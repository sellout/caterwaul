{- TODO: This currently forces ùí± = ùêíùêûùê≠, because of the Hom instance. It would be
         good to abstract that via composition with some symmetric category,
         like `category.product (hom.map a b) flip`.
-}
let kCat = ./../Cat/semigroupal

let vObject = Type

let v =
      ./../Monoidal/Cartesian/extractMonoidal
        kCat
        Type
        vObject
        ./../Set/monoidal/cartesian

in    Œª(object : Kind)
    ‚Üí Œª(cat : ./../Kind kCat vObject object)
    ‚Üí Œª(category : ./../Type object v cat)
    ‚Üí let Op = ./Kind vObject object cat
      
      in    { unit =
                category.unit
            , product =
                  Œª(a : { _1 : object, _2 : object })
                ‚Üí Œª ( p
                    :   ‚àÄ(r : Type)
                      ‚Üí (   ‚àÄ(z : object)
                          ‚Üí Op.arrow { _1 = z, _2 = a._2 }
                          ‚Üí Op.arrow { _1 = a._1, _2 = z }
                          ‚Üí r
                        )
                      ‚Üí r
                    )
                ‚Üí category.product
                    { _1 = a._2, _2 = a._1 }
                    (   Œª(r : Type)
                      ‚Üí Œª ( arrowsOut
                          :   ‚àÄ(z : object)
                            ‚Üí cat.arrow { _1 = z, _2 = a._1 }
                            ‚Üí cat.arrow { _1 = a._2, _2 = z }
                            ‚Üí r
                          )
                      ‚Üí p
                          r
                          (   Œª(z : object)
                            ‚Üí Œª(f : Op.arrow { _1 = z, _2 = a._2 })
                            ‚Üí Œª(g : Op.arrow { _1 = a._1, _2 = z })
                            ‚Üí arrowsOut z g f
                          )
                    )
            , hom =
                { map =
                      Œª(a : { _1 : object, _2 : object })
                    ‚Üí Œª(b : { _1 : object, _2 : object })
                    ‚Üí Œª ( f
                        : { _1 :
                              cat.arrow { _1 = a._1, _2 = b._1 }
                          , _2 :
                              cat.arrow { _1 = b._2, _2 = a._2 }
                          }
                        )
                    ‚Üí category.hom.map
                        { _1 = a._2, _2 = a._1 }
                        { _1 = b._2, _2 = b._1 }
                        { _1 = f._2, _2 = f._1 }
                }
            }
          : ./../Type object v Op
