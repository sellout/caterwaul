{- FIXME: The `hom` profunctor should be implementable generically, however I
          canâ€˜t currently get it to compile with Dhall, so itâ€™s a member here,
          and every implementation is basically a copy/paste of
         `compose (compose f g) h`. Embedding the definition here also basically
          forces every category to be enriched over ğ’ğğ­.
-}

let kCat = ./../Category/Cat/semigroupal

let vObject = Type

in    Î»(object : Kind)
    â†’ Î»(v : ./../Category/Monoidal/Kind kCat Type vObject)
    â†’ Î»(cat : ./../Category/Kind kCat vObject object)
    â†’ Î»(m : kCat.arrow (kCat.product object object) vObject)
    â†’ let profunctor = kCat.arrow (kCat.product object object) vObject
      
      in    { hom : ./../Functor/Profunctor/Type object object v cat cat m }
          â©“ ./../Semigroup/Type
              profunctor
              (./../Category/Profunctor/semigroupal object v cat)
              m
