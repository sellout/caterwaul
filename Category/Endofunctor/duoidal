{- NB: This is defined in terms of the monoidal categories instead of the other
       way around because this is more restrictive than either monoidal
       category.
     • Applicative requires that the target category is **Set** and
     • monadic requires an endofunctor`object`.
       When you combine these two restrictions, you end up only being able to
       support endofunctors in **Set**.
-}
let kArrow = ./../../Function/Kind

let kProduct = ./../../Tuple/Kind

let vObject = Type

let object = Type

in    λ(v : ./../../Category/Kind kArrow kProduct Type vObject)
    → λ(cat : ./../../Category/Monoidal/Kind kArrow kProduct vObject object)
    → let applicative = ./../Functor/monoidal object v cat cat
      
      let monadic =
            ./monoidal/monadic
            object
            v
            ( ./../../Category/Monoidal/extractCategory
              kArrow
              kProduct
              vObject
              object
              cat
            )
      
      in    { constraint =
                monadic.constraint
            , arrow =
                applicative.arrow
            , additive =
                { identity = applicative.identity, op = applicative.op }
            , multiplicative =
                { identity = monadic.identity, op = monadic.op }
            }
          : ./../Duoidal/Kind kArrow kProduct vObject (kArrow object object)
