let kArrow = ./../../Function/Kind

let kProduct = ./../../Tuple/Kind

let vObject = Type

let object = Type

in    { constraint =
          λ(t : object) → ./../../Const/Type object object { _1 = {}, _2 = t }
      , arrow =
          λ(a : { _1 : object, _2 : object }) → a._1 → a._2
      , additive =
          { identity =
              <>
          , op =
                λ(a : { _1 : object, _2 : object })
              → < Left : a._1 | Right : a._2 >
          }
      , multiplicative =
          { identity =
              {}
          , op =
              λ(a : { _1 : Type, _2 : Type }) → { _1 : a._1, _2 : a._2 }
          }
      }
    : ./../Rig/Kind kArrow kProduct vObject object
