{- NB: This doesn’t use `Duoidal/extractMultiplicative` because that has a fixed
      `object`.
-}
let kArrow = ./../../../Function/Kind

let kProduct = ./../../../Tuple/Kind

let Category = ./../../Kind kArrow kProduct

let Endofunctor = ./../../../Functor/Endo/Type

let vObject = Type

in    λ(object : Kind)
    → λ(v : Category Type vObject)
    → λ(cat : Category vObject object)
    →   { constraint =
            Endofunctor vObject object v cat
        , arrow =
            ./../../../NaturalTransformation/Type object object cat
        , identity =
            ./../../../Identity/Type object
        , op =
            ./../../../Compose/Type object object object
        }
      : ./../../Monoidal/Kind kArrow kProduct vObject (kArrow object object)
