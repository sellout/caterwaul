{- Any functor `p : C → C'` induces a functor between functor categories
  `[C', D] → [C, D]`.
-}
let cat =
      ./../Cat/semigroupal sha256:de5b05c9640ea3ca0ee586c7102a982db79d3c0f0c92230cb2df19c7b986b513

let Category =
      ./../Kind sha256:c73426d12cddcdfc44b6e687fc897f7ef91fcda0c4da116a91acdca4d15c68a2
      cat

let Compose =
      ./../../Compose/Type sha256:e830545569ce8ba04d3124a7ca93994fc93e18c0372616f45910253f0a00907d

let Functor =
      ./../../Functor/Type sha256:bebd999f32d6a3fd9bd7151ca5f0942ed6aeded30809c4a7e6c91382bed2dbcb

let FunctorCategory =
      ./category sha256:c69163eac75892504c9b6fd8b9637704c20e0baa23c5d428ecfb2b4587414bef

let NaturalTransformation =
      ./../../NaturalTransformation/Type sha256:ae103806c5d0da8f35ba65b9c08afdcc86ed1d5d71eb2ed4a0d631119df51bbc

let Set =
      ./../Set/monoidal/cartesian sha256:3a79a17d1c39a3df58efcc62fd96a2da0147bb29b524f57aa7c35942f653f164

let vObject = Type

let v = Set.{ arrow, constraint }

in    λ(cObject : Kind)
    → λ(c : Category vObject cObject)
    → λ(cpObject : Kind)
    → λ(cp : Category vObject cpObject)
    → λ(p : cat.arrow cObject cpObject)
    → λ(dObject : Kind)
    → λ(d : Category vObject dObject)
    →   { map =
              λ(a : cat.arrow cpObject dObject)
            → λ(b : cat.arrow cpObject dObject)
            → λ ( fn
                : NaturalTransformation cpObject dObject d { _1 = a, _2 = b }
                )
            → λ(i : cObject)
            → fn (p i)
        }
      : Functor
        vObject
        (cat.arrow cpObject dObject)
        (cat.arrow cObject dObject)
        v
        (FunctorCategory cpObject dObject v cp d)
        (FunctorCategory cObject dObject v c d)
        (   λ(h : cat.arrow cpObject dObject)
          → Compose cObject cpObject dObject { _1 = h, _2 = p }
        )
