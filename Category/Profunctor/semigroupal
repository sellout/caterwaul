{- This doesn’t use `extractSemigroupal` because I don’t know how to apply the
  `morphism` in the monoidal category instance.
-}
let kArrow = ./../../Function/Kind

let kProduct = ./../../Tuple/Kind

let vObject = Type

in    λ(object : Kind)
    → λ(v : ./../../Category/Monoidal/Kind kArrow kProduct Type vObject)
    → λ(cat : ./../Kind kArrow kProduct vObject object)
    → let profunctor = kArrow (kProduct object object) vObject
      
      in    { constraint =
                ./../../Functor/Profunctor/Type object object v cat cat
            , arrow =
                  λ(p : { _1 : profunctor, _2 : profunctor })
                → ∀(a : { _1 : object, _2 : object }) → p._1 a → p._2 a
            , op =
                  λ(p : { _1 : profunctor, _2 : profunctor })
                → λ(a : { _1 : object, _2 : object })
                →   ∀(r : Type)
                  → (   ∀(z : object)
                      → p._1 { _1 = z, _2 = a._2 }
                      → p._2 { _1 = a._1, _2 = z }
                      → r
                    )
                  → r
            }
          : ./../Semigroupal/Kind kArrow kProduct vObject profunctor
