{- This cheats a bit on the identity, since `dObject` is Type, we don‚Äôt need a
   functor **Set** ‚Üí ùíü.
-}
let kArrow = ./../../Function/Kind

let kProduct = ./../../Tuple/Kind

let MonoidalCategory = ./../Monoidal/Kind kArrow kProduct

let cObject = Type

let dObject = Type

let c = ./../Set/monoidal/cartesian

let d = ./../Set/monoidal/cartesian

let Day = ./../../Day/Type cObject c d

let object = kArrow cObject dObject

let functorCategory = ./monoidal cObject c d

in    { associativity =
            Œª(a : object)
          ‚Üí Œª(_ : functorCategory.constraint a)
          ‚Üí Œª(b : object)
          ‚Üí Œª(_ : functorCategory.constraint b)
          ‚Üí Œª(e : object)
          ‚Üí Œª(_ : functorCategory.constraint e)
          ‚Üí { to =
                  Œª(i : cObject)
                ‚Üí Œª(day : Day { _1 = Day { _1 = a, _2 = b }, _2 = e } i)
                ‚Üí Œª(r : Type)
                ‚Üí Œª ( convolute
                    :   ‚àÄ(f : { _1 : cObject, _2 : cObject })
                      ‚Üí c.arrow { _1 = c.op f, _2 = i }
                      ‚Üí d.op { _1 = a f._1, _2 = Day { _1 = b, _2 = e } f._2 }
                      ‚Üí r
                    )
                ‚Üí day r
            , from =
                  Œª(i : cObject)
                ‚Üí Œª(day : Day { _1 = a, _2 = Day { _1 = b, _2 = e } } i)
                ‚Üí Œª(r : Type)
                ‚Üí Œª ( convolute
                    :   ‚àÄ(f : { _1 : cObject, _2 : cObject })
                      ‚Üí c.arrow { _1 = c.op f, _2 = i }
                      ‚Üí d.op { _1 = Day { _1 = a, _2 = b } f._1, _2 = e f._2 }
                      ‚Üí r
                    )
                ‚Üí day r
            }
      , leftIdentity =
            Œª(a : object)
          ‚Üí Œª(functor : functorCategory.constraint a)
          ‚Üí { to =
                  Œª(i : cObject)
                ‚Üí Œª ( day
                    : Day
                      { _1 =
                          Œª(x : cObject) ‚Üí c.arrow { _1 = c.identity, _2 = x }
                      , _2 =
                          a
                      }
                      i
                    )
                ‚Üí day
                  (a i)
                  (   Œª(b : { _1 : cObject, _2 : cObject })
                    ‚Üí Œª(fn : c.arrow { _1 = c.op b, _2 = i })
                    ‚Üí Œª ( prod
                        : d.op
                          { _1 =
                              c.arrow { _1 = c.identity, _2 = b._1 }
                          , _2 =
                              a b._2
                          }
                        )
                    ‚Üí functor.map
                      b._2
                      i
                      (Œª(x : b._2) ‚Üí fn { _1 = prod._1 {=}, _2 = x })
                      prod._2
                  )
            , from =
                  Œª(i : cObject)
                ‚Üí Œª(x : a i)
                ‚Üí Œª(r : Type)
                ‚Üí Œª ( day
                    :   ‚àÄ(b : { _1 : cObject, _2 : cObject })
                      ‚Üí c.arrow { _1 = c.op b, _2 = i }
                      ‚Üí d.op
                        { _1 =
                            c.arrow { _1 = c.identity, _2 = b._1 }
                        , _2 =
                            a b._2
                        }
                      ‚Üí r
                    )
                ‚Üí day
                  { _1 = c.identity, _2 = i }
                  (Œª(p : { _1 : c.identity, _2 : i }) ‚Üí p._2)
                  { _1 = Œª(y : c.identity) ‚Üí y, _2 = x }
            }
      , rightIdentity =
            Œª(a : object)
          ‚Üí Œª(functor : functorCategory.constraint a)
          ‚Üí { to =
                  Œª(i : cObject)
                ‚Üí Œª ( day
                    : Day
                      { _1 =
                          a
                      , _2 =
                          Œª(x : cObject) ‚Üí c.arrow { _1 = c.identity, _2 = x }
                      }
                      i
                    )
                ‚Üí day
                  (a i)
                  (   Œª(b : { _1 : cObject, _2 : cObject })
                    ‚Üí Œª(fn : c.arrow { _1 = c.op b, _2 = i })
                    ‚Üí Œª ( prod
                        : d.op
                          { _1 =
                              a b._1
                          , _2 =
                              c.arrow { _1 = c.identity, _2 = b._2 }
                          }
                        )
                    ‚Üí functor.map
                      b._1
                      i
                      (Œª(x : b._1) ‚Üí fn { _1 = x, _2 = prod._2 {=} })
                      prod._1
                  )
            , from =
                  Œª(i : cObject)
                ‚Üí Œª(x : a i)
                ‚Üí Œª(r : Type)
                ‚Üí Œª ( convolute
                    :   ‚àÄ(b : { _1 : cObject, _2 : cObject })
                      ‚Üí c.arrow { _1 = c.op b, _2 = i }
                      ‚Üí d.op
                        { _1 =
                            a b._1
                        , _2 =
                            c.arrow { _1 = c.identity, _2 = b._2 }
                        }
                      ‚Üí r
                    )
                ‚Üí convolute
                  { _1 = i, _2 = c.identity }
                  (Œª(p : { _1 : i, _2 : c.identity }) ‚Üí p._1)
                  { _1 = x, _2 = Œª(y : c.identity) ‚Üí y }
            }
      }
    : ./../Monoidal/Laws object functorCategory
