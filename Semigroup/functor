let kArrow = ./../Function/Kind

let kProduct = ./../Tuple/Kind

let vObject = Type

let v = ./../Category/Set/monoidal/cartesian

let vBase =
      ./../Category/Monoidal/extractCategory kArrow kProduct Type vObject v

in    λ(object : Kind)
    → λ(cat : ./../Category/Semigroupal/Kind kArrow kProduct vObject object)
    → let catBase =
            ./../Category/Semigroupal/extractCategory
            kArrow
            kProduct
            vObject
            object
            cat
      
      in    λ(semigroupoid : ./../Semigroupoid/Type object v catBase cat.arrow)
          → λ ( bifunctor
              : ./../Functor/Pair/Type vObject object v catBase cat.op
              )
          → let Semigroup = ./Type object cat
            
            let Dagger = ./../Category/Dagger/Kind object catBase
            
            in    { map =
                        λ(a : object)
                      → λ(b : object)
                      → λ(fn : Dagger.arrow { _1 = a, _2 = b })
                      → λ(fa : Semigroup a)
                      → { op =
                            semigroupoid.op
                            { _1 = cat.op { _1 = b, _2 = b }, _2 = b }
                            (   λ(r : Type)
                              → λ ( arrowsOut
                                  :   ∀(z : object)
                                    → cat.arrow { _1 = z, _2 = b }
                                    → cat.arrow
                                      { _1 = cat.op { _1 = b, _2 = b }, _2 = z }
                                    → r
                                  )
                              → arrowsOut
                                a
                                fn.to
                                ( semigroupoid.op
                                  { _1 = cat.op { _1 = b, _2 = b }, _2 = a }
                                  (   λ(r : Type)
                                    → λ ( arrowsOut
                                        :   ∀(z : object)
                                          → cat.arrow { _1 = z, _2 = a }
                                          → cat.arrow
                                            { _1 =
                                                cat.op { _1 = b, _2 = b }
                                            , _2 =
                                                z
                                            }
                                          → r
                                        )
                                    → arrowsOut
                                      (cat.op { _1 = a, _2 = a })
                                      fa.op
                                      ( bifunctor.map
                                        { _1 = b, _2 = b }
                                        { _1 = a, _2 = a }
                                        { _1 = fn.from, _2 = fn.from }
                                      )
                                  )
                                )
                            )
                        }
                  }
                : ./../Functor/SetValued object vBase Dagger Semigroup
