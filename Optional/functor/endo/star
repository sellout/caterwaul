let kArrow = ./../../../Function/Kind

let kProduct = ./../../../Tuple/Kind

let base = ./../../../Category/Monoidal/extractCategory kArrow kProduct

let vObject = Type

let v = base Type vObject ./../../../Category/Set/monoidal/cartesian

let object = Type

let cat = ./../../../Category/Set/monoidal/cartesian

in    λ(m : kArrow object object)
    → λ(monoidal : ./../../../Functor/Monoidal/Type object v cat cat m)
    →   { map =
              λ(a : object)
            → λ(b : object)
            → λ(f : cat.arrow { _1 = a, _2 = m b })
            → λ(fa : Optional a)
            → Optional/fold
              a
              fa
              (m (Optional b))
              (   λ(x : a)
                → ( ./../../../Functor/Monoidal/extractFunctor
                    Type
                    v
                    cat
                    cat
                    m
                    monoidal
                  ).map
                  b
                  (Optional b)
                  (λ(y : b) → Some y)
                  (f x)
              )
              (monoidal.identity (Optional b) (λ(_ : cat.identity) → None b))
        }
      : ./../../../Functor/Endo/Star/Type
        vObject
        object
        v
        (base vObject object cat)
        m
        Optional
