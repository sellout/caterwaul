<html>
<head>
<title>caterwaul</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>
<h1>caterwaul</h1>
<h1 style="background-color: #bbb; width: 100%">.</h1>
<h2 style="background-color: #bbb; width: 100%">./Adjunction</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ ∀(f : dObject → cObject)
→ ∀(g : cObject → dObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ λ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ λ(f : dObject → cObject)
→ λ(g : cObject → dObject)
→ { counit :
      ∀(a : cObject) → c.arrow { _1 = f (g a), _2 = a }
  , leftAdjunct :
        ∀(a : dObject)
      → ∀(b : cObject)
      → c.arrow { _1 = f a, _2 = b }
      → d.arrow { _1 = a, _2 = g b }
  , rightAdjunct :
        ∀(a : dObject)
      → ∀(b : cObject)
      → d.arrow { _1 = a, _2 = g b }
      → c.arrow { _1 = f a, _2 = b }
  , unit :
      ∀(a : dObject) → d.arrow { _1 = a, _2 = g (f a) }
  }
</pre></dd>
</dl>
<h4>impliedComonad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ ∀(f : dObject → cObject)
→ ∀ ( functor
    : { map :
            dObject
          → dObject
          → d.arrow { _1 = _@1, _2 = _ }
          → c.arrow { _1 = f _@2, _2 = f _@1 }
      }
    )
→ ∀(g : cObject → dObject)
→ ∀ ( adjunction
    : { counit :
          cObject → c.arrow { _1 = f (g _), _2 = _ }
      , leftAdjunct :
            dObject
          → cObject
          → c.arrow { _1 = f _@1, _2 = _ }
          → d.arrow { _1 = _@2, _2 = g _@1 }
      , rightAdjunct :
            dObject
          → cObject
          → d.arrow { _1 = _@1, _2 = g _ }
          → c.arrow { _1 = f _@2, _2 = _@1 }
      , unit :
          dObject → d.arrow { _1 = _, _2 = g (f _) }
      }
    )
→ { identity :
      cObject → c.arrow { _1 = f (g _), _2 = _ }
  , op :
      ∀(a : cObject) → c.arrow { _1 = f (g a), _2 = f (g (f (g a))) }
  }
</pre></dd>
</dl>
<h4>impliedMonad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ ∀(f : dObject → cObject)
→ ∀(g : cObject → dObject)
→ ∀ ( functor
    : { map :
            cObject
          → cObject
          → c.arrow { _1 = _@1, _2 = _ }
          → d.arrow { _1 = g _@2, _2 = g _@1 }
      }
    )
→ ∀ ( adjunction
    : { counit :
          cObject → c.arrow { _1 = f (g _), _2 = _ }
      , leftAdjunct :
            dObject
          → cObject
          → c.arrow { _1 = f _@1, _2 = _ }
          → d.arrow { _1 = _@2, _2 = g _@1 }
      , rightAdjunct :
            dObject
          → cObject
          → d.arrow { _1 = _@1, _2 = g _ }
          → c.arrow { _1 = f _@2, _2 = _@1 }
      , unit :
          dObject → d.arrow { _1 = _, _2 = g (f _) }
      }
    )
→ { identity :
      dObject → d.arrow { _1 = _, _2 = g (f _) }
  , op :
      ∀(a : dObject) → d.arrow { _1 = g (f (g (f a))), _2 = g (f a) }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Arrow</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ { fanout :
        ∀(a : object)
      → ∀(b : object)
      → ∀(c : object)
      → cat.arrow { _1 = a, _2 = b }
      → cat.arrow { _1 = a, _2 = c }
      → cat.arrow { _1 = a, _2 = cat.op { _1 = b, _2 = c } }
  , identity :
      object → cat.arrow { _1 = _, _2 = _ }
  , lmap :
        object
      → object
      → object
      → cat.arrow { _1 = _@1, _2 = _@2 }
      → cat.arrow { _1 = _@3, _2 = _@1 }
      → cat.arrow { _1 = _@3, _2 = _@2 }
  , map :
        { _1 : object, _2 : object }
      → { _1 : object, _2 : object }
      → v.arrow
        { _1 =
            v.op
            { _1 =
                cat.arrow { _1 = _._1, _2 = _@1._1 }
            , _2 =
                cat.arrow { _1 = _@1._2, _2 = _._2 }
            }
        , _2 =
            v.arrow { _1 = cat.arrow _@1, _2 = cat.arrow _ }
        }
  , op :
        { _1 : object, _2 : object }
      → (   Type
          → (   object
              → cat.arrow { _1 = _, _2 = _@2._2 }
              → cat.arrow { _1 = _@3._1, _2 = _@1 }
              → _@3
            )
          → _@1
        )
      → cat.arrow _@1
  , rmap :
        object
      → object
      → object
      → cat.arrow { _1 = _@1, _2 = _ }
      → cat.arrow { _1 = _@3, _2 = _@2 }
      → cat.arrow { _1 = _@4, _2 = _@2 }
  , split :
        ∀(a : object)
      → ∀(b : object)
      → ∀(c : object)
      → ∀(d : object)
      → cat.arrow { _1 = a, _2 = b }
      → cat.arrow { _1 = c, _2 = d }
      → cat.arrow
        { _1 = cat.op { _1 = a, _2 = c }, _2 = cat.op { _1 = b, _2 = d } }
  }
</pre></dd>
</dl>
<h4>extractCategory (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀ ( arrow
    : { fanout :
            object
          → object
          → object
          → cat.arrow { _1 = _@2, _2 = _@1 }
          → cat.arrow { _1 = _@3, _2 = _@1 }
          → cat.arrow { _1 = _@4, _2 = cat.op { _1 = _@3, _2 = _@2 } }
      , identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , lmap :
            object
          → object
          → object
          → cat.arrow { _1 = _@1, _2 = _@2 }
          → cat.arrow { _1 = _@3, _2 = _@1 }
          → cat.arrow { _1 = _@3, _2 = _@2 }
      , map :
            { _1 : object, _2 : object }
          → { _1 : object, _2 : object }
          → v.arrow
            { _1 =
                v.op
                { _1 =
                    cat.arrow { _1 = _._1, _2 = _@1._1 }
                , _2 =
                    cat.arrow { _1 = _@1._2, _2 = _._2 }
                }
            , _2 =
                v.arrow { _1 = cat.arrow _@1, _2 = cat.arrow _ }
            }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      , rmap :
            object
          → object
          → object
          → cat.arrow { _1 = _@1, _2 = _ }
          → cat.arrow { _1 = _@3, _2 = _@2 }
          → cat.arrow { _1 = _@4, _2 = _@2 }
      , split :
            object
          → object
          → object
          → object
          → cat.arrow { _1 = _@3, _2 = _@2 }
          → cat.arrow { _1 = _@2, _2 = _@1 }
          → cat.arrow
            { _1 =
                cat.op { _1 = _@5, _2 = _@3 }
            , _2 =
                cat.op { _1 = _@4, _2 = _@2 }
            }
      }
    )
→ { identity :
      object → cat.arrow { _1 = _, _2 = _ }
  , op :
        { _1 : object, _2 : object }
      → (   Type
          → (   object
              → cat.arrow { _1 = _, _2 = _@2._2 }
              → cat.arrow { _1 = _@3._1, _2 = _@1 }
              → _@3
            )
          → _@1
        )
      → cat.arrow _@1
  }
</pre></dd>
</dl>
<h4>extractProfunctor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀ ( arrow
    : { fanout :
            object
          → object
          → object
          → cat.arrow { _1 = _@2, _2 = _@1 }
          → cat.arrow { _1 = _@3, _2 = _@1 }
          → cat.arrow { _1 = _@4, _2 = cat.op { _1 = _@3, _2 = _@2 } }
      , identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , lmap :
            object
          → object
          → object
          → cat.arrow { _1 = _@1, _2 = _@2 }
          → cat.arrow { _1 = _@3, _2 = _@1 }
          → cat.arrow { _1 = _@3, _2 = _@2 }
      , map :
            { _1 : object, _2 : object }
          → { _1 : object, _2 : object }
          → v.arrow
            { _1 =
                v.op
                { _1 =
                    cat.arrow { _1 = _._1, _2 = _@1._1 }
                , _2 =
                    cat.arrow { _1 = _@1._2, _2 = _._2 }
                }
            , _2 =
                v.arrow { _1 = cat.arrow _@1, _2 = cat.arrow _ }
            }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      , rmap :
            object
          → object
          → object
          → cat.arrow { _1 = _@1, _2 = _ }
          → cat.arrow { _1 = _@3, _2 = _@2 }
          → cat.arrow { _1 = _@4, _2 = _@2 }
      , split :
            object
          → object
          → object
          → object
          → cat.arrow { _1 = _@3, _2 = _@2 }
          → cat.arrow { _1 = _@2, _2 = _@1 }
          → cat.arrow
            { _1 =
                cat.op { _1 = _@5, _2 = _@3 }
            , _2 =
                cat.op { _1 = _@4, _2 = _@2 }
            }
      }
    )
→ { map :
        { _1 : object, _2 : object }
      → { _1 : object, _2 : object }
      → v.arrow
        { _1 =
            v.op
            { _1 =
                cat.arrow { _1 = _._1, _2 = _@1._1 }
            , _2 =
                cat.arrow { _1 = _@1._2, _2 = _._2 }
            }
        , _2 =
            v.arrow { _1 = cat.arrow _@1, _2 = cat.arrow _ }
        }
  }
</pre></dd>
</dl>
<h4>extractSemigroupoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀ ( arrow
    : { fanout :
            object
          → object
          → object
          → cat.arrow { _1 = _@2, _2 = _@1 }
          → cat.arrow { _1 = _@3, _2 = _@1 }
          → cat.arrow { _1 = _@4, _2 = cat.op { _1 = _@3, _2 = _@2 } }
      , identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , lmap :
            object
          → object
          → object
          → cat.arrow { _1 = _@1, _2 = _@2 }
          → cat.arrow { _1 = _@3, _2 = _@1 }
          → cat.arrow { _1 = _@3, _2 = _@2 }
      , map :
            { _1 : object, _2 : object }
          → { _1 : object, _2 : object }
          → v.arrow
            { _1 =
                v.op
                { _1 =
                    cat.arrow { _1 = _._1, _2 = _@1._1 }
                , _2 =
                    cat.arrow { _1 = _@1._2, _2 = _._2 }
                }
            , _2 =
                v.arrow { _1 = cat.arrow _@1, _2 = cat.arrow _ }
            }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      , rmap :
            object
          → object
          → object
          → cat.arrow { _1 = _@1, _2 = _ }
          → cat.arrow { _1 = _@3, _2 = _@2 }
          → cat.arrow { _1 = _@4, _2 = _@2 }
      , split :
            object
          → object
          → object
          → object
          → cat.arrow { _1 = _@3, _2 = _@2 }
          → cat.arrow { _1 = _@2, _2 = _@1 }
          → cat.arrow
            { _1 =
                cat.op { _1 = _@5, _2 = _@3 }
            , _2 =
                cat.op { _1 = _@4, _2 = _@2 }
            }
      }
    )
→ { op :
        { _1 : object, _2 : object }
      → (   Type
          → (   object
              → cat.arrow { _1 = _, _2 = _@2._2 }
              → cat.arrow { _1 = _@3._1, _2 = _@1 }
              → _@3
            )
          → _@1
        )
      → cat.arrow _@1
  }
</pre></dd>
</dl>
<h4>extractStrong (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀ ( arrow
    : { fanout :
            object
          → object
          → object
          → cat.arrow { _1 = _@2, _2 = _@1 }
          → cat.arrow { _1 = _@3, _2 = _@1 }
          → cat.arrow { _1 = _@4, _2 = cat.op { _1 = _@3, _2 = _@2 } }
      , identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , lmap :
            object
          → object
          → object
          → cat.arrow { _1 = _@1, _2 = _@2 }
          → cat.arrow { _1 = _@3, _2 = _@1 }
          → cat.arrow { _1 = _@3, _2 = _@2 }
      , map :
            { _1 : object, _2 : object }
          → { _1 : object, _2 : object }
          → v.arrow
            { _1 =
                v.op
                { _1 =
                    cat.arrow { _1 = _._1, _2 = _@1._1 }
                , _2 =
                    cat.arrow { _1 = _@1._2, _2 = _._2 }
                }
            , _2 =
                v.arrow { _1 = cat.arrow _@1, _2 = cat.arrow _ }
            }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      , rmap :
            object
          → object
          → object
          → cat.arrow { _1 = _@1, _2 = _ }
          → cat.arrow { _1 = _@3, _2 = _@2 }
          → cat.arrow { _1 = _@4, _2 = _@2 }
      , split :
            object
          → object
          → object
          → object
          → cat.arrow { _1 = _@3, _2 = _@2 }
          → cat.arrow { _1 = _@2, _2 = _@1 }
          → cat.arrow
            { _1 =
                cat.op { _1 = _@5, _2 = _@3 }
            , _2 =
                cat.op { _1 = _@4, _2 = _@2 }
            }
      }
    )
→ { lmap :
        object
      → object
      → object
      → cat.arrow { _1 = _@1, _2 = _@2 }
      → cat.arrow { _1 = _@3, _2 = _@1 }
      → cat.arrow { _1 = _@3, _2 = _@2 }
  , map :
        { _1 : object, _2 : object }
      → { _1 : object, _2 : object }
      → v.arrow
        { _1 =
            v.op
            { _1 =
                cat.arrow { _1 = _._1, _2 = _@1._1 }
            , _2 =
                cat.arrow { _1 = _@1._2, _2 = _._2 }
            }
        , _2 =
            v.arrow { _1 = cat.arrow _@1, _2 = cat.arrow _ }
        }
  , rmap :
        object
      → object
      → object
      → cat.arrow { _1 = _@1, _2 = _ }
      → cat.arrow { _1 = _@3, _2 = _@2 }
      → cat.arrow { _1 = _@4, _2 = _@2 }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Bimonad</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(v : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ (object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(v : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ λ(_ : object → object)
→ { comonoid :
      { identity :
          object → cat.arrow { _1 = _@1 _, _2 = _ }
      , op :
          object → cat.arrow { _1 = _@1 _, _2 = _@1 (_@1 _) }
      }
  , monoid :
      { identity :
          object → cat.arrow { _1 = _, _2 = _@1 _ }
      , op :
          object → cat.arrow { _1 = _@1 (_@1 _), _2 = _@1 _ }
      }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Bimonoid</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { comonoid :
      { identity :
          cat.arrow { _1 = m, _2 = cat.identity }
      , op :
          cat.arrow { _1 = m, _2 = cat.op { _1 = m, _2 = m } }
      }
  , monoid :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Bool</h2>
<h4>eq (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ eq : ∀(x : Bool) → ∀(y : Bool) → Bool }
</pre></dd>
</dl>
<h4>lattice (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ join :
    { identity : {} → Bool, op : ∀(p : { _1 : Bool, _2 : Bool }) → Bool }
, meet :
    { identity : {} → Bool, op : ∀(p : { _1 : Bool, _2 : Bool }) → Bool }
}
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Bool/monoid</h3>
<h4>conjunction (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ identity : {} → Bool, op : { _1 : Bool, _2 : Bool } → Bool }
</pre></dd>
</dl>
<h4>disjunction (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ identity : {} → Bool, op : { _1 : Bool, _2 : Bool } → Bool }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Category</h2>
<h3 style="background-color: #bbb; width: 100%">./Category/Cartesian</h3>
<h4>Kind (kind)</h4>
<p>{- Can’t define `augmentation` at this level, because we have no unit `Kind`.
-}</p>
<dl>
<dt>sort</dt><dd><pre>
∀(kArrow : Kind → Kind → Kind) → ∀(vObject : Kind) → ∀(object : Kind) → Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(vObject : Kind)
→ λ(object : Kind)
→ { arrow :
      kArrow { _1 : object, _2 : object } vObject
  , constraint :
      object → Type
  , diagonal :
      kArrow object { _1 : object, _2 : object }
  , identity :
      object
  , op :
      kArrow { _1 : object, _2 : object } object
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { category :
      { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
  , comonoid :
      { identity :
          cat.arrow { _1 = m, _2 = cat.identity }
      , op :
          cat.arrow { _1 = m, _2 = cat.op { _1 = m, _2 = m } }
      }
  , monoid :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>extractCategory (term)</h4>
<p>{- FIXME: Should be able to do `cartesian.{ arrow, op }`, but Dhall doesn’t like
          that for some reason.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( cartesian
    : { arrow :
          kArrow (kProduct object object) vObject
      , constraint :
          object → Type
      , diagonal :
          kArrow object (kProduct object object)
      , identity :
          object
      , op :
          kArrow (kProduct object object) object
      }
    )
→ { arrow :
      kArrow (kProduct object object) vObject
  , constraint :
      object → Type
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Closed</h3>
<h4>Kind (kind)</h4>
<p>{- A category enriched over itself.
-}</p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(object : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(object : Kind)
→ { arrow : kArrow (kProduct object object) object, constraint : object → Type }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Dagger</h3>
<h4>Kind (term)</h4>
<p>{- A true †-category has a contravariant endofunctor on C that reverses the
   morphisms. I’m not sure how to implement that, so this structure simply uses
   pairs of morphisms as the morphism.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ { arrow : { _1 : object, _2 : object } → Type, constraint : object → Type }
</pre></dd>
</dl>
<h4>category (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ∀ ( category
    : { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ { identity :
        ∀(a : object)
      → { from :
            cat.arrow { _1 = a, _2 = a }
        , to :
            cat.arrow { _1 = a, _2 = a }
        }
  , op :
        ∀(a : { _1 : object, _2 : object })
      → ∀ ( p
          :   ∀(r : Type)
            → (   ∀(z : object)
                → { from :
                      cat.arrow { _1 = a._2, _2 = z }
                  , to :
                      cat.arrow { _1 = z, _2 = a._2 }
                  }
                → { from :
                      cat.arrow { _1 = z, _2 = a._1 }
                  , to :
                      cat.arrow { _1 = a._1, _2 = z }
                  }
                → r
              )
            → r
          )
      → { from : cat.arrow { _1 = a._2, _2 = a._1 }, to : cat.arrow a }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Duoidal</h3>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(vObject : Kind)
→ ∀(object : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(vObject : Kind)
→ λ(object : Kind)
→ { additive :
      { identity : object, op : kArrow (kProduct object object) object }
  , arrow :
      kArrow (kProduct object object) vObject
  , constraint :
      object → Type
  , multiplicative :
      { identity : object, op : kArrow (kProduct object object) object }
  }
</pre></dd>
</dl>
<h4>Laws (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { additive :
          { identity : object, op : { _1 : object, _2 : object } → object }
      , arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , multiplicative :
          { identity : object, op : { _1 : object, _2 : object } → object }
      }
    )
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { additive :
          { identity : object, op : { _1 : object, _2 : object } → object }
      , arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , multiplicative :
          { identity : object, op : { _1 : object, _2 : object } → object }
      }
    )
→ { additive :
      { associativity :
            object
          → object
          → object
          → { from :
                cat.arrow
                { _1 =
                    cat.additive.op
                    { _1 = _@2, _2 = cat.additive.op { _1 = _@1, _2 = _ } }
                , _2 =
                    cat.additive.op
                    { _1 = cat.additive.op { _1 = _@2, _2 = _@1 }, _2 = _ }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.additive.op
                    { _1 = cat.additive.op { _1 = _@2, _2 = _@1 }, _2 = _ }
                , _2 =
                    cat.additive.op
                    { _1 = _@2, _2 = cat.additive.op { _1 = _@1, _2 = _ } }
                }
            }
      , leftIdentity :
            object
          → { from :
                cat.arrow
                { _1 =
                    _
                , _2 =
                    cat.additive.op { _1 = cat.additive.identity, _2 = _ }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.additive.op { _1 = cat.additive.identity, _2 = _ }
                , _2 =
                    _
                }
            }
      , rightIdentity :
            object
          → { from :
                cat.arrow
                { _1 =
                    _
                , _2 =
                    cat.additive.op { _1 = _, _2 = cat.additive.identity }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.additive.op { _1 = _, _2 = cat.additive.identity }
                , _2 =
                    _
                }
            }
      }
  , combine :
      cat.arrow
      { _1 =
          cat.additive.op
          { _1 = cat.multiplicative.identity, _2 = cat.multiplicative.identity }
      , _2 =
          cat.multiplicative.identity
      }
  , multiplicative :
      { associativity :
            object
          → object
          → object
          → { from :
                cat.arrow
                { _1 =
                    cat.multiplicative.op
                    { _1 =
                        _@2
                    , _2 =
                        cat.multiplicative.op { _1 = _@1, _2 = _ }
                    }
                , _2 =
                    cat.multiplicative.op
                    { _1 =
                        cat.multiplicative.op { _1 = _@2, _2 = _@1 }
                    , _2 =
                        _
                    }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.multiplicative.op
                    { _1 =
                        cat.multiplicative.op { _1 = _@2, _2 = _@1 }
                    , _2 =
                        _
                    }
                , _2 =
                    cat.multiplicative.op
                    { _1 =
                        _@2
                    , _2 =
                        cat.multiplicative.op { _1 = _@1, _2 = _ }
                    }
                }
            }
      , leftIdentity :
            object
          → { from :
                cat.arrow
                { _1 =
                    _
                , _2 =
                    cat.multiplicative.op
                    { _1 = cat.multiplicative.identity, _2 = _ }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.multiplicative.op
                    { _1 = cat.multiplicative.identity, _2 = _ }
                , _2 =
                    _
                }
            }
      , rightIdentity :
            object
          → { from :
                cat.arrow
                { _1 =
                    _
                , _2 =
                    cat.multiplicative.op
                    { _1 = _, _2 = cat.multiplicative.identity }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.multiplicative.op
                    { _1 = _, _2 = cat.multiplicative.identity }
                , _2 =
                    _
                }
            }
      }
  , split :
      cat.arrow
      { _1 =
          cat.additive.identity
      , _2 =
          cat.multiplicative.op
          { _1 = cat.additive.identity, _2 = cat.additive.identity }
      }
  , swap :
        ∀(a : object)
      → ∀(b : object)
      → ∀(c : object)
      → ∀(d : object)
      → cat.arrow
        { _1 =
            cat.additive.op
            { _1 =
                cat.multiplicative.op { _1 = a, _2 = b }
            , _2 =
                cat.multiplicative.op { _1 = c, _2 = d }
            }
        , _2 =
            cat.multiplicative.op
            { _1 =
                cat.additive.op { _1 = a, _2 = c }
            , _2 =
                cat.additive.op { _1 = b, _2 = d }
            }
        }
  , switch :
      cat.arrow { _1 = cat.additive.identity, _2 = cat.multiplicative.identity }
  }
</pre></dd>
</dl>
<h4>extractAdditive (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( duoidal
    : { additive :
          { identity : object, op : kArrow (kProduct object object) object }
      , arrow :
          kArrow (kProduct object object) vObject
      , constraint :
          object → Type
      , multiplicative :
          { identity : object, op : kArrow (kProduct object object) object }
      }
    )
→ { arrow :
      kArrow (kProduct object object) vObject
  , constraint :
      object → Type
  , identity :
      object
  , op :
      kArrow (kProduct object object) object
  }
</pre></dd>
</dl>
<h4>extractCategory (term)</h4>
<p>{- FIXME: Should be able to do `duoidal.{ arrow, op }`, but Dhall doesn’t like
          that for some reason.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( duoidal
    : { additive :
          { identity : object, op : kArrow (kProduct object object) object }
      , arrow :
          kArrow (kProduct object object) vObject
      , constraint :
          object → Type
      , multiplicative :
          { identity : object, op : kArrow (kProduct object object) object }
      }
    )
→ { arrow :
      kArrow (kProduct object object) vObject
  , constraint :
      object → Type
  }
</pre></dd>
</dl>
<h4>extractMultiplicative (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( duoidal
    : { additive :
          { identity : object, op : kArrow (kProduct object object) object }
      , arrow :
          kArrow (kProduct object object) vObject
      , constraint :
          object → Type
      , multiplicative :
          { identity : object, op : kArrow (kProduct object object) object }
      }
    )
→ { arrow :
      kArrow (kProduct object object) vObject
  , constraint :
      object → Type
  , identity :
      object
  , op :
      kArrow (kProduct object object) object
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Endofunctor</h3>
<h4>duoidal (term)</h4>
<p>{- NB: This is defined in terms of the monoidal categories instead of the other
       way around because this is more restrictive than either monoidal
       category.
     • Applicative requires that the target category is **Set** and
     • monadic requires an endofunctor`object`.
       When you combine these two restrictions, you end up only being able to
       support endofunctors in **Set**.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  ∀(v : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ ∀ ( cat
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ { additive :
      { identity :
          Type → Type
      , op :
          { _1 : Type → Type, _2 : Type → Type } → Type → Type
      }
  , arrow :
      { _1 : Type → Type, _2 : Type → Type } → Type
  , constraint :
      (Type → Type) → Type
  , multiplicative :
      { identity :
          Type → Type
      , op :
          { _1 : Type → Type, _2 : Type → Type } → Type → Type
      }
  }
</pre></dd>
</dl>
<h4 style="background-color: #bbb; width: 100%">./Category/Endofunctor/monoidal</h4>
<h4>functor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(v : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ ∀ ( cat
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ { arrow :
      { _1 : Type → Type, _2 : Type → Type } → Type
  , constraint :
      (Type → Type) → Type
  , identity :
      Type → Type
  , op :
      { _1 : Type → Type, _2 : Type → Type } → Type → Type
  }
</pre></dd>
</dl>
<h4>monadic (term)</h4>
<p>{- NB: This doesn’t use `Duoidal/extractMultiplicative` because that has a fixed
      `object`.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀(v : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ { arrow :
      { _1 : object → object, _2 : object → object } → Type
  , constraint :
      (object → object) → Type
  , identity :
      object → object
  , op :
      { _1 : object → object, _2 : object → object } → object → object
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Functor</h3>
<h4>category (term)</h4>
<p>{- This cheats a bit on the identity, since `dObject` is Type, we don’t need a
   functor **Set** → 𝒟.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀(v : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ { arrow :
      { _1 : cObject → dObject, _2 : cObject → dObject } → Type
  , constraint :
      (cObject → dObject) → Type
  }
</pre></dd>
</dl>
<h4>monoidal (term)</h4>
<p>{- This cheats a bit on the identity, since `dObject` is Type, we don’t need a
   functor **Set** → 𝒟.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(v : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      , identity :
          cObject
      , op :
          { _1 : cObject, _2 : cObject } → cObject
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ { arrow :
      { _1 : cObject → Type, _2 : cObject → Type } → Type
  , constraint :
      (cObject → Type) → Type
  , identity :
      ∀(x : cObject) → Type
  , op :
      { _1 : cObject → Type, _2 : cObject → Type } → cObject → Type
  }
</pre></dd>
</dl>
<h4>types.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ { Adjunction :
        ((cObject → dObject) → cObject → dObject)
      → ((cObject → dObject) → cObject → dObject)
      → Type
  , Bifunctor :
        ({ _1 : cObject → dObject, _2 : cObject → dObject } → cObject → dObject)
      → Type
  , Category :
        { arrow :
            { _1 : Type, _2 : Type } → Type
        , constraint :
            Type → Type
        , identity :
            Type
        , op :
            { _1 : Type, _2 : Type } → Type
        }
      → { arrow :
            { _1 : cObject → dObject, _2 : cObject → dObject } → Type
        , constraint :
            (cObject → dObject) → Type
        }
      → Type
  , Codensity :
        { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
      → ((cObject → dObject) → Type)
      → Type
      → Type
  , Comonad :
      ((cObject → dObject) → cObject → dObject) → Type
  , Compose :
        { _1 :
            (cObject → dObject) → cObject → dObject
        , _2 :
            (cObject → dObject) → cObject → dObject
        }
      → (cObject → dObject)
      → cObject
      → dObject
  , Const :
      { _1 : cObject → dObject, _2 : cObject → dObject } → cObject → dObject
  , Costar :
        ((cObject → dObject) → cObject → dObject)
      → { _1 : cObject → dObject, _2 : cObject → dObject }
      → Type
  , Coyoneda :
      ((cObject → dObject) → Type) → (cObject → dObject) → Type
  , Density :
        { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
      → ((cObject → dObject) → Type)
      → Type
      → Type
  , Endofunctor :
      ((cObject → dObject) → cObject → dObject) → Type
  , HomFunctor :
      ({ _1 : cObject → dObject, _2 : cObject → dObject } → Type) → Type
  , Identity :
      (cObject → dObject) → cObject → dObject
  , Lan :
        ((cObject → dObject) → cObject → dObject)
      → ((cObject → dObject) → Type)
      → (cObject → dObject)
      → Type
  , Leibniz :
      { arrow :
          { _1 : cObject → dObject, _2 : cObject → dObject } → Type
      , constraint :
          (cObject → dObject) → Type
      }
  , Monad :
      ((cObject → dObject) → cObject → dObject) → Type
  , NaturalTransformation :
        { _1 :
            (cObject → dObject) → cObject → dObject
        , _2 :
            (cObject → dObject) → cObject → dObject
        }
      → Type
  , Profunctor :
      ({ _1 : cObject → dObject, _2 : cObject → dObject } → Type) → Type
  , Ran :
        ((cObject → dObject) → cObject → dObject)
      → ((cObject → dObject) → Type)
      → (cObject → dObject)
      → Type
  , Semigroupoid :
        { arrow :
            { _1 : Type, _2 : Type } → Type
        , constraint :
            Type → Type
        , identity :
            Type
        , op :
            { _1 : Type, _2 : Type } → Type
        }
      → { arrow :
            { _1 : cObject → dObject, _2 : cObject → dObject } → Type
        , constraint :
            (cObject → dObject) → Type
        }
      → ({ _1 : cObject → dObject, _2 : cObject → dObject } → Type)
      → Type
  , Star :
        ((cObject → dObject) → cObject → dObject)
      → { _1 : cObject → dObject, _2 : cObject → dObject }
      → Type
  , Strong :
      ({ _1 : cObject → dObject, _2 : cObject → dObject } → Type) → Type
  , Traversable :
        ((cObject → dObject) → cObject → dObject)
      → ((cObject → dObject) → cObject → dObject)
      → Type
  , Yoneda :
      ((cObject → dObject) → Type) → (cObject → dObject) → Type
  }
</pre></dd>
</dl>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(vObject : Kind)
→ ∀(object : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(vObject : Kind)
→ λ(object : Kind)
→ { arrow :
      kArrow (kProduct object object) vObject
  , constraint :
      object → Type
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Kleisli</h3>
<h4>category (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → vObject
      , constraint :
          object → Type
      }
    )
→ ∀(m : object → object)
→ { arrow : { _1 : object, _2 : object } → vObject, constraint : object → Type }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Monoidal</h3>
<h4 style="background-color: #bbb; width: 100%">./Category/Monoidal/Braided</h4>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ { braid :
        ∀(x : object)
      → ∀(y : object)
      → cat.arrow
        { _1 = cat.op { _1 = x, _2 = y }, _2 = cat.op { _1 = y, _2 = x } }
  , category :
      { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
  , monoid :
        object
      → { identity :
            cat.arrow { _1 = cat.identity, _2 = _ }
        , op :
            cat.arrow { _1 = cat.op { _1 = _, _2 = _ }, _2 = _ }
        }
  }
</pre></dd>
</dl>
<h4 style="background-color: #bbb; width: 100%">./Category/Monoidal/Cartesian</h4>
<h4>Kind (kind)</h4>
<p>{- Can’t define `augmentation` at this level, because we have no unit `Kind`.
-}</p>
<dl>
<dt>sort</dt><dd><pre>
∀(kArrow : Kind → Kind → Kind) → ∀(vObject : Kind) → ∀(object : Kind) → Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(vObject : Kind)
→ λ(object : Kind)
→ { arrow :
      kArrow { _1 : object, _2 : object } vObject
  , constraint :
      object → Type
  , diagonal :
      kArrow object { _1 : object, _2 : object }
  , identity :
      object
  , op :
      kArrow { _1 : object, _2 : object } object
  }
</pre></dd>
</dl>
<h4 style="background-color: #bbb; width: 100%">./Category/Monoidal/Closed</h4>
<h5 style="background-color: #bbb; width: 100%">./Category/Monoidal/Closed/Cartesian</h5>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
∀(kArrow : Kind → Kind → Kind) → ∀(object : Kind) → Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(object : Kind)
→ { arrow :
      kArrow { _1 : object, _2 : object } object
  , constraint :
      object → Type
  , diagonal :
      kArrow object { _1 : object, _2 : object }
  , identity :
      object
  , op :
      kArrow { _1 : object, _2 : object } object
  }
</pre></dd>
</dl>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(object : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(object : Kind)
→ { arrow :
      kArrow (kProduct object object) object
  , constraint :
      object → Type
  , identity :
      object
  , op :
      kArrow (kProduct object object) object
  }
</pre></dd>
</dl>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(vObject : Kind)
→ ∀(object : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(vObject : Kind)
→ λ(object : Kind)
→ { arrow :
      kArrow (kProduct object object) vObject
  , constraint :
      object → Type
  , identity :
      object
  , op :
      kArrow (kProduct object object) object
  }
</pre></dd>
</dl>
<h4>Laws (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ { associativity :
        object
      → object
      → object
      → { from :
            cat.arrow
            { _1 =
                cat.op { _1 = _@2, _2 = cat.op { _1 = _@1, _2 = _ } }
            , _2 =
                cat.op { _1 = cat.op { _1 = _@2, _2 = _@1 }, _2 = _ }
            }
        , to :
            cat.arrow
            { _1 =
                cat.op { _1 = cat.op { _1 = _@2, _2 = _@1 }, _2 = _ }
            , _2 =
                cat.op { _1 = _@2, _2 = cat.op { _1 = _@1, _2 = _ } }
            }
        }
  , leftIdentity :
        ∀(a : object)
      → { from :
            cat.arrow { _1 = a, _2 = cat.op { _1 = cat.identity, _2 = a } }
        , to :
            cat.arrow { _1 = cat.op { _1 = cat.identity, _2 = a }, _2 = a }
        }
  , rightIdentity :
        ∀(a : object)
      → { from :
            cat.arrow { _1 = a, _2 = cat.op { _1 = a, _2 = cat.identity } }
        , to :
            cat.arrow { _1 = cat.op { _1 = a, _2 = cat.identity }, _2 = a }
        }
  }
</pre></dd>
</dl>
<h4 style="background-color: #bbb; width: 100%">./Category/Monoidal/Symmetric</h4>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  Kind
→ { arrow :
      { _1 : Type, _2 : Type } → Type
  , constraint :
      Type → Type
  , identity :
      Type
  , op :
      { _1 : Type, _2 : Type } → Type
  }
→ { arrow :
      { _1 : _@1, _2 : _@1 } → Type
  , constraint :
      _@1 → Type
  , identity :
      _@1
  , op :
      { _1 : _@1, _2 : _@1 } → _@2
  }
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(_ : Kind)
→ λ ( _
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ λ ( _
    : { arrow :
          { _1 : _@1, _2 : _@1 } → Type
      , constraint :
          _@1 → Type
      , identity :
          _@1
      , op :
          { _1 : _@1, _2 : _@1 } → _@2
      }
    )
→ { braid :
        _@2
      → _@3
      → _@2.arrow
        { _1 = _@2.op { _1 = _@1, _2 = _ }, _2 = _@2.op { _1 = _, _2 = _@1 } }
  , category :
      { identity :
          _@2 → _@1.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : _@2, _2 : _@2 }
          → (   Type
              → (   _@4
                  → _@3.arrow { _1 = _, _2 = _@2._2 }
                  → _@4.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → _@2.arrow _@1
      }
  , monoid :
        _@2
      → { identity :
            _@1.arrow { _1 = _@1.identity, _2 = _ }
        , op :
            _@1.arrow { _1 = _@1.op { _1 = _, _2 = _ }, _2 = _ }
        }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ { category :
      { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
  , monoid :
        ∀(m : object)
      → { identity :
            cat.arrow { _1 = cat.identity, _2 = m }
        , op :
            cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
        }
  }
</pre></dd>
</dl>
<h4>extractCategory (term)</h4>
<p>{- FIXME: Should be able to do `monoidal.{ arrow, op }`, but Dhall doesn’t like
          that for some reason.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( monoidal
    : { arrow :
          kArrow (kProduct object object) vObject
      , constraint :
          object → Type
      , identity :
          object
      , op :
          kArrow (kProduct object object) object
      }
    )
→ { arrow :
      kArrow (kProduct object object) vObject
  , constraint :
      object → Type
  }
</pre></dd>
</dl>
<h4>extractSemigroupal (term)</h4>
<p>{- FIXME: Should be able to do `monoidal.{ arrow, op }`, but Dhall doesn’t like
          that for some reason.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( monoidal
    : { arrow :
          kArrow (kProduct object object) vObject
      , constraint :
          object → Type
      , identity :
          object
      , op :
          kArrow (kProduct object object) object
      }
    )
→ { arrow :
      kArrow (kProduct object object) vObject
  , constraint :
      object → Type
  , op :
      kArrow (kProduct object object) object
  }
</pre></dd>
</dl>
<h4>types.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ { Adjunction :
      (object → object) → (object → object) → Type
  , Arrow :
      Type
  , Bifunctor :
      ({ _1 : object, _2 : object } → object) → Type
  , Category :
        { arrow :
            { _1 : Type, _2 : Type } → Type
        , constraint :
            Type → Type
        , identity :
            Type
        , op :
            { _1 : Type, _2 : Type } → Type
        }
      → { arrow :
            { _1 : object, _2 : object } → Type
        , constraint :
            object → Type
        }
      → Type
  , Codensity :
        { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
      → (object → Type)
      → Type
      → Type
  , CommutativeGroup :
      object → Type
  , CommutativeMonoid :
      object → Type
  , Comonad :
      (object → object) → Type
  , Compose :
      { _1 : object → object, _2 : object → object } → object → object
  , Const :
      { _1 : object, _2 : object } → object
  , Costar :
      (object → object) → { _1 : object, _2 : object } → Type
  , Coyoneda :
      (object → Type) → object → Type
  , Day :
      { _1 : object → Type, _2 : object → Type } → object → Type
  , Density :
        { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
      → (object → Type)
      → Type
      → Type
  , Endofunctor :
      (object → object) → Type
  , Field :
      object → Type
  , Group :
      object → Type
  , HomFunctor :
      ({ _1 : object, _2 : object } → Type) → Type
  , Identity :
      object → object
  , Lan :
      (object → object) → (object → Type) → object → Type
  , Leibniz :
      { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
  , Monad :
      (object → object) → Type
  , Monoid :
      object → Type
  , MonoidalFunctor :
      (object → Type) → Type
  , NaturalTransformation :
      { _1 : object → object, _2 : object → object } → Type
  , Profunctor :
      ({ _1 : object, _2 : object } → Type) → Type
  , Ran :
      (object → object) → (object → Type) → object → Type
  , Rig :
      object → Type
  , Ring :
      object → Type
  , Semigroup :
      object → Type
  , Semigroupoid :
        { arrow :
            { _1 : Type, _2 : Type } → Type
        , constraint :
            Type → Type
        , identity :
            Type
        , op :
            { _1 : Type, _2 : Type } → Type
        }
      → { arrow :
            { _1 : object, _2 : object } → Type
        , constraint :
            object → Type
        }
      → ({ _1 : object, _2 : object } → Type)
      → Type
  , Semiring :
      object → Type
  , Star :
      (object → object) → { _1 : object, _2 : object } → Type
  , Strong :
      ({ _1 : object, _2 : object } → Type) → Type
  , Traversable :
      (object → object) → (object → object) → Type
  , Yoneda :
      (object → Type) → object → Type
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Op</h3>
<h4>Kind (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → vObject
      , constraint :
          object → Type
      }
    )
→ { arrow :
      ∀(a : { _1 : object, _2 : object }) → vObject
  , constraint :
      object → Type
  }
</pre></dd>
</dl>
<h4>Sort (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
∀(kArrow : Kind → Kind → Kind) → ∀(a : Kind) → ∀(b : Kind) → Kind
</pre></dd>
<dt>kind</dt><dd><pre>
λ(kArrow : Kind → Kind → Kind) → λ(a : Kind) → λ(b : Kind) → kArrow b a
</pre></dd>
</dl>
<h4>category (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ∀ ( category
    : { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ { identity :
      object → cat.arrow { _1 = _, _2 = _ }
  , op :
        ∀(a : { _1 : object, _2 : object })
      → ∀ ( p
          :   ∀(r : Type)
            → (   ∀(z : object)
                → cat.arrow { _1 = a._2, _2 = z }
                → cat.arrow { _1 = z, _2 = a._1 }
                → r
              )
            → r
          )
      → cat.arrow { _1 = a._2, _2 = a._1 }
  }
</pre></dd>
</dl>
<h4>duoidal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( cat
    : { additive :
          { identity : object, op : { _1 : object, _2 : object } → object }
      , arrow :
          { _1 : object, _2 : object } → vObject
      , constraint :
          object → Type
      , multiplicative :
          { identity : object, op : { _1 : object, _2 : object } → object }
      }
    )
→ { additive :
      { identity : object, op : { _1 : object, _2 : object } → object }
  , arrow :
      { _1 : object, _2 : object } → vObject
  , constraint :
      object → Type
  , multiplicative :
      { identity : object, op : { _1 : object, _2 : object } → object }
  }
</pre></dd>
</dl>
<h4>monoidal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → vObject
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ { arrow :
      { _1 : object, _2 : object } → vObject
  , constraint :
      object → Type
  , identity :
      object
  , op :
      { _1 : object, _2 : object } → object
  }
</pre></dd>
</dl>
<h4>semigroupal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → vObject
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ { arrow :
      { _1 : object, _2 : object } → vObject
  , constraint :
      object → Type
  , op :
      { _1 : object, _2 : object } → object
  }
</pre></dd>
</dl>
<h4>types.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ { Adjunction :
      (object → object) → (object → object) → Type
  , Arrow :
      Type
  , Bifunctor :
      ({ _1 : object, _2 : object } → object) → Type
  , Category :
        { arrow :
            { _1 : Type, _2 : Type } → Type
        , constraint :
            Type → Type
        , identity :
            Type
        , op :
            { _1 : Type, _2 : Type } → Type
        }
      → { arrow :
            { _1 : object, _2 : object } → Type
        , constraint :
            object → Type
        }
      → Type
  , Codensity :
        { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
      → (object → Type)
      → Type
      → Type
  , CommutativeGroup :
      object → Type
  , CommutativeMonoid :
      object → Type
  , Comonad :
      (object → object) → Type
  , Compose :
      { _1 : object → object, _2 : object → object } → object → object
  , Const :
      { _1 : object, _2 : object } → object
  , Costar :
      (object → object) → { _1 : object, _2 : object } → Type
  , Coyoneda :
      (object → Type) → object → Type
  , Day :
      { _1 : object → Type, _2 : object → Type } → object → Type
  , Density :
        { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
      → (object → Type)
      → Type
      → Type
  , Endofunctor :
      (object → object) → Type
  , Field :
      object → Type
  , Group :
      object → Type
  , HomFunctor :
      ({ _1 : object, _2 : object } → Type) → Type
  , Identity :
      object → object
  , Lan :
      (object → object) → (object → Type) → object → Type
  , Leibniz :
      { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
  , Monad :
      (object → object) → Type
  , Monoid :
      object → Type
  , MonoidalFunctor :
      (object → Type) → Type
  , NaturalTransformation :
      { _1 : object → object, _2 : object → object } → Type
  , Profunctor :
      ({ _1 : object, _2 : object } → Type) → Type
  , Ran :
      (object → object) → (object → Type) → object → Type
  , Rig :
      object → Type
  , Ring :
      object → Type
  , Semigroup :
      object → Type
  , Semigroupoid :
        { arrow :
            { _1 : Type, _2 : Type } → Type
        , constraint :
            Type → Type
        , identity :
            Type
        , op :
            { _1 : Type, _2 : Type } → Type
        }
      → { arrow :
            { _1 : object, _2 : object } → Type
        , constraint :
            object → Type
        }
      → ({ _1 : object, _2 : object } → Type)
      → Type
  , Semiring :
      object → Type
  , Star :
      (object → object) → { _1 : object, _2 : object } → Type
  , Strong :
      ({ _1 : object, _2 : object } → Type) → Type
  , Traversable :
      (object → object) → (object → object) → Type
  , Yoneda :
      (object → Type) → object → Type
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Product</h3>
<h4>Kind (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ { arrow :
        ∀ ( a
          : { _1 :
                { _1 : cObject, _2 : dObject }
            , _2 :
                { _1 : cObject, _2 : dObject }
            }
          )
      → Type
  , constraint :
      ∀(x : { _1 : cObject, _2 : dObject }) → Type
  }
</pre></dd>
</dl>
<h4>Type (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      , identity :
          vObject
      , op :
          { _1 : vObject, _2 : vObject } → vObject
      }
    )
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → vObject
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → vObject
      , constraint :
          dObject → Type
      }
    )
→ { arrow :
        ∀ ( a
          : { _1 :
                { _1 : cObject, _2 : dObject }
            , _2 :
                { _1 : cObject, _2 : dObject }
            }
          )
      → vObject
  , constraint :
      ∀(obj : { _1 : cObject, _2 : dObject }) → Type
  }
</pre></dd>
</dl>
<h4>category (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( cCategory
    : { identity :
          cObject → c.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : cObject, _2 : cObject }
          → (   Type
              → (   cObject
                  → c.arrow { _1 = _, _2 = _@2._2 }
                  → c.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → c.arrow _@1
      }
    )
→ ∀(dObject : Kind)
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ ∀ ( dCategory
    : { identity :
          dObject → d.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : dObject, _2 : dObject }
          → (   Type
              → (   dObject
                  → d.arrow { _1 = _, _2 = _@2._2 }
                  → d.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → d.arrow _@1
      }
    )
→ { identity :
        ∀(a : { _1 : cObject, _2 : dObject })
      → { _1 :
            c.arrow { _1 = a._1, _2 = a._1 }
        , _2 :
            d.arrow { _1 = a._2, _2 = a._2 }
        }
  , op :
        ∀ ( a
          : { _1 :
                { _1 : cObject, _2 : dObject }
            , _2 :
                { _1 : cObject, _2 : dObject }
            }
          )
      → ∀ ( p
          :   ∀(r : Type)
            → (   ∀(z : { _1 : cObject, _2 : dObject })
                → { _1 :
                      c.arrow { _1 = z._1, _2 = a._2._1 }
                  , _2 :
                      d.arrow { _1 = z._2, _2 = a._2._2 }
                  }
                → { _1 :
                      c.arrow { _1 = a._1._1, _2 = z._1 }
                  , _2 :
                      d.arrow { _1 = a._1._2, _2 = z._2 }
                  }
                → r
              )
            → r
          )
      → { _1 :
            c.arrow { _1 = a._1._1, _2 = a._2._1 }
        , _2 :
            d.arrow { _1 = a._1._2, _2 = a._2._2 }
        }
  }
</pre></dd>
</dl>
<h4>types.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ { Adjunction :
        ({ _1 : cObject, _2 : dObject } → { _1 : cObject, _2 : dObject })
      → ({ _1 : cObject, _2 : dObject } → { _1 : cObject, _2 : dObject })
      → Type
  , Bifunctor :
        (   { _1 :
                { _1 : cObject, _2 : dObject }
            , _2 :
                { _1 : cObject, _2 : dObject }
            }
          → { _1 : cObject, _2 : dObject }
        )
      → Type
  , Category :
        { arrow :
            { _1 : Type, _2 : Type } → Type
        , constraint :
            Type → Type
        , identity :
            Type
        , op :
            { _1 : Type, _2 : Type } → Type
        }
      → { arrow :
              { _1 :
                  { _1 : cObject, _2 : dObject }
              , _2 :
                  { _1 : cObject, _2 : dObject }
              }
            → Type
        , constraint :
            { _1 : cObject, _2 : dObject } → Type
        }
      → Type
  , Codensity :
        { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
      → ({ _1 : cObject, _2 : dObject } → Type)
      → Type
      → Type
  , Comonad :
      ({ _1 : cObject, _2 : dObject } → { _1 : cObject, _2 : dObject }) → Type
  , Compose :
        { _1 :
            { _1 : cObject, _2 : dObject } → { _1 : cObject, _2 : dObject }
        , _2 :
            { _1 : cObject, _2 : dObject } → { _1 : cObject, _2 : dObject }
        }
      → { _1 : cObject, _2 : dObject }
      → { _1 : cObject, _2 : dObject }
  , Const :
        { _1 :
            { _1 : cObject, _2 : dObject }
        , _2 :
            { _1 : cObject, _2 : dObject }
        }
      → { _1 : cObject, _2 : dObject }
  , Costar :
        ({ _1 : cObject, _2 : dObject } → { _1 : cObject, _2 : dObject })
      → { _1 :
            { _1 : cObject, _2 : dObject }
        , _2 :
            { _1 : cObject, _2 : dObject }
        }
      → Type
  , Coyoneda :
        ({ _1 : cObject, _2 : dObject } → Type)
      → { _1 : cObject, _2 : dObject }
      → Type
  , Density :
        { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
      → ({ _1 : cObject, _2 : dObject } → Type)
      → Type
      → Type
  , Endofunctor :
      ({ _1 : cObject, _2 : dObject } → { _1 : cObject, _2 : dObject }) → Type
  , HomFunctor :
        (   { _1 :
                { _1 : cObject, _2 : dObject }
            , _2 :
                { _1 : cObject, _2 : dObject }
            }
          → Type
        )
      → Type
  , Identity :
      { _1 : cObject, _2 : dObject } → { _1 : cObject, _2 : dObject }
  , Lan :
        ({ _1 : cObject, _2 : dObject } → { _1 : cObject, _2 : dObject })
      → ({ _1 : cObject, _2 : dObject } → Type)
      → { _1 : cObject, _2 : dObject }
      → Type
  , Leibniz :
      { arrow :
            { _1 :
                { _1 : cObject, _2 : dObject }
            , _2 :
                { _1 : cObject, _2 : dObject }
            }
          → Type
      , constraint :
          { _1 : cObject, _2 : dObject } → Type
      }
  , Monad :
      ({ _1 : cObject, _2 : dObject } → { _1 : cObject, _2 : dObject }) → Type
  , NaturalTransformation :
        { _1 :
            { _1 : cObject, _2 : dObject } → { _1 : cObject, _2 : dObject }
        , _2 :
            { _1 : cObject, _2 : dObject } → { _1 : cObject, _2 : dObject }
        }
      → Type
  , Profunctor :
        (   { _1 :
                { _1 : cObject, _2 : dObject }
            , _2 :
                { _1 : cObject, _2 : dObject }
            }
          → Type
        )
      → Type
  , Ran :
        ({ _1 : cObject, _2 : dObject } → { _1 : cObject, _2 : dObject })
      → ({ _1 : cObject, _2 : dObject } → Type)
      → { _1 : cObject, _2 : dObject }
      → Type
  , Semigroupoid :
        { arrow :
            { _1 : Type, _2 : Type } → Type
        , constraint :
            Type → Type
        , identity :
            Type
        , op :
            { _1 : Type, _2 : Type } → Type
        }
      → { arrow :
              { _1 :
                  { _1 : cObject, _2 : dObject }
              , _2 :
                  { _1 : cObject, _2 : dObject }
              }
            → Type
        , constraint :
            { _1 : cObject, _2 : dObject } → Type
        }
      → (   { _1 :
                { _1 : cObject, _2 : dObject }
            , _2 :
                { _1 : cObject, _2 : dObject }
            }
          → Type
        )
      → Type
  , Star :
        ({ _1 : cObject, _2 : dObject } → { _1 : cObject, _2 : dObject })
      → { _1 :
            { _1 : cObject, _2 : dObject }
        , _2 :
            { _1 : cObject, _2 : dObject }
        }
      → Type
  , Strong :
        (   { _1 :
                { _1 : cObject, _2 : dObject }
            , _2 :
                { _1 : cObject, _2 : dObject }
            }
          → Type
        )
      → Type
  , Traversable :
        ({ _1 : cObject, _2 : dObject } → { _1 : cObject, _2 : dObject })
      → ({ _1 : cObject, _2 : dObject } → { _1 : cObject, _2 : dObject })
      → Type
  , Yoneda :
        ({ _1 : cObject, _2 : dObject } → Type)
      → { _1 : cObject, _2 : dObject }
      → Type
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Profunctor</h3>
<h4>monoidal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ∀(morphism : { _1 : object, _2 : object } → Type)
→ { arrow :
        { _1 :
            { _1 : object, _2 : object } → Type
        , _2 :
            { _1 : object, _2 : object } → Type
        }
      → Type
  , constraint :
      ({ _1 : object, _2 : object } → Type) → Type
  , identity :
      { _1 : object, _2 : object } → Type
  , op :
        { _1 :
            { _1 : object, _2 : object } → Type
        , _2 :
            { _1 : object, _2 : object } → Type
        }
      → { _1 : object, _2 : object }
      → Type
  }
</pre></dd>
</dl>
<h4>semigroupal (term)</h4>
<p>{- This doesn’t use `extractSemigroupal` because I don’t know how to apply the
  `morphism` in the monoidal category instance.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ { arrow :
        ∀ ( p
          : { _1 :
                { _1 : object, _2 : object } → Type
            , _2 :
                { _1 : object, _2 : object } → Type
            }
          )
      → Type
  , constraint :
      ({ _1 : object, _2 : object } → Type) → Type
  , op :
        ∀ ( p
          : { _1 :
                { _1 : object, _2 : object } → Type
            , _2 :
                { _1 : object, _2 : object } → Type
            }
          )
      → ∀(a : { _1 : object, _2 : object })
      → Type
  }
</pre></dd>
</dl>
<h4>types.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ { Adjunction :
        (   ({ _1 : object, _2 : object } → Type)
          → { _1 : object, _2 : object }
          → Type
        )
      → (   ({ _1 : object, _2 : object } → Type)
          → { _1 : object, _2 : object }
          → Type
        )
      → Type
  , Arrow :
      Type
  , Bifunctor :
        (   { _1 :
                { _1 : object, _2 : object } → Type
            , _2 :
                { _1 : object, _2 : object } → Type
            }
          → { _1 : object, _2 : object }
          → Type
        )
      → Type
  , Category :
        { arrow :
            { _1 : Type, _2 : Type } → Type
        , constraint :
            Type → Type
        , identity :
            Type
        , op :
            { _1 : Type, _2 : Type } → Type
        }
      → { arrow :
              { _1 :
                  { _1 : object, _2 : object } → Type
              , _2 :
                  { _1 : object, _2 : object } → Type
              }
            → Type
        , constraint :
            ({ _1 : object, _2 : object } → Type) → Type
        }
      → Type
  , Codensity :
        { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
      → (({ _1 : object, _2 : object } → Type) → Type)
      → Type
      → Type
  , Comonad :
        (   ({ _1 : object, _2 : object } → Type)
          → { _1 : object, _2 : object }
          → Type
        )
      → Type
  , Compose :
        { _1 :
              ({ _1 : object, _2 : object } → Type)
            → { _1 : object, _2 : object }
            → Type
        , _2 :
              ({ _1 : object, _2 : object } → Type)
            → { _1 : object, _2 : object }
            → Type
        }
      → ({ _1 : object, _2 : object } → Type)
      → { _1 : object, _2 : object }
      → Type
  , Const :
        { _1 :
            { _1 : object, _2 : object } → Type
        , _2 :
            { _1 : object, _2 : object } → Type
        }
      → { _1 : object, _2 : object }
      → Type
  , Costar :
        (   ({ _1 : object, _2 : object } → Type)
          → { _1 : object, _2 : object }
          → Type
        )
      → { _1 :
            { _1 : object, _2 : object } → Type
        , _2 :
            { _1 : object, _2 : object } → Type
        }
      → Type
  , Coyoneda :
        (({ _1 : object, _2 : object } → Type) → Type)
      → ({ _1 : object, _2 : object } → Type)
      → Type
  , Density :
        { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
      → (({ _1 : object, _2 : object } → Type) → Type)
      → Type
      → Type
  , Endofunctor :
        (   ({ _1 : object, _2 : object } → Type)
          → { _1 : object, _2 : object }
          → Type
        )
      → Type
  , HomFunctor :
        (   { _1 :
                { _1 : object, _2 : object } → Type
            , _2 :
                { _1 : object, _2 : object } → Type
            }
          → Type
        )
      → Type
  , Identity :
        ({ _1 : object, _2 : object } → Type)
      → { _1 : object, _2 : object }
      → Type
  , Lan :
        (   ({ _1 : object, _2 : object } → Type)
          → { _1 : object, _2 : object }
          → Type
        )
      → (({ _1 : object, _2 : object } → Type) → Type)
      → ({ _1 : object, _2 : object } → Type)
      → Type
  , Leibniz :
      { arrow :
            { _1 :
                { _1 : object, _2 : object } → Type
            , _2 :
                { _1 : object, _2 : object } → Type
            }
          → Type
      , constraint :
          ({ _1 : object, _2 : object } → Type) → Type
      }
  , Monad :
        (   ({ _1 : object, _2 : object } → Type)
          → { _1 : object, _2 : object }
          → Type
        )
      → Type
  , NaturalTransformation :
        { _1 :
              ({ _1 : object, _2 : object } → Type)
            → { _1 : object, _2 : object }
            → Type
        , _2 :
              ({ _1 : object, _2 : object } → Type)
            → { _1 : object, _2 : object }
            → Type
        }
      → Type
  , Profunctor :
        (   { _1 :
                { _1 : object, _2 : object } → Type
            , _2 :
                { _1 : object, _2 : object } → Type
            }
          → Type
        )
      → Type
  , Ran :
        (   ({ _1 : object, _2 : object } → Type)
          → { _1 : object, _2 : object }
          → Type
        )
      → (({ _1 : object, _2 : object } → Type) → Type)
      → ({ _1 : object, _2 : object } → Type)
      → Type
  , Semigroup :
      ({ _1 : object, _2 : object } → Type) → Type
  , Semigroupoid :
        { arrow :
            { _1 : Type, _2 : Type } → Type
        , constraint :
            Type → Type
        , identity :
            Type
        , op :
            { _1 : Type, _2 : Type } → Type
        }
      → { arrow :
              { _1 :
                  { _1 : object, _2 : object } → Type
              , _2 :
                  { _1 : object, _2 : object } → Type
              }
            → Type
        , constraint :
            ({ _1 : object, _2 : object } → Type) → Type
        }
      → (   { _1 :
                { _1 : object, _2 : object } → Type
            , _2 :
                { _1 : object, _2 : object } → Type
            }
          → Type
        )
      → Type
  , Star :
        (   ({ _1 : object, _2 : object } → Type)
          → { _1 : object, _2 : object }
          → Type
        )
      → { _1 :
            { _1 : object, _2 : object } → Type
        , _2 :
            { _1 : object, _2 : object } → Type
        }
      → Type
  , Strong :
        (   { _1 :
                { _1 : object, _2 : object } → Type
            , _2 :
                { _1 : object, _2 : object } → Type
            }
          → Type
        )
      → Type
  , Traversable :
        (   ({ _1 : object, _2 : object } → Type)
          → { _1 : object, _2 : object }
          → Type
        )
      → (   ({ _1 : object, _2 : object } → Type)
          → { _1 : object, _2 : object }
          → Type
        )
      → Type
  , Yoneda :
        (({ _1 : object, _2 : object } → Type) → Type)
      → ({ _1 : object, _2 : object } → Type)
      → Type
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Rig</h3>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(vObject : Kind)
→ ∀(object : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(vObject : Kind)
→ λ(object : Kind)
→ { additive :
      { identity : object, op : kArrow (kProduct object object) object }
  , arrow :
      kArrow (kProduct object object) vObject
  , constraint :
      object → Type
  , multiplicative :
      { identity : object, op : kArrow (kProduct object object) object }
  }
</pre></dd>
</dl>
<h4>Laws (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { additive :
          { identity : object, op : { _1 : object, _2 : object } → object }
      , arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , multiplicative :
          { identity : object, op : { _1 : object, _2 : object } → object }
      }
    )
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { additive :
          { identity : object, op : { _1 : object, _2 : object } → object }
      , arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , multiplicative :
          { identity : object, op : { _1 : object, _2 : object } → object }
      }
    )
→ { additive :
      { associativity :
            object
          → object
          → object
          → { from :
                cat.arrow
                { _1 =
                    cat.additive.op
                    { _1 = _@2, _2 = cat.additive.op { _1 = _@1, _2 = _ } }
                , _2 =
                    cat.additive.op
                    { _1 = cat.additive.op { _1 = _@2, _2 = _@1 }, _2 = _ }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.additive.op
                    { _1 = cat.additive.op { _1 = _@2, _2 = _@1 }, _2 = _ }
                , _2 =
                    cat.additive.op
                    { _1 = _@2, _2 = cat.additive.op { _1 = _@1, _2 = _ } }
                }
            }
      , leftIdentity :
            object
          → { from :
                cat.arrow
                { _1 =
                    _
                , _2 =
                    cat.additive.op { _1 = cat.additive.identity, _2 = _ }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.additive.op { _1 = cat.additive.identity, _2 = _ }
                , _2 =
                    _
                }
            }
      , rightIdentity :
            object
          → { from :
                cat.arrow
                { _1 =
                    _
                , _2 =
                    cat.additive.op { _1 = _, _2 = cat.additive.identity }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.additive.op { _1 = _, _2 = cat.additive.identity }
                , _2 =
                    _
                }
            }
      }
  , distributivity :
        ∀(a : object)
      → ∀(b : object)
      → ∀(c : object)
      → { from :
            cat.arrow
            { _1 =
                cat.additive.op
                { _1 =
                    cat.multiplicative.op { _1 = a, _2 = b }
                , _2 =
                    cat.multiplicative.op { _1 = a, _2 = c }
                }
            , _2 =
                cat.multiplicative.op
                { _1 = a, _2 = cat.additive.op { _1 = b, _2 = c } }
            }
        , to :
            cat.arrow
            { _1 =
                cat.multiplicative.op
                { _1 = a, _2 = cat.additive.op { _1 = b, _2 = c } }
            , _2 =
                cat.additive.op
                { _1 =
                    cat.multiplicative.op { _1 = a, _2 = b }
                , _2 =
                    cat.multiplicative.op { _1 = a, _2 = c }
                }
            }
        }
  , leftAnnihilation :
        ∀(a : object)
      → { from :
            cat.arrow
            { _1 =
                cat.additive.identity
            , _2 =
                cat.multiplicative.op { _1 = cat.additive.identity, _2 = a }
            }
        , to :
            cat.arrow
            { _1 =
                cat.multiplicative.op { _1 = cat.additive.identity, _2 = a }
            , _2 =
                cat.additive.identity
            }
        }
  , multiplicative :
      { associativity :
            object
          → object
          → object
          → { from :
                cat.arrow
                { _1 =
                    cat.multiplicative.op
                    { _1 =
                        _@2
                    , _2 =
                        cat.multiplicative.op { _1 = _@1, _2 = _ }
                    }
                , _2 =
                    cat.multiplicative.op
                    { _1 =
                        cat.multiplicative.op { _1 = _@2, _2 = _@1 }
                    , _2 =
                        _
                    }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.multiplicative.op
                    { _1 =
                        cat.multiplicative.op { _1 = _@2, _2 = _@1 }
                    , _2 =
                        _
                    }
                , _2 =
                    cat.multiplicative.op
                    { _1 =
                        _@2
                    , _2 =
                        cat.multiplicative.op { _1 = _@1, _2 = _ }
                    }
                }
            }
      , leftIdentity :
            object
          → { from :
                cat.arrow
                { _1 =
                    _
                , _2 =
                    cat.multiplicative.op
                    { _1 = cat.multiplicative.identity, _2 = _ }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.multiplicative.op
                    { _1 = cat.multiplicative.identity, _2 = _ }
                , _2 =
                    _
                }
            }
      , rightIdentity :
            object
          → { from :
                cat.arrow
                { _1 =
                    _
                , _2 =
                    cat.multiplicative.op
                    { _1 = _, _2 = cat.multiplicative.identity }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.multiplicative.op
                    { _1 = _, _2 = cat.multiplicative.identity }
                , _2 =
                    _
                }
            }
      }
  , rightAnnihilation :
        ∀(a : object)
      → { from :
            cat.arrow
            { _1 =
                cat.additive.identity
            , _2 =
                cat.multiplicative.op { _1 = a, _2 = cat.additive.identity }
            }
        , to :
            cat.arrow
            { _1 =
                cat.multiplicative.op { _1 = a, _2 = cat.additive.identity }
            , _2 =
                cat.additive.identity
            }
        }
  }
</pre></dd>
</dl>
<h4>extractAdditive (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( rig
    : { additive :
          { identity : object, op : kArrow (kProduct object object) object }
      , arrow :
          kArrow (kProduct object object) vObject
      , constraint :
          object → Type
      , multiplicative :
          { identity : object, op : kArrow (kProduct object object) object }
      }
    )
→ { arrow :
      kArrow (kProduct object object) vObject
  , constraint :
      object → Type
  , identity :
      object
  , op :
      kArrow (kProduct object object) object
  }
</pre></dd>
</dl>
<h4>extractMultiplicative (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( rig
    : { additive :
          { identity : object, op : kArrow (kProduct object object) object }
      , arrow :
          kArrow (kProduct object object) vObject
      , constraint :
          object → Type
      , multiplicative :
          { identity : object, op : kArrow (kProduct object object) object }
      }
    )
→ { arrow :
      kArrow (kProduct object object) vObject
  , constraint :
      object → Type
  , identity :
      object
  , op :
      kArrow (kProduct object object) object
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Semigroupal</h3>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(vObject : Kind)
→ ∀(object : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(vObject : Kind)
→ λ(object : Kind)
→ { arrow :
      kArrow (kProduct object object) vObject
  , constraint :
      object → Type
  , op :
      kArrow (kProduct object object) object
  }
</pre></dd>
</dl>
<h4>Laws (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ { associativity :
        ∀(a : object)
      → ∀(b : object)
      → ∀(c : object)
      → { from :
            cat.arrow
            { _1 =
                cat.op { _1 = a, _2 = cat.op { _1 = b, _2 = c } }
            , _2 =
                cat.op { _1 = cat.op { _1 = a, _2 = b }, _2 = c }
            }
        , to :
            cat.arrow
            { _1 =
                cat.op { _1 = cat.op { _1 = a, _2 = b }, _2 = c }
            , _2 =
                cat.op { _1 = a, _2 = cat.op { _1 = b, _2 = c } }
            }
        }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { category :
      { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
  , monoid :
      { op : cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m } }
  }
</pre></dd>
</dl>
<h4>extractCategory (term)</h4>
<p>{- FIXME: Should be able to do `semigroupal.{ arrow, op }`, but Dhall doesn’t like
          that for some reason.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( semigroupal
    : { arrow :
          kArrow (kProduct object object) vObject
      , constraint :
          object → Type
      , op :
          kArrow (kProduct object object) object
      }
    )
→ { arrow :
      kArrow (kProduct object object) vObject
  , constraint :
      object → Type
  }
</pre></dd>
</dl>
<h4>types.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ { Adjunction :
      (object → object) → (object → object) → Type
  , Arrow :
      Type
  , Bifunctor :
      ({ _1 : object, _2 : object } → object) → Type
  , Category :
        { arrow :
            { _1 : Type, _2 : Type } → Type
        , constraint :
            Type → Type
        , identity :
            Type
        , op :
            { _1 : Type, _2 : Type } → Type
        }
      → { arrow :
            { _1 : object, _2 : object } → Type
        , constraint :
            object → Type
        }
      → Type
  , Codensity :
        { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
      → (object → Type)
      → Type
      → Type
  , Comonad :
      (object → object) → Type
  , Compose :
      { _1 : object → object, _2 : object → object } → object → object
  , Const :
      { _1 : object, _2 : object } → object
  , Costar :
      (object → object) → { _1 : object, _2 : object } → Type
  , Coyoneda :
      (object → Type) → object → Type
  , Density :
        { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
      → (object → Type)
      → Type
      → Type
  , Endofunctor :
      (object → object) → Type
  , HomFunctor :
      ({ _1 : object, _2 : object } → Type) → Type
  , Identity :
      object → object
  , Lan :
      (object → object) → (object → Type) → object → Type
  , Leibniz :
      { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
  , Monad :
      (object → object) → Type
  , NaturalTransformation :
      { _1 : object → object, _2 : object → object } → Type
  , Profunctor :
      ({ _1 : object, _2 : object } → Type) → Type
  , Ran :
      (object → object) → (object → Type) → object → Type
  , Semigroup :
      object → Type
  , Semigroupoid :
        { arrow :
            { _1 : Type, _2 : Type } → Type
        , constraint :
            Type → Type
        , identity :
            Type
        , op :
            { _1 : Type, _2 : Type } → Type
        }
      → { arrow :
            { _1 : object, _2 : object } → Type
        , constraint :
            object → Type
        }
      → ({ _1 : object, _2 : object } → Type)
      → Type
  , Star :
      (object → object) → { _1 : object, _2 : object } → Type
  , Strong :
      ({ _1 : object, _2 : object } → Type) → Type
  , Traversable :
      (object → object) → (object → object) → Type
  , Yoneda :
      (object → Type) → object → Type
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Set</h3>
<h4>arrow (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ fanout :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(f : a → b)
    → ∀(g : a → c)
    → ∀(x : a)
    → { _1 : b, _2 : c }
, identity :
    ∀(a : Type) → ∀(x : a) → a
, lmap :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(f : b → a)
    → ∀(p : a → c)
    → ∀(x : b)
    → c
, map :
      ∀(a : { _1 : Type, _2 : Type })
    → ∀(b : { _1 : Type, _2 : Type })
    → ∀(f : { _1 : b._1 → a._1, _2 : a._2 → b._2 })
    → ∀(fn : a._1 → a._2)
    → ∀(x : b._1)
    → b._2
, op :
      ∀(a : { _1 : Type, _2 : Type })
    → ∀(p : ∀(r : Type) → (∀(z : Type) → (z → a._2) → (a._1 → z) → r) → r)
    → a._1
    → a._2
, rmap :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(f : b → c)
    → ∀(p : a → b)
    → ∀(x : a)
    → c
, split :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → ∀(d : Type)
    → ∀(f : a → b)
    → ∀(g : c → d)
    → ∀(p : { _1 : a, _2 : c })
    → { _1 : b, _2 : d }
}
</pre></dd>
</dl>
<h4>category (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    Type → _ → _@1
, op :
      { _1 : Type, _2 : Type }
    → (Type → (Type → (_ → _@3._2) → (_@3._1 → _@2) → _@3) → _@1)
    → _@1._1
    → _@2._2
}
</pre></dd>
</dl>
<h4>comonoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → { identity : a → {}, op : ∀(x : a) → { _1 : a, _2 : a } }
</pre></dd>
</dl>
<h4 style="background-color: #bbb; width: 100%">./Category/Set/functor</h4>
<h4>hom (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ map :
      { _1 : Type, _2 : Type }
    → { _1 : Type, _2 : Type }
    → { _1 : _._1 → _@2._1, _2 : _@1._2 → _@1._2 }
    → (_@2._1 → _@3._2)
    → _@2._1
    → _@3._2
}
</pre></dd>
</dl>
<h4>laws (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ additive :
    { associativity :
          ∀(a : Type)
        → ∀(b : Type)
        → ∀(c : Type)
        → { from :
                ∀(e : < Left : a | Right : < Left : b | Right : c > >)
              → < Left : < Left : a | Right : b > | Right : c >
          , to :
                ∀(e : < Left : < Left : a | Right : b > | Right : c >)
              → < Left : a | Right : < Left : b | Right : c > >
          }
    , leftIdentity :
          ∀(a : Type)
        → { from :
              ∀(Right : a) → < Left : <> | Right : a >
          , to :
              ∀(e : < Left : <> | Right : a >) → a
          }
    , rightIdentity :
          ∀(a : Type)
        → { from :
              ∀(Left : a) → < Left : a | Right : <> >
          , to :
              ∀(e : < Left : a | Right : <> >) → a
          }
    }
, distributivity :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(c : Type)
    → { from :
            ∀(e : < Left : { _1 : a, _2 : b } | Right : { _1 : a, _2 : c } >)
          → { _1 : a, _2 : < Left : b | Right : c > }
      , to :
            ∀(p : { _1 : a, _2 : < Left : b | Right : c > })
          → < Left : { _1 : a, _2 : b } | Right : { _1 : a, _2 : c } >
      }
, leftAnnihilation :
      ∀(a : Type)
    → { from :
          ∀(v : <>) → { _1 : <>, _2 : a }
      , to :
          ∀(p : { _1 : <>, _2 : a }) → <>
      }
, multiplicative :
    { associativity :
          ∀(a : Type)
        → ∀(b : Type)
        → ∀(c : Type)
        → { from :
                ∀(p : { _1 : a, _2 : { _1 : b, _2 : c } })
              → { _1 : { _1 : a, _2 : b }, _2 : c }
          , to :
                ∀(p : { _1 : { _1 : a, _2 : b }, _2 : c })
              → { _1 : a, _2 : { _1 : b, _2 : c } }
          }
    , leftIdentity :
          ∀(a : Type)
        → { from :
              ∀(x : a) → { _1 : {}, _2 : a }
          , to :
              ∀(p : { _1 : {}, _2 : a }) → a
          }
    , rightIdentity :
          ∀(a : Type)
        → { from :
              ∀(x : a) → { _1 : a, _2 : {} }
          , to :
              ∀(p : { _1 : a, _2 : {} }) → a
          }
    }
, rightAnnihilation :
      ∀(a : Type)
    → { from :
          ∀(v : <>) → { _1 : a, _2 : <> }
      , to :
          ∀(p : { _1 : a, _2 : <> }) → <>
      }
}
</pre></dd>
</dl>
<h4 style="background-color: #bbb; width: 100%">./Category/Set/monoidal</h4>
<h4>cartesian (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ arrow :
    { _1 : Type, _2 : Type } → Type
, constraint :
    Type → Type
, diagonal :
    ∀(a : Type) → { _1 : Type, _2 : Type }
, identity :
    Type
, op :
    { _1 : Type, _2 : Type } → Type
}
</pre></dd>
</dl>
<h4>rig (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ additive :
    { identity : Type, op : ∀(a : { _1 : Type, _2 : Type }) → Type }
, arrow :
    ∀(a : { _1 : Type, _2 : Type }) → Type
, constraint :
    ∀(t : Type) → Type
, multiplicative :
    { identity : Type, op : ∀(a : { _1 : Type, _2 : Type }) → Type }
}
</pre></dd>
</dl>
<h4>semigroupoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ op :
      { _1 : Type, _2 : Type }
    → (Type → (Type → (_ → _@3._2) → (_@3._1 → _@2) → _@3) → _@1)
    → _@1._1
    → _@2._2
}
</pre></dd>
</dl>
<h4>strong (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ lmap :
    Type → Type → Type → (_@1 → _@3) → (_@3 → _@2) → _@3 → _@3
, map :
      { _1 : Type, _2 : Type }
    → { _1 : Type, _2 : Type }
    → { _1 : _._1 → _@2._1, _2 : _@1._2 → _@1._2 }
    → (_@2._1 → _@3._2)
    → _@2._1
    → _@3._2
, rmap :
    Type → Type → Type → (_@1 → _@1) → (_@3 → _@3) → _@4 → _@3
}
</pre></dd>
</dl>
<h4>types.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ { Adjunction :
      (Type → Type) → (Type → Type) → Type
  , Arrow :
      Type
  , Bifunctor :
      ({ _1 : Type, _2 : Type } → Type) → Type
  , Category :
        { arrow :
            { _1 : Type, _2 : Type } → Type
        , constraint :
            Type → Type
        , identity :
            Type
        , op :
            { _1 : Type, _2 : Type } → Type
        }
      → { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
      → Type
  , Codensity :
        { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
      → (Type → Type)
      → Type
      → Type
  , CommutativeGroup :
      Type → Type
  , CommutativeMonoid :
      Type → Type
  , Comonad :
      (Type → Type) → Type
  , Compose :
      { _1 : Type → Type, _2 : Type → Type } → Type → Type
  , Const :
      { _1 : Type, _2 : Type } → Type
  , Costar :
      (Type → Type) → { _1 : Type, _2 : Type } → Type
  , Coyoneda :
      (Type → Type) → Type → Type
  , Day :
      { _1 : Type → Type, _2 : Type → Type } → Type → Type
  , Density :
        { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
      → (Type → Type)
      → Type
      → Type
  , Either :
      { _1 : Type, _2 : Type } → Type
  , Endofunctor :
      (Type → Type) → Type
  , Eq :
      Type → Type
  , Field :
      Type → Type
  , Group :
      Type → Type
  , HomFunctor :
      ({ _1 : Type, _2 : Type } → Type) → Type
  , Identity :
      Type → Type
  , InternalHomFunctor :
      ({ _1 : Type, _2 : Type } → Type) → Type
  , Lan :
      (Type → Type) → (Type → Type) → Type → Type
  , Leibniz :
      { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
  , Monad :
      (Type → Type) → Type
  , Monoid :
      Type → Type
  , MonoidalFunctor :
      (Type → Type) → Type
  , NaturalTransformation :
      { _1 : Type → Type, _2 : Type → Type } → Type
  , OrderedField :
      Type → Type
  , OrderedGroup :
      Type → Type
  , OrderedRing :
      Type → Type
  , PartiallyOrderedField :
      Type → Type
  , PartiallyOrderedGroup :
      Type → Type
  , PartiallyOrderedRing :
      Type → Type
  , Profunctor :
      ({ _1 : Type, _2 : Type } → Type) → Type
  , Ran :
      (Type → Type) → (Type → Type) → Type → Type
  , Rig :
      Type → Type
  , Ring :
      Type → Type
  , Semigroup :
      Type → Type
  , Semigroupoid :
        { arrow :
            { _1 : Type, _2 : Type } → Type
        , constraint :
            Type → Type
        , identity :
            Type
        , op :
            { _1 : Type, _2 : Type } → Type
        }
      → { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
      → ({ _1 : Type, _2 : Type } → Type)
      → Type
  , Semiring :
      Type → Type
  , Star :
      (Type → Type) → { _1 : Type, _2 : Type } → Type
  , Strong :
      ({ _1 : Type, _2 : Type } → Type) → Type
  , Traversable :
      (Type → Type) → (Type → Type) → Type
  , Tuple :
      { _1 : Type, _2 : Type } → Type
  , Unit :
      Type
  , Void :
      Type
  , Yoneda :
      (Type → Type) → Type → Type
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p>{- FIXME: This should use `./../Monoid/Type … (./../Category/Monoidal/Profunctor
          object morphism)`, but the identity in that monoidal category
          definition isn’t correct (or, if it is, I can’t figure out how to use
          it). So instead, we just build the `Semigroup`, and then write a
          custom identity. But this means we’re not structurally a `Monoid`.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ { identity :
      ∀(a : object) → cat.arrow { _1 = a, _2 = a }
  , op :
        { _1 : object, _2 : object }
      → (   Type
          → (   object
              → cat.arrow { _1 = _, _2 = _@2._2 }
              → cat.arrow { _1 = _@3._1, _2 = _@1 }
              → _@3
            )
          → _@1
        )
      → cat.arrow _@1
  }
</pre></dd>
</dl>
<h4>extractSemigroupoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ∀ ( category
    : { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ { op :
        { _1 : object, _2 : object }
      → (   Type
          → (   object
              → cat.arrow { _1 = _, _2 = _@2._2 }
              → cat.arrow { _1 = _@3._1, _2 = _@1 }
              → _@3
            )
          → _@1
        )
      → cat.arrow _@1
  }
</pre></dd>
</dl>
<h4>postcomposition (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ∀ ( category
    : { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀(c : object)
→ { map :
        ∀(x : object)
      → ∀(y : object)
      → ∀(fn : cat.arrow { _1 = x, _2 = y })
      → ∀(input : cat.arrow { _1 = c, _2 = x })
      → cat.arrow { _1 = c, _2 = y }
  }
</pre></dd>
</dl>
<h4>precomposition (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ∀ ( category
    : { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀(c : object)
→ { map :
        ∀(x : object)
      → ∀(y : object)
      → ∀(fn : cat.arrow { _1 = y, _2 = x })
      → ∀(input : cat.arrow { _1 = x, _2 = c })
      → cat.arrow { _1 = y, _2 = c }
  }
</pre></dd>
</dl>
<h4>types.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ { Adjunction :
      (object → object) → (object → object) → Type
  , Bifunctor :
      ({ _1 : object, _2 : object } → object) → Type
  , Category :
        { arrow :
            { _1 : Type, _2 : Type } → Type
        , constraint :
            Type → Type
        , identity :
            Type
        , op :
            { _1 : Type, _2 : Type } → Type
        }
      → { arrow :
            { _1 : object, _2 : object } → Type
        , constraint :
            object → Type
        }
      → Type
  , Codensity :
        { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
      → (object → Type)
      → Type
      → Type
  , Comonad :
      (object → object) → Type
  , Compose :
      { _1 : object → object, _2 : object → object } → object → object
  , Const :
      { _1 : object, _2 : object } → object
  , Costar :
      (object → object) → { _1 : object, _2 : object } → Type
  , Coyoneda :
      (object → Type) → object → Type
  , Density :
        { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type }
      → (object → Type)
      → Type
      → Type
  , Endofunctor :
      (object → object) → Type
  , HomFunctor :
      ({ _1 : object, _2 : object } → Type) → Type
  , Identity :
      object → object
  , Lan :
      (object → object) → (object → Type) → object → Type
  , Leibniz :
      { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
  , Monad :
      (object → object) → Type
  , NaturalTransformation :
      { _1 : object → object, _2 : object → object } → Type
  , Profunctor :
      ({ _1 : object, _2 : object } → Type) → Type
  , Ran :
      (object → object) → (object → Type) → object → Type
  , Semigroupoid :
        { arrow :
            { _1 : Type, _2 : Type } → Type
        , constraint :
            Type → Type
        , identity :
            Type
        , op :
            { _1 : Type, _2 : Type } → Type
        }
      → { arrow :
            { _1 : object, _2 : object } → Type
        , constraint :
            object → Type
        }
      → ({ _1 : object, _2 : object } → Type)
      → Type
  , Star :
      (object → object) → { _1 : object, _2 : object } → Type
  , Strong :
      ({ _1 : object, _2 : object } → Type) → Type
  , Traversable :
      ∀(m : object → object) → (object → object) → Type
  , Yoneda :
      (object → Type) → object → Type
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Codensity</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(d : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ ∀(m : cObject → Type)
→ Type
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(d : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ λ(m : cObject → Type)
→ λ(_ : Type)
→ cObject → d.arrow { _1 = _@1, _2 = m _ } → m _@1
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Codensity/functor</h3>
<h4>endo (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ { map :
        Type
      → Type
      → (_@1 → _@1)
      → (Type → (_@3 → m _@1) → m _@1)
      → Type
      → (_@3 → m _@1)
      → m _@1
  }
</pre></dd>
</dl>
<h4>monoidal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ { identity :
      Type → ({} → _@1) → Type → (_@2 → m _@1) → m _@1
  , map :
        Type
      → Type
      → (_@1 → _@1)
      → (Type → (_@3 → m _@1) → m _@1)
      → Type
      → (_@3 → m _@1)
      → m _@1
  , op :
        Type
      → (   Type
          → (   { _1 : Type, _2 : Type }
              → ({ _1 : _._1, _2 : _._2 } → _@3)
              → { _1 :
                    Type → (_@2._1 → m _@1) → m _@1
                , _2 :
                    Type → (_@2._2 → m _@1) → m _@1
                }
              → _@3
            )
          → _@1
        )
      → Type
      → (_@2 → m _@1)
      → m _@1
  }
</pre></dd>
</dl>
<h4>lift (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ∀ ( semigroupoid
    : { op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀(f : object → object)
→ ∀ ( functor
    : { map :
            object
          → object
          → cat.arrow { _1 = _@1, _2 = _ }
          → cat.arrow { _1 = f _@2, _2 = f _@1 }
      }
    )
→ ∀ ( monad
    : { identity :
          object → cat.arrow { _1 = _, _2 = f _ }
      , op :
          object → cat.arrow { _1 = f (f _), _2 = f _ }
      }
    )
→ object
→ object
→ cat.arrow { _1 = _@1, _2 = f _ }
→ cat.arrow { _1 = f _@2, _2 = f _@1 }
</pre></dd>
</dl>
<h4>lower (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀ ( monoidal
    : { identity :
          Type → ({} → _@1) → m _@1
      , map :
          Type → Type → (_@1 → _@1) → m _@2 → m _@2
      , op :
            Type
          → (   Type
              → (   { _1 : Type, _2 : Type }
                  → ({ _1 : _._1, _2 : _._2 } → _@3)
                  → { _1 : m _@1._1, _2 : m _@1._2 }
                  → _@3
                )
              → _@1
            )
          → m _@1
      }
    )
→ Type
→ (Type → (_@1 → m _@1) → m _@1)
→ m _@1
</pre></dd>
</dl>
<h4>monad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀ ( category
    : { identity :
          Type → _ → _@1
      , op :
            { _1 : Type, _2 : Type }
          → (Type → (Type → (_ → _@3._2) → (_@3._1 → _@2) → _@3) → _@1)
          → _@1._1
          → _@2._2
      }
    )
→ ∀(m : Type → Type)
→ { identity :
      ∀(a : Type) → ∀(x : a) → ∀(b : Type) → ∀(k : a → m b) → m b
  , op :
        ∀(a : Type)
      → ∀(codensity : Type → ((Type → (a → m _@1) → m _@1) → m _@1) → m _@1)
      → ∀(c : Type)
      → ∀(l : a → m c)
      → m c
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Comonad</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ (object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ λ(_ : object → object)
→ { identity :
      object → cat.arrow { _1 = _@1 _, _2 = _ }
  , op :
      object → cat.arrow { _1 = _@1 _, _2 = _@1 (_@1 _) }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Comonoid</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
∀(kArrow : Kind → Kind → Kind) → ∀(kProduct : Kind → Kind → Kind) → Kind → Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(_ : Kind)
→ { identity : _, op : kArrow _ (kProduct _ _) }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ object
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(_ : object)
→ { identity :
      cat.arrow { _1 = _, _2 = cat.identity }
  , op :
      cat.arrow { _1 = _, _2 = cat.op { _1 = _, _2 = _ } }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Compose</h2>
<h4>Type (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀(eObject : Kind)
→ ∀(f : { _1 : dObject → eObject, _2 : cObject → dObject })
→ ∀(a : cObject)
→ eObject
</pre></dd>
</dl>
<h4>adjunction (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h4>comonad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀(dObject : Kind)
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ ∀(f : dObject → cObject)
→ ∀ ( fFunctor
    : { map :
            dObject
          → dObject
          → d.arrow { _1 = _@1, _2 = _ }
          → c.arrow { _1 = f _@2, _2 = f _@1 }
      }
    )
→ ∀(g : cObject → dObject)
→ ∀ ( adjunction
    : { counit :
          cObject → c.arrow { _1 = f (g _), _2 = _ }
      , leftAdjunct :
            dObject
          → cObject
          → c.arrow { _1 = f _@1, _2 = _ }
          → d.arrow { _1 = _@2, _2 = g _@1 }
      , rightAdjunct :
            dObject
          → cObject
          → d.arrow { _1 = _@1, _2 = g _ }
          → c.arrow { _1 = f _@2, _2 = _@1 }
      , unit :
          dObject → d.arrow { _1 = _, _2 = g (f _) }
      }
    )
→ { identity :
      cObject → c.arrow { _1 = f (g _), _2 = _ }
  , op :
      ∀(a : cObject) → c.arrow { _1 = f (g a), _2 = f (g (f (g a))) }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Compose/functor</h3>
<h4>instance (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      }
    )
→ ∀ ( vCategory
    : { identity :
          vObject → v.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : vObject, _2 : vObject }
          → (   Type
              → (   vObject
                  → v.arrow { _1 = _, _2 = _@2._2 }
                  → v.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → v.arrow _@1
      }
    )
→ ∀(cObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → vObject
      , constraint :
          cObject → Type
      }
    )
→ ∀(dObject : Kind)
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → vObject
      , constraint :
          dObject → Type
      }
    )
→ ∀(eObject : Kind)
→ ∀ ( e
    : { arrow :
          { _1 : eObject, _2 : eObject } → vObject
      , constraint :
          eObject → Type
      }
    )
→ ∀(f : dObject → eObject)
→ ∀ ( fFunctor
    : { map :
            dObject
          → dObject
          → v.arrow
            { _1 =
                d.arrow { _1 = _@1, _2 = _ }
            , _2 =
                e.arrow { _1 = f _@1, _2 = f _ }
            }
      }
    )
→ ∀(g : cObject → dObject)
→ ∀ ( gFunctor
    : { map :
            cObject
          → cObject
          → v.arrow
            { _1 =
                c.arrow { _1 = _@1, _2 = _ }
            , _2 =
                d.arrow { _1 = g _@1, _2 = g _ }
            }
      }
    )
→ { map :
        ∀(a : cObject)
      → ∀(b : cObject)
      → v.arrow
        { _1 =
            c.arrow { _1 = a, _2 = b }
        , _2 =
            e.arrow { _1 = f (g a), _2 = f (g b) }
        }
  }
</pre></dd>
</dl>
<h4>monoidal (term)</h4>
<p>{- NB: Since this is currently forced to be in *Set*, it’s quite possible that
       some of the uses of _C_ and _D_ are wrong, since the type system can’t
       distinguish them. So take them with a grain of salt if you’re editing
       this file.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(v : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ ∀ ( vCategory
    : { identity :
          Type → v.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : Type, _2 : Type }
          → (   Type
              → (   Type
                  → v.arrow { _1 = _, _2 = _@2._2 }
                  → v.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → v.arrow _@1
      }
    )
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      , identity :
          cObject
      , op :
          { _1 : cObject, _2 : cObject } → cObject
      }
    )
→ ∀(f : Type → Type)
→ ∀ ( fMonoidal
    : { identity :
          Type → ({} → _@1) → f _@1
      , map :
          Type → Type → v.arrow { _1 = _@1 → _@1, _2 = f _@1 → f _@1 }
      , op :
            Type
          → (   Type
              → (   { _1 : Type, _2 : Type }
                  → ({ _1 : _._1, _2 : _._2 } → _@3)
                  → { _1 : f _@1._1, _2 : f _@1._2 }
                  → _@3
                )
              → _@1
            )
          → f _@1
      }
    )
→ ∀(g : cObject → Type)
→ ∀ ( gMonoidal
    : { identity :
          cObject → c.arrow { _1 = c.identity, _2 = _ } → g _@1
      , map :
            cObject
          → cObject
          → v.arrow { _1 = c.arrow { _1 = _@1, _2 = _ }, _2 = g _@1 → g _@1 }
      , op :
            cObject
          → (   Type
              → (   { _1 : cObject, _2 : cObject }
                  → c.arrow { _1 = c.op _, _2 = _@2 }
                  → { _1 : g _@1._1, _2 : g _@1._2 }
                  → _@3
                )
              → _@1
            )
          → g _@1
      }
    )
→ { identity :
      ∀(a : cObject) → ∀(fn : c.arrow { _1 = c.identity, _2 = a }) → f (g a)
  , map :
        ∀(a : cObject)
      → ∀(b : cObject)
      → v.arrow { _1 = c.arrow { _1 = a, _2 = b }, _2 = f (g a) → f (g b) }
  , op :
        ∀(i : cObject)
      → ∀ ( day
          :   Type
            → (   { _1 : cObject, _2 : cObject }
                → c.arrow { _1 = c.op _, _2 = i }
                → { _1 : f (g _@1._1), _2 : f (g _@1._2) }
                → _@3
              )
            → _@1
          )
      → f (g i)
  }
</pre></dd>
</dl>
<h4>monad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀(dObject : Kind)
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ ∀(f : dObject → cObject)
→ ∀(g : cObject → dObject)
→ ∀ ( gFunctor
    : { map :
            cObject
          → cObject
          → c.arrow { _1 = _@1, _2 = _ }
          → d.arrow { _1 = g _@2, _2 = g _@1 }
      }
    )
→ ∀ ( adjunction
    : { counit :
          cObject → c.arrow { _1 = f (g _), _2 = _ }
      , leftAdjunct :
            dObject
          → cObject
          → c.arrow { _1 = f _@1, _2 = _ }
          → d.arrow { _1 = _@2, _2 = g _@1 }
      , rightAdjunct :
            dObject
          → cObject
          → d.arrow { _1 = _@1, _2 = g _ }
          → c.arrow { _1 = f _@2, _2 = _@1 }
      , unit :
          dObject → d.arrow { _1 = _, _2 = g (f _) }
      }
    )
→ { identity :
      dObject → d.arrow { _1 = _, _2 = g (f _) }
  , op :
      ∀(a : dObject) → d.arrow { _1 = g (f (g (f a))), _2 = g (f a) }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Const</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
∀(a : { _1 : Kind, _2 : Kind }) → Kind
</pre></dd>
<dt>kind</dt><dd><pre>
λ(a : { _1 : Kind, _2 : Kind }) → a._1
</pre></dd>
</dl>
<h4>Type (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀(a : { _1 : cObject, _2 : dObject })
→ cObject
</pre></dd>
</dl>
<h4>functor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( cCategory
    : { identity :
          cObject → c.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : cObject, _2 : cObject }
          → (   Type
              → (   cObject
                  → c.arrow { _1 = _, _2 = _@2._2 }
                  → c.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → c.arrow _@1
      }
    )
→ ∀(dObject : Kind)
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ { map :
        ∀(a : { _1 : cObject, _2 : dObject })
      → ∀(b : { _1 : cObject, _2 : dObject })
      → ∀ ( f
          : { _1 :
                c.arrow { _1 = a._1, _2 = b._1 }
            , _2 :
                d.arrow { _1 = a._2, _2 = b._2 }
            }
          )
      → c.arrow { _1 = a._1, _2 = b._1 }
  }
</pre></dd>
</dl>
<h4>term (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Type)
→ ∀(dObject : Type)
→ ∀(a : { _1 : cObject, _2 : dObject })
→ cObject
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Cosemigroup</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ object
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(_ : object)
→ { op : cat.arrow { _1 = _, _2 = cat.op { _1 = _, _2 = _ } } }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Costar</h2>
<h4>Type (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → vObject
      , constraint :
          object → Type
      }
    )
→ (object → object)
→ { _1 : object, _2 : object }
→ vObject
</pre></dd>
</dl>
<h4>category (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h4>semigroupoid (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Coyoneda</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ (object → Type)
→ object
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ λ(_ : object → Type)
→ λ(_ : object)
→ Type → (object → cat.arrow { _1 = _, _2 = _@2 } → _@4 _@1 → _@3) → _@1
</pre></dd>
</dl>
<h4>functor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ∀ ( semigroupoid
    : { op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ (object → Type)
→ { map :
        object
      → object
      → cat.arrow { _1 = _@1, _2 = _ }
      → (Type → (object → cat.arrow { _1 = _, _2 = _@4 } → _@6 _@1 → _@3) → _@1)
      → Type
      → (object → cat.arrow { _1 = _, _2 = _@4 } → _@7 _@1 → _@3)
      → _@1
  }
</pre></dd>
</dl>
<h4>lift (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀(cat : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ ∀ ( category
    : { identity :
          Type → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : Type, _2 : Type }
          → (   Type
              → (   Type
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ (Type → Type)
→ Type
→ _@1 _
→ Type
→ (Type → cat.arrow { _1 = _, _2 = _@3 } → _@5 _@1 → _@3)
→ _@1
</pre></dd>
</dl>
<h4>lower (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀(f : cObject → Type)
→ ∀ ( functor
    : { map : cObject → cObject → c.arrow { _1 = _@1, _2 = _ } → f _@2 → f _@2 }
    )
→ cObject
→ (Type → (cObject → c.arrow { _1 = _, _2 = _@2 } → f _@1 → _@3) → _@1)
→ f _@1
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Day</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      , identity :
          cObject
      , op :
          { _1 : cObject, _2 : cObject } → cObject
      }
    )
→ ∀(f : { _1 : cObject → Type, _2 : cObject → Type })
→ cObject
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ λ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      , identity :
          cObject
      , op :
          { _1 : cObject, _2 : cObject } → cObject
      }
    )
→ λ(f : { _1 : cObject → Type, _2 : cObject → Type })
→ λ(_ : cObject)
→   Type
  → (   { _1 : cObject, _2 : cObject }
      → c.arrow { _1 = c.op _, _2 = _@2 }
      → v.op { _1 = f._1 _@1._1, _2 = f._2 _@1._2 }
      → _@3
    )
  → _@1
</pre></dd>
</dl>
<h4>comonad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀ ( semigroupoid
    : { op :
            { _1 : Type, _2 : Type }
          → (Type → (Type → (_ → _@3._2) → (_@3._1 → _@2) → _@3) → _@1)
          → _@1._1
          → _@2._2
      }
    )
→ ∀(f : Type → Type)
→ ∀(fComonad : { identity : Type → f _ → _@1, op : Type → f _ → f (f _@1) })
→ ∀(g : Type → Type)
→ ∀(gComonad : { identity : Type → g _ → _@1, op : Type → g _ → g (g _@1) })
→ { identity :
        ∀(a : Type)
      → ∀ ( day
          :   Type
            → (   { _1 : Type, _2 : Type }
                → ({ _1 : _._1, _2 : _._2 } → a)
                → { _1 : f _@1._1, _2 : g _@1._2 }
                → _@3
              )
            → _@1
          )
      → a
  , op :
        ∀(a : Type)
      → ∀ ( day
          :   Type
            → (   { _1 : Type, _2 : Type }
                → ({ _1 : _._1, _2 : _._2 } → a)
                → { _1 : f _@1._1, _2 : g _@1._2 }
                → _@3
              )
            → _@1
          )
      → Type
      → (   { _1 : Type, _2 : Type }
          → (   { _1 : _._1, _2 : _._2 }
              → Type
              → (   { _1 : Type, _2 : Type }
                  → ({ _1 : _._1, _2 : _._2 } → a)
                  → { _1 : f _@1._1, _2 : g _@1._2 }
                  → _@3
                )
              → _@1
            )
          → { _1 : f _@1._1, _2 : g _@1._2 }
          → _@3
        )
      → _@1
  }
</pre></dd>
</dl>
<h4>convolution (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      , identity :
          cObject
      , op :
          { _1 : cObject, _2 : cObject } → cObject
      }
    )
→ ∀(f : cObject → Type)
→ ∀(g : cObject → Type)
→ ∀(a : cObject)
→ ∀(r : Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ λ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      , identity :
          cObject
      , op :
          { _1 : cObject, _2 : cObject } → cObject
      }
    )
→ λ(f : cObject → Type)
→ λ(g : cObject → Type)
→ λ(a : cObject)
→ λ(r : Type)
→   ∀(b : { _1 : cObject, _2 : cObject })
  → c.arrow { _1 = c.op b, _2 = a }
  → v.arrow { _1 = v.op { _1 = f b._1, _2 = g b._2 }, _2 = r }
</pre></dd>
</dl>
<h4>functor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      , identity :
          cObject
      , op :
          { _1 : cObject, _2 : cObject } → cObject
      }
    )
→ ∀ ( semigroupoid
    : { op :
            { _1 : cObject, _2 : cObject }
          → (   Type
              → (   cObject
                  → c.arrow { _1 = _, _2 = _@2._2 }
                  → c.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → c.arrow _@1
      }
    )
→ ∀(f : cObject → Type)
→ ∀(g : cObject → Type)
→ { map :
        ∀(a : cObject)
      → ∀(b : cObject)
      → ∀(fn : c.arrow { _1 = a, _2 = b })
      → ∀ ( day
          :   Type
            → (   { _1 : cObject, _2 : cObject }
                → c.arrow { _1 = c.op _, _2 = a }
                → { _1 : f _@1._1, _2 : g _@1._2 }
                → _@3
              )
            → _@1
          )
      → Type
      → (   { _1 : cObject, _2 : cObject }
          → c.arrow { _1 = c.op _, _2 = b }
          → { _1 : f _@1._1, _2 : g _@1._2 }
          → _@3
        )
      → _@1
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Density</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(d : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ ∀(f : cObject → Type)
→ Type
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(d : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ λ(f : cObject → Type)
→ λ(_ : Type)
→ Type → (cObject → d.arrow { _1 = f _, _2 = _@2 } → f _@1 → _@3) → _@1
</pre></dd>
</dl>
<h4>functor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(d : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ ∀ ( dSemigroupoid
    : { op :
            { _1 : Type, _2 : Type }
          → (   Type
              → (   Type
                  → d.arrow { _1 = _, _2 = _@2._2 }
                  → d.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → d.arrow _@1
      }
    )
→ ∀(f : cObject → Type)
→ { map :
        Type
      → Type
      → d.arrow { _1 = _@1, _2 = _ }
      → (Type → (cObject → d.arrow { _1 = f _, _2 = _@4 } → f _@1 → _@3) → _@1)
      → Type
      → (cObject → d.arrow { _1 = f _, _2 = _@4 } → f _@1 → _@3)
      → _@1
  }
</pre></dd>
</dl>
<h4>lift (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀(cat : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ ∀ ( semigroupoid
    : { op :
            { _1 : Type, _2 : Type }
          → (   Type
              → (   Type
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀(f : Type → Type)
→ ∀ ( comonad
    : { identity :
          Type → cat.arrow { _1 = f _, _2 = _ }
      , op :
          Type → cat.arrow { _1 = f _, _2 = f (f _) }
      }
    )
→ Type
→ f _
→ Type
→ (Type → cat.arrow { _1 = f _, _2 = _@3 } → f _@1 → _@3)
→ _@1
</pre></dd>
</dl>
<h4>lower (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀(functor : { map : Type → Type → (_@1 → _@1) → f _@2 → f _@2 })
→ ∀(comonad : { identity : Type → f _ → _@1, op : Type → f _ → f (f _@1) })
→ Type
→ (Type → (Type → (f _ → _@3) → f _@1 → _@3) → _@1)
→ f _@1
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Duoid</h2>
<h4>Kind (kind)</h4>
<p>{- A duoid (also known as a “united monoid”) is actually a pair of monoids with
   a shared `identity`. The `additive.op` distributes over the
  `multiplicative.op` as well.
-}</p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(m : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(m : Kind)
→ { additive :
      { identity : m, op : kArrow (kProduct m m) m }
  , multiplicative :
      { identity : m, op : kArrow (kProduct m m) m }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p>{- A duoid (also known as a “united monoid”) is actually a pair of monoids with
   a shared `identity`. The `additive.op` distributes over the
  `multiplicative.op` as well.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { additive :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  , multiplicative :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Either</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
∀(a : Kind) → ∀(b : Kind) → Kind
</pre></dd>
<dt>kind</dt><dd><pre>
λ(a : Kind) → λ(b : Kind) → < Left : a | Right : b >
</pre></dd>
</dl>
<h4>duoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(semigroup : { op : { _1 : a, _2 : a } → a })
→ { additive :
      { identity :
          Type → ({} → _@1) → < Left : a | Right : _@1 >
      , op :
            Type
          → (   Type
              → (   { _1 : Type, _2 : Type }
                  → ({ _1 : _._1, _2 : _._2 } → _@3)
                  → { _1 :
                        < Left : a | Right : _@1._1 >
                    , _2 :
                        < Left : a | Right : _@1._2 >
                    }
                  → _@3
                )
              → _@1
            )
          → < Left : a | Right : _@1 >
      }
  , multiplicative :
      { identity :
          Type → ({} → _@1) → < Left : a | Right : _@1 >
      , op :
            Type
          → (   Type
              → (   { _1 : Type, _2 : Type }
                  → ({ _1 : _._1, _2 : _._2 } → _@3)
                  → { _1 :
                        < Left : a | Right : _@1._1 >
                    , _2 :
                        < Left : a | Right : _@1._2 >
                    }
                  → _@3
                )
              → _@1
            )
          → < Left : a | Right : _@1 >
      }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Either/functor</h3>
<h4 style="background-color: #bbb; width: 100%">./Either/functor/endo</h4>
<h4>star (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀ ( monoidal
    : { identity :
          Type → ({} → _@1) → m _@1
      , map :
          Type → Type → (_@1 → _@1) → m _@2 → m _@2
      , op :
            Type
          → (   Type
              → (   { _1 : Type, _2 : Type }
                  → ({ _1 : _._1, _2 : _._2 } → _@3)
                  → { _1 : m _@1._1, _2 : m _@1._2 }
                  → _@3
                )
              → _@1
            )
          → m _@1
      }
    )
→ ∀(a : Type)
→ { map :
        ∀(b : Type)
      → ∀(c : Type)
      → ∀(f : b → m c)
      → < Left : a | Right : b >
      → m < Left : a | Right : c >
  }
</pre></dd>
</dl>
<h4 style="background-color: #bbb; width: 100%">./Either/functor/monoidal</h4>
<h4>parallel (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(semigroup : { op : { _1 : a, _2 : a } → a })
→ { identity :
      ∀(b : Type) → ∀(fn : {} → b) → < Left : a | Right : b >
  , map :
        Type
      → Type
      → (_@1 → _@1)
      → < Left : a | Right : _@2 >
      → < Left : a | Right : _@2 >
  , op :
        ∀(i : Type)
      → ∀ ( day
          :   ∀(r : Type)
            → (   ∀(d : { _1 : Type, _2 : Type })
                → ({ _1 : d._1, _2 : d._2 } → i)
                → { _1 :
                      < Left : a | Right : d._1 >
                  , _2 :
                      < Left : a | Right : d._2 >
                  }
                → r
              )
            → r
          )
      → < Left : a | Right : i >
  }
</pre></dd>
</dl>
<h4>sequential (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ { identity :
      Type → ({} → _@1) → < Left : a | Right : _@1 >
  , map :
        Type
      → Type
      → (_@1 → _@1)
      → < Left : a | Right : _@2 >
      → < Left : a | Right : _@2 >
  , op :
        Type
      → (   Type
          → (   { _1 : Type, _2 : Type }
              → ({ _1 : _._1, _2 : _._2 } → _@3)
              → { _1 :
                    < Left : a | Right : _@1._1 >
                , _2 :
                    < Left : a | Right : _@1._2 >
                }
              → _@3
            )
          → _@1
        )
      → < Left : a | Right : _@1 >
  }
</pre></dd>
</dl>
<h4>pair (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀(functor : { map : Type → Type → (_@1 → _@1) → m _@2 → m _@2 })
→ { map :
        ∀(a : { _1 : Type, _2 : Type })
      → ∀(b : { _1 : Type, _2 : Type })
      → ∀(f : { _1 : a._1 → m b._1, _2 : a._2 → m b._2 })
      → ∀(e : < Left : a._1 | Right : a._2 >)
      → m < Left : b._1 | Right : b._2 >
  }
</pre></dd>
</dl>
<h4>monad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ { identity :
      ∀(b : Type) → ∀(x : b) → < Left : a | Right : b >
  , op :
        ∀(b : Type)
      → ∀(fa : < Left : a | Right : < Left : a | Right : b > >)
      → < Left : a | Right : b >
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Eq</h2>
<h4>Type (type)</h4>
<p>{- `bool` is some sort of `Const` functor in the correct category that can be
--     converted to a `Bool`.
-- -}</p>
<dl>
<dt>kind</dt><dd><pre>
∀(a : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
λ(a : Type) → { eq : a → a → Bool }
</pre></dd>
</dl>
<h4>eqfn (term)</h4>
<p>{- When defining properties, you almost always are trying to show the
   equivalence of two functions. This makes that easier.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(b : Type)
→ ∀(eq : { eq : b → b → Bool })
→ ∀(f : a → b)
→ ∀(g : a → b)
→ ∀(x : a)
→ Bool
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Eq/functor</h3>
<h4>contravariant (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ map :
      ∀(a : Type)
    → ∀(b : Type)
    → ∀(fn : b → a)
    → ∀(fa : { eq : a → a → Bool })
    → { eq : ∀(x : b) → ∀(y : b) → Bool }
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Field</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(m : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(m : Kind)
→ { additive :
      { identity : m, inverse : kArrow m m, op : kArrow (kProduct m m) m }
  , multiplicative :
      { identity : m, inverse : kArrow m m, op : kArrow (kProduct m m) m }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Field/Ordered</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { additive :
      { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , le :
          m → m → Bool
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  }
</pre></dd>
</dl>
<h4>extractPartiallyOrderedField (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( field
    : { additive :
          { eq :
              m → m → Bool
          , identity :
              {} → m
          , inverse :
              m → m
          , le :
              m → m → Bool
          , op :
              { _1 : m, _2 : m } → m
          , partialLE :
              m → m → Optional Bool
          , preLE :
              m → m → Optional Bool
          }
      , multiplicative :
          { identity :
              {} → m
          , inverse :
              m → m
          , op :
              { _1 : m, _2 : m } → m
          , preLE :
              m → m → Optional Bool
          }
      }
    )
→ { additive :
      { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( field
    : { additive :
          { eq :
              m → m → Bool
          , identity :
              {} → m
          , inverse :
              m → m
          , le :
              m → m → Bool
          , op :
              { _1 : m, _2 : m } → m
          , partialLE :
              m → m → Optional Bool
          , preLE :
              m → m → Optional Bool
          }
      , multiplicative :
          { identity :
              {} → m
          , inverse :
              m → m
          , op :
              { _1 : m, _2 : m } → m
          , preLE :
              m → m → Optional Bool
          }
      }
    )
→ { add :
      { _1 : m, _2 : m } → m
  , divide :
      { _1 : m, _2 : m } → m
  , eq :
      m → m → Bool
  , le :
      m → m → Bool
  , multiply :
      { _1 : m, _2 : m } → m
  , negate :
      m → m
  , one :
      {} → m
  , partialLE :
      m → m → Optional Bool
  , reciprocal :
      m → m
  , subtract :
      { _1 : m, _2 : m } → m
  , zero :
      {} → m
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Field/PartiallyOrdered</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { additive :
      { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  }
</pre></dd>
</dl>
<h4>extractField (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( field
    : { additive :
          { eq :
              m → m → Bool
          , identity :
              {} → m
          , inverse :
              m → m
          , op :
              { _1 : m, _2 : m } → m
          , partialLE :
              m → m → Optional Bool
          , preLE :
              m → m → Optional Bool
          }
      , multiplicative :
          { identity :
              {} → m
          , inverse :
              m → m
          , op :
              { _1 : m, _2 : m } → m
          , preLE :
              m → m → Optional Bool
          }
      }
    )
→ { additive :
      { identity : {} → m, inverse : m → m, op : { _1 : m, _2 : m } → m }
  , multiplicative :
      { identity : {} → m, inverse : m → m, op : { _1 : m, _2 : m } → m }
  }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( field
    : { additive :
          { eq :
              m → m → Bool
          , identity :
              {} → m
          , inverse :
              m → m
          , op :
              { _1 : m, _2 : m } → m
          , partialLE :
              m → m → Optional Bool
          , preLE :
              m → m → Optional Bool
          }
      , multiplicative :
          { identity :
              {} → m
          , inverse :
              m → m
          , op :
              { _1 : m, _2 : m } → m
          , preLE :
              m → m → Optional Bool
          }
      }
    )
→ { add :
      { _1 : m, _2 : m } → m
  , divide :
      { _1 : m, _2 : m } → m
  , eq :
      m → m → Bool
  , multiply :
      { _1 : m, _2 : m } → m
  , negate :
      m → m
  , one :
      {} → m
  , partialLE :
      m → m → Optional Bool
  , reciprocal :
      m → m
  , subtract :
      { _1 : m, _2 : m } → m
  , zero :
      {} → m
  }
</pre></dd>
</dl>
<h4>Set (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { additive :
      { identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { additive :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , inverse :
          cat.arrow { _1 = m, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  , multiplicative :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , inverse :
          cat.arrow { _1 = m, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>divide (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀ ( category
    : { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀ ( bifunctor
    : { map :
            { _1 : object, _2 : object }
          → { _1 : object, _2 : object }
          → { _1 :
                cat.arrow { _1 = _@1._1, _2 = _._1 }
            , _2 :
                cat.arrow { _1 = _@1._2, _2 = _._2 }
            }
          → cat.arrow { _1 = cat.op _@2, _2 = cat.op _@1 }
      }
    )
→ ∀(m : object)
→ ∀ ( field
    : { additive :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , inverse :
              cat.arrow { _1 = m, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      , multiplicative :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , inverse :
              cat.arrow { _1 = m, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      }
    )
→ cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
</pre></dd>
</dl>
<h4>extractCommutativeRing (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ ∀ ( field
    : { additive :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , inverse :
              cat.arrow { _1 = m, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      , multiplicative :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , inverse :
              cat.arrow { _1 = m, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      }
    )
→ { additive :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , inverse :
          cat.arrow { _1 = m, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  , multiplicative :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>extractRing (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ ∀ ( field
    : { additive :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , inverse :
              cat.arrow { _1 = m, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      , multiplicative :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , inverse :
              cat.arrow { _1 = m, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      }
    )
→ { additive :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , inverse :
          cat.arrow { _1 = m, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  , multiplicative :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀ ( category
    : { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀ ( bifunctor
    : { map :
            { _1 : object, _2 : object }
          → { _1 : object, _2 : object }
          → { _1 :
                cat.arrow { _1 = _@1._1, _2 = _._1 }
            , _2 :
                cat.arrow { _1 = _@1._2, _2 = _._2 }
            }
          → cat.arrow { _1 = cat.op _@2, _2 = cat.op _@1 }
      }
    )
→ ∀(m : object)
→ ∀ ( field
    : { additive :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , inverse :
              cat.arrow { _1 = m, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      , multiplicative :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , inverse :
              cat.arrow { _1 = m, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      }
    )
→ { add :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  , divide :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  , multiply :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  , negate :
      cat.arrow { _1 = m, _2 = m }
  , one :
      cat.arrow { _1 = cat.identity, _2 = m }
  , reciprocal :
      cat.arrow { _1 = m, _2 = m }
  , subtract :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  , zero :
      cat.arrow { _1 = cat.identity, _2 = m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Function</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
∀(a : Kind) → ∀(b : Kind) → Kind
</pre></dd>
<dt>kind</dt><dd><pre>
λ(a : Kind) → λ(b : Kind) → a → b
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Functor</h2>
<h3 style="background-color: #bbb; width: 100%">./Functor/Bifunctor</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀(eObject : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      , identity :
          vObject
      , op :
          { _1 : vObject, _2 : vObject } → vObject
      }
    )
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → vObject
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → vObject
      , constraint :
          dObject → Type
      }
    )
→ { arrow :
      { _1 : eObject, _2 : eObject } → vObject
  , constraint :
      eObject → Type
  }
→ ({ _1 : cObject, _2 : dObject } → eObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(vObject : Kind)
→ λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ(eObject : Kind)
→ λ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      , identity :
          vObject
      , op :
          { _1 : vObject, _2 : vObject } → vObject
      }
    )
→ λ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → vObject
      , constraint :
          cObject → Type
      }
    )
→ λ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → vObject
      , constraint :
          dObject → Type
      }
    )
→ λ ( _
    : { arrow :
          { _1 : eObject, _2 : eObject } → vObject
      , constraint :
          eObject → Type
      }
    )
→ λ(_ : { _1 : cObject, _2 : dObject } → eObject)
→ { map :
        { _1 : cObject, _2 : dObject }
      → { _1 : cObject, _2 : dObject }
      → v.arrow
        { _1 =
            v.op
            { _1 =
                c.arrow { _1 = _@1._1, _2 = _._1 }
            , _2 =
                d.arrow { _1 = _@1._2, _2 = _._2 }
            }
        , _2 =
            _@3.arrow { _1 = _@2 _@1, _2 = _@2 _ }
        }
  }
</pre></dd>
</dl>
<h4>impliedFirstFunctor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀(dObject : Kind)
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ ∀ ( dCategory
    : { identity :
          dObject → d.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : dObject, _2 : dObject }
          → (   Type
              → (   dObject
                  → d.arrow { _1 = _, _2 = _@2._2 }
                  → d.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → d.arrow _@1
      }
    )
→ ∀(eObject : Kind)
→ ∀ ( e
    : { arrow :
          { _1 : eObject, _2 : eObject } → Type
      , constraint :
          eObject → Type
      }
    )
→ ∀(f : { _1 : cObject, _2 : dObject } → eObject)
→ ∀ ( bifunctor
    : { map :
            { _1 : cObject, _2 : dObject }
          → { _1 : cObject, _2 : dObject }
          → { _1 :
                c.arrow { _1 = _@1._1, _2 = _._1 }
            , _2 :
                d.arrow { _1 = _@1._2, _2 = _._2 }
            }
          → e.arrow { _1 = f _@2, _2 = f _@1 }
      }
    )
→ ∀(a : dObject)
→ { map :
        ∀(g : cObject)
      → ∀(h : cObject)
      → ∀(fn : c.arrow { _1 = g, _2 = h })
      → e.arrow { _1 = f { _1 = g, _2 = a }, _2 = f { _1 = h, _2 = a } }
  }
</pre></dd>
</dl>
<h4>impliedSecondFunctor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( cCategory
    : { identity :
          cObject → c.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : cObject, _2 : cObject }
          → (   Type
              → (   cObject
                  → c.arrow { _1 = _, _2 = _@2._2 }
                  → c.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → c.arrow _@1
      }
    )
→ ∀(dObject : Kind)
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ ∀(eObject : Kind)
→ ∀ ( e
    : { arrow :
          { _1 : eObject, _2 : eObject } → Type
      , constraint :
          eObject → Type
      }
    )
→ ∀(f : { _1 : cObject, _2 : dObject } → eObject)
→ ∀ ( bifunctor
    : { map :
            { _1 : cObject, _2 : dObject }
          → { _1 : cObject, _2 : dObject }
          → { _1 :
                c.arrow { _1 = _@1._1, _2 = _._1 }
            , _2 :
                d.arrow { _1 = _@1._2, _2 = _._2 }
            }
          → e.arrow { _1 = f _@2, _2 = f _@1 }
      }
    )
→ ∀(a : cObject)
→ { map :
        ∀(b : dObject)
      → ∀(c : dObject)
      → ∀(fn : d.arrow { _1 = b, _2 = c })
      → e.arrow { _1 = f { _1 = a, _2 = b }, _2 = f { _1 = a, _2 = c } }
  }
</pre></dd>
</dl>
<h4>Contravariant (type)</h4>
<p>{- A contravariant functor `C → D` is equivalent to a covariant functor
  `C^op → D`.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      }
    )
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → vObject
      , constraint :
          cObject → Type
      }
    )
→ { arrow :
      { _1 : dObject, _2 : dObject } → vObject
  , constraint :
      dObject → Type
  }
→ (cObject → dObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(vObject : Kind)
→ λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      }
    )
→ λ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → vObject
      , constraint :
          cObject → Type
      }
    )
→ λ ( _
    : { arrow :
          { _1 : dObject, _2 : dObject } → vObject
      , constraint :
          dObject → Type
      }
    )
→ λ(_ : cObject → dObject)
→ { map :
        cObject
      → cObject
      → v.arrow
        { _1 =
            c.arrow { _1 = _, _2 = _@1 }
        , _2 =
            _@3.arrow { _1 = _@2 _@1, _2 = _@2 _ }
        }
  }
</pre></dd>
</dl>
<h4>Costar (type)</h4>
<p>{- A functor from a Cokleisli category to the underlying category -}</p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → vObject
      , constraint :
          object → Type
      }
    )
→ (object → object)
→ (object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(vObject : Kind)
→ λ(object : Kind)
→ λ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      }
    )
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → vObject
      , constraint :
          object → Type
      }
    )
→ λ(_ : object → object)
→ λ(_ : object → object)
→ { map :
        object
      → object
      → v.arrow
        { _1 =
            cat.arrow { _1 = _@3 _, _2 = _@1 }
        , _2 =
            cat.arrow { _1 = _@2 _, _2 = _@2 _@1 }
        }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Functor/Endo</h3>
<h4 style="background-color: #bbb; width: 100%">./Functor/Endo/Star</h4>
<h4>Type (type)</h4>
<p>{- This is very similar to Haskell’s `Traversable`, except that it can be
   implemented for an arbitrary `m`, doesn’t necessarily require an
  `Applicative` instance, and also may be _more_ constrained than `Applicative`.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → vObject
      , constraint :
          object → Type
      }
    )
→ ∀(m : object → object)
→ (object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(vObject : Kind)
→ λ(object : Kind)
→ λ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      }
    )
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → vObject
      , constraint :
          object → Type
      }
    )
→ λ(m : object → object)
→ λ(_ : object → object)
→ { map :
        object
      → object
      → v.arrow
        { _1 =
            cat.arrow { _1 = _@1, _2 = m _ }
        , _2 =
            cat.arrow { _1 = _@2 _@1, _2 = m (_@2 _) }
        }
  }
</pre></dd>
</dl>
<h4>sequence (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ∀ ( category
    : { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀(f : object → object)
→ ∀(g : object → object)
→ ∀ ( functor
    : { map :
            object
          → object
          → cat.arrow { _1 = _@1, _2 = f _ }
          → cat.arrow { _1 = g _@2, _2 = f (g _@1) }
      }
    )
→ ∀(a : object)
→ cat.arrow { _1 = g (f a), _2 = f (g a) }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → vObject
      , constraint :
          object → Type
      }
    )
→ (object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(vObject : Kind)
→ λ(object : Kind)
→ λ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      }
    )
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → vObject
      , constraint :
          object → Type
      }
    )
→ λ(_ : object → object)
→ { map :
        object
      → object
      → v.arrow
        { _1 =
            cat.arrow { _1 = _@1, _2 = _ }
        , _2 =
            cat.arrow { _1 = _@2 _@1, _2 = _@2 _ }
        }
  }
</pre></dd>
</dl>
<h4>Hom (type)</h4>
<p>{- This, specialized to `Type ../Category/Set/type`, is equivalent to Haskell’s
  `Profunctor`. Not to be confused with Dhall’s `./Profunctor`, which is more
   general.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ({ _1 : object, _2 : object } → Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ λ(_ : { _1 : object, _2 : object } → Type)
→ { map :
        { _1 : object, _2 : object }
      → { _1 : object, _2 : object }
      → v.arrow
        { _1 =
            v.op
            { _1 =
                cat.arrow { _1 = _._1, _2 = _@1._1 }
            , _2 =
                cat.arrow { _1 = _@1._2, _2 = _._2 }
            }
        , _2 =
            v.arrow { _1 = _@2 _@1, _2 = _@2 _ }
        }
  }
</pre></dd>
</dl>
<h4>InternalHom (type)</h4>
<p>{- This, specialized to `Type ../Category/Set/type`, is equivalent to Haskell’s
  `Profunctor`. Not to be confused with Dhall’s `./Profunctor`, which is more
   general.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ({ _1 : Type, _2 : Type } → Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ λ(_ : { _1 : Type, _2 : Type } → Type)
→ { map :
        { _1 : Type, _2 : Type }
      → { _1 : Type, _2 : Type }
      → v.arrow
        { _1 =
            v.op
            { _1 =
                v.arrow { _1 = _._1, _2 = _@1._1 }
            , _2 =
                v.arrow { _1 = _@1._2, _2 = _._2 }
            }
        , _2 =
            v.arrow { _1 = _@2 _@1, _2 = _@2 _ }
        }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Functor/Monoidal</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(v : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      , identity :
          cObject
      , op :
          { _1 : cObject, _2 : cObject } → cObject
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀(f : cObject → Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(v : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ λ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      , identity :
          cObject
      , op :
          { _1 : cObject, _2 : cObject } → cObject
      }
    )
→ λ ( d
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ λ(f : cObject → Type)
→ { identity :
      cObject → d.arrow { _1 = c.arrow { _1 = c.identity, _2 = _ }, _2 = f _ }
  , map :
        cObject
      → cObject
      → v.arrow
        { _1 =
            c.arrow { _1 = _@1, _2 = _ }
        , _2 =
            d.arrow { _1 = f _@1, _2 = f _ }
        }
  , op :
        cObject
      → d.arrow
        { _1 =
              Type
            → (   { _1 : cObject, _2 : cObject }
                → c.arrow { _1 = c.op _, _2 = _@2 }
                → d.op { _1 = f _@1._1, _2 = f _@1._2 }
                → _@3
              )
            → _@1
        , _2 =
            f _
        }
  }
</pre></dd>
</dl>
<h4>extractFunctor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(v : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      , identity :
          cObject
      , op :
          { _1 : cObject, _2 : cObject } → cObject
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀(f : cObject → Type)
→ ∀ ( monoidal
    : { identity :
            cObject
          → d.arrow { _1 = c.arrow { _1 = c.identity, _2 = _ }, _2 = f _ }
      , map :
            cObject
          → cObject
          → v.arrow
            { _1 =
                c.arrow { _1 = _@1, _2 = _ }
            , _2 =
                d.arrow { _1 = f _@1, _2 = f _ }
            }
      , op :
            cObject
          → d.arrow
            { _1 =
                  Type
                → (   { _1 : cObject, _2 : cObject }
                    → c.arrow { _1 = c.op _, _2 = _@2 }
                    → d.op { _1 = f _@1._1, _2 = f _@1._2 }
                    → _@3
                  )
                → _@1
            , _2 =
                f _
            }
      }
    )
→ { map :
        cObject
      → cObject
      → v.arrow
        { _1 =
            c.arrow { _1 = _@1, _2 = _ }
        , _2 =
            d.arrow { _1 = f _@1, _2 = f _ }
        }
  }
</pre></dd>
</dl>
<h4>extractMonoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(v : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      , identity :
          cObject
      , op :
          { _1 : cObject, _2 : cObject } → cObject
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀(f : cObject → Type)
→ ∀ ( monoidal
    : { identity :
            cObject
          → d.arrow { _1 = c.arrow { _1 = c.identity, _2 = _ }, _2 = f _ }
      , map :
            cObject
          → cObject
          → v.arrow
            { _1 =
                c.arrow { _1 = _@1, _2 = _ }
            , _2 =
                d.arrow { _1 = f _@1, _2 = f _ }
            }
      , op :
            cObject
          → d.arrow
            { _1 =
                  Type
                → (   { _1 : cObject, _2 : cObject }
                    → c.arrow { _1 = c.op _, _2 = _@2 }
                    → d.op { _1 = f _@1._1, _2 = f _@1._2 }
                    → _@3
                  )
                → _@1
            , _2 =
                f _
            }
      }
    )
→ { identity :
      cObject → d.arrow { _1 = c.arrow { _1 = c.identity, _2 = _ }, _2 = f _ }
  , op :
        cObject
      → d.arrow
        { _1 =
              Type
            → (   { _1 : cObject, _2 : cObject }
                → c.arrow { _1 = c.op _, _2 = _@2 }
                → d.op { _1 = f _@1._1, _2 = f _@1._2 }
                → _@3
              )
            → _@1
        , _2 =
            f _
        }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Functor/Pair</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      , identity :
          vObject
      , op :
          { _1 : vObject, _2 : vObject } → vObject
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → vObject
      , constraint :
          object → Type
      }
    )
→ ({ _1 : object, _2 : object } → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(vObject : Kind)
→ λ(object : Kind)
→ λ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      , identity :
          vObject
      , op :
          { _1 : vObject, _2 : vObject } → vObject
      }
    )
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → vObject
      , constraint :
          object → Type
      }
    )
→ λ(_ : { _1 : object, _2 : object } → object)
→ { map :
        { _1 : object, _2 : object }
      → { _1 : object, _2 : object }
      → v.arrow
        { _1 =
            v.op
            { _1 =
                cat.arrow { _1 = _@1._1, _2 = _._1 }
            , _2 =
                cat.arrow { _1 = _@1._2, _2 = _._2 }
            }
        , _2 =
            cat.arrow { _1 = _@2 _@1, _2 = _@2 _ }
        }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Functor/Profunctor</h3>
<h4>Type (type)</h4>
<p>{- A profunctor `C ↛ D` is represented as the bifunctor `(D^op, C) → Set`. This
   is much more general than Haskell’s `Profunctor`. See `Hom` and `InternalHom`
   for that.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ ({ _1 : dObject, _2 : cObject } → Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ λ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ λ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ λ(_ : { _1 : dObject, _2 : cObject } → Type)
→ { map :
        { _1 : dObject, _2 : cObject }
      → { _1 : dObject, _2 : cObject }
      → v.arrow
        { _1 =
            v.op
            { _1 =
                d.arrow { _1 = _._1, _2 = _@1._1 }
            , _2 =
                c.arrow { _1 = _@1._2, _2 = _._2 }
            }
        , _2 =
            v.arrow { _1 = _@2 _@1, _2 = _@2 _ }
        }
  }
</pre></dd>
</dl>
<h4>SetValued (type)</h4>
<p>{- A functor to *Set* from some other category.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(v : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ (object → Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(v : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ λ(_ : object → Type)
→ { map :
        object
      → object
      → v.arrow { _1 = cat.arrow { _1 = _@1, _2 = _ }, _2 = _@2 _@1 → _@3 _@1 }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Functor/Star</h3>
<h4>Type (type)</h4>
<p>{- A functor from a Kleisli category to the underlying non-Kleisli category.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → vObject
      , constraint :
          object → Type
      }
    )
→ ∀(m : object → object)
→ (object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(vObject : Kind)
→ λ(object : Kind)
→ λ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      }
    )
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → vObject
      , constraint :
          object → Type
      }
    )
→ λ(m : object → object)
→ λ(_ : object → object)
→ { map :
        object
      → object
      → v.arrow
        { _1 =
            cat.arrow { _1 = _@1, _2 = m _ }
        , _2 =
            cat.arrow { _1 = _@2 _@1, _2 = _@2 _ }
        }
  }
</pre></dd>
</dl>
<h4>functor (term)</h4>
<p>{- If there is a natural transformation from `n` to `m`, then a m-Star functor
   can be made into an n-Star functor.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ∀ ( category
    : { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀(f : object → object)
→ { map :
        ∀(m : object → object)
      → ∀(n : object → object)
      → ∀(natural : object → cat.arrow { _1 = n _, _2 = m _ })
      → ∀ ( star
          : { map :
                  object
                → object
                → cat.arrow { _1 = _@1, _2 = m _ }
                → cat.arrow { _1 = f _@2, _2 = f _@1 }
            }
          )
      → { map :
              ∀(a : object)
            → ∀(b : object)
            → ∀(fn : cat.arrow { _1 = a, _2 = n b })
            → cat.arrow { _1 = f a, _2 = f b }
        }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      }
    )
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → vObject
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → vObject
      , constraint :
          dObject → Type
      }
    )
→ ∀(f : cObject → dObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(vObject : Kind)
→ λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      }
    )
→ λ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → vObject
      , constraint :
          cObject → Type
      }
    )
→ λ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → vObject
      , constraint :
          dObject → Type
      }
    )
→ λ(f : cObject → dObject)
→ { map :
        ∀(a : cObject)
      → ∀(b : cObject)
      → v.arrow
        { _1 = c.arrow { _1 = a, _2 = b }, _2 = d.arrow { _1 = f a, _2 = f b } }
  }
</pre></dd>
</dl>
<h4>laws (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( cCategory
    : { identity :
          cObject → c.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : cObject, _2 : cObject }
          → (   Type
              → (   cObject
                  → c.arrow { _1 = _, _2 = _@2._2 }
                  → c.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → c.arrow _@1
      }
    )
→ ∀(f : cObject → Type)
→ ∀ ( functor
    : { map : cObject → cObject → c.arrow { _1 = _@1, _2 = _ } → f _@2 → f _@2 }
    )
→ { composition :
        ∀(a : cObject)
      → ∀(b : cObject)
      → ∀(e : cObject)
      → ∀(eq : { eq : f e → f e → Bool })
      → ∀(fn : c.arrow { _1 = b, _2 = e })
      → ∀(gn : c.arrow { _1 = a, _2 = b })
      → f a
      → Bool
  , identity :
      ∀(a : cObject) → ∀(eq : { eq : f a → f a → Bool }) → f a → Bool
  }
</pre></dd>
</dl>
<h4>opposite (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      }
    )
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → vObject
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → vObject
      , constraint :
          dObject → Type
      }
    )
→ ∀(f : cObject → dObject)
→ ∀ ( functor
    : { map :
            cObject
          → cObject
          → v.arrow
            { _1 =
                c.arrow { _1 = _@1, _2 = _ }
            , _2 =
                d.arrow { _1 = f _@1, _2 = f _ }
            }
      }
    )
→ { map :
        ∀(a : cObject)
      → ∀(b : cObject)
      → v.arrow
        { _1 = c.arrow { _1 = b, _2 = a }, _2 = d.arrow { _1 = f b, _2 = f a } }
  }
</pre></dd>
</dl>
<h4>void (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(dObject : Kind)
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ ∀(f : Type → dObject)
→ ∀ ( functor
    : { map : Type → Type → (_@1 → _@1) → d.arrow { _1 = f _@2, _2 = f _@1 } }
    )
→ ∀(a : Type)
→ d.arrow { _1 = f a, _2 = f {} }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Group</h2>
<h3 style="background-color: #bbb; width: 100%">./Group/Commutative</h3>
<h4>Kind (kind)</h4>
<p>{- A commutative monoid implies a preorder. However, that currently forces us
   into *Set*, so we instead just alias the non-commutative type to avoid specializing.
-}</p>
<dl>
<dt>sort</dt><dd><pre>
(Kind → Kind → Kind) → (Kind → Kind → Kind) → Kind → Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(_ : Kind → Kind → Kind)
→ λ(_ : Kind → Kind → Kind)
→ λ(_ : Kind)
→ { identity : _, inverse : _@2 _ _, op : _@2 (_@1 _ _) _ }
</pre></dd>
</dl>
<h4>Set (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { identity :
      {} → m
  , inverse :
      m → m
  , op :
      { _1 : m, _2 : m } → m
  , preLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p>{- A commutative monoid implies a preorder. However, that currently forces us
   into *Set*, so we instead just alias the non-commutative type to avoid specializing.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  Kind
→ { arrow :
      { _1 : _, _2 : _ } → Type
  , constraint :
      _ → Type
  , identity :
      _
  , op :
      { _1 : _, _2 : _ } → _@1
  }
→ _@1
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(_ : Kind)
→ λ ( _
    : { arrow :
          { _1 : _, _2 : _ } → Type
      , constraint :
          _ → Type
      , identity :
          _
      , op :
          { _1 : _, _2 : _ } → _@1
      }
    )
→ λ(_ : _@1)
→ { identity :
      _@1.arrow { _1 = _@1.identity, _2 = _ }
  , inverse :
      _@1.arrow { _1 = _, _2 = _ }
  , op :
      _@1.arrow { _1 = _@1.op { _1 = _, _2 = _ }, _2 = _ }
  }
</pre></dd>
</dl>
<h4>extractCommutativeMonoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ ∀ ( group
    : { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , inverse :
          cat.arrow { _1 = m, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
    )
→ { identity :
      cat.arrow { _1 = cat.identity, _2 = m }
  , op :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  }
</pre></dd>
</dl>
<h4>extractGroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ ∀ ( group
    : { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , inverse :
          cat.arrow { _1 = m, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
    )
→ { identity :
      cat.arrow { _1 = cat.identity, _2 = m }
  , inverse :
      cat.arrow { _1 = m, _2 = m }
  , op :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  }
</pre></dd>
</dl>
<h4>extractMonoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ ∀ ( group
    : { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , inverse :
          cat.arrow { _1 = m, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
    )
→ { identity :
      cat.arrow { _1 = cat.identity, _2 = m }
  , op :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  }
</pre></dd>
</dl>
<h4>quotient (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀ ( category
    : { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀ ( bifunctor
    : { map :
            { _1 : object, _2 : object }
          → { _1 : object, _2 : object }
          → { _1 :
                cat.arrow { _1 = _@1._1, _2 = _._1 }
            , _2 :
                cat.arrow { _1 = _@1._2, _2 = _._2 }
            }
          → cat.arrow { _1 = cat.op _@2, _2 = cat.op _@1 }
      }
    )
→ ∀(m : object)
→ ∀ ( group
    : { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , inverse :
          cat.arrow { _1 = m, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
    )
→ cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
</pre></dd>
</dl>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(m : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(m : Kind)
→ { identity : m, inverse : kArrow m m, op : kArrow (kProduct m m) m }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Group/Ordered</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { eq :
      m → m → Bool
  , identity :
      {} → m
  , inverse :
      m → m
  , le :
      m → m → Bool
  , op :
      { _1 : m, _2 : m } → m
  , partialLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h4>extractPartiallyOrderedGroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( group
    : { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , le :
          m → m → Bool
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      }
    )
→ { eq :
      m → m → Bool
  , identity :
      {} → m
  , inverse :
      m → m
  , op :
      { _1 : m, _2 : m } → m
  , partialLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Group/OrderedCommutative</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { eq :
      m → m → Bool
  , identity :
      {} → m
  , inverse :
      m → m
  , le :
      m → m → Bool
  , op :
      { _1 : m, _2 : m } → m
  , partialLE :
      m → m → Optional Bool
  , preLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h4>extractPartiallyOrderedCommutativeGroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( group
    : { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , le :
          m → m → Bool
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      , preLE :
          m → m → Optional Bool
      }
    )
→ { eq :
      m → m → Bool
  , identity :
      {} → m
  , inverse :
      m → m
  , op :
      { _1 : m, _2 : m } → m
  , partialLE :
      m → m → Optional Bool
  , preLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Group/PartiallyOrdered</h3>
<h4>Type (type)</h4>
<p>{- This is the weakest form of order provided. There is no standalone preorder,
   partial order, or anything, because there are too many possible
   instances. For the general case, just define regular functions. A
   `Group/PartiallyOrdered` constrains the instances enough for a generic “less
   than” to be meaningful.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { eq :
      m → m → Bool
  , identity :
      {} → m
  , inverse :
      m → m
  , op :
      { _1 : m, _2 : m } → m
  , partialLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h4>extractEq (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( group
    : { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      }
    )
→ { eq : m → m → Bool }
</pre></dd>
</dl>
<h4>extractGroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( group
    : { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      }
    )
→ { identity : {} → m, inverse : m → m, op : { _1 : m, _2 : m } → m }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Group/PartiallyOrderedCommutative</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { eq :
      m → m → Bool
  , identity :
      {} → m
  , inverse :
      m → m
  , op :
      { _1 : m, _2 : m } → m
  , partialLE :
      m → m → Optional Bool
  , preLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h4>extractCommutativeGroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( group
    : { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      , preLE :
          m → m → Optional Bool
      }
    )
→ { identity : {} → m, inverse : m → m, op : { _1 : m, _2 : m } → m }
</pre></dd>
</dl>
<h4>extractSetCommutativeGroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( group
    : { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      , preLE :
          m → m → Optional Bool
      }
    )
→ { identity :
      {} → m
  , inverse :
      m → m
  , op :
      { _1 : m, _2 : m } → m
  , preLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { identity :
      cat.arrow { _1 = cat.identity, _2 = m }
  , inverse :
      cat.arrow { _1 = m, _2 = m }
  , op :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  }
</pre></dd>
</dl>
<h4>extractMonoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ ∀ ( group
    : { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , inverse :
          cat.arrow { _1 = m, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
    )
→ { identity :
      cat.arrow { _1 = cat.identity, _2 = m }
  , op :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  }
</pre></dd>
</dl>
<h4>leftQuotient (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀ ( category
    : { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀ ( bifunctor
    : { map :
            { _1 : object, _2 : object }
          → { _1 : object, _2 : object }
          → { _1 :
                cat.arrow { _1 = _@1._1, _2 = _._1 }
            , _2 :
                cat.arrow { _1 = _@1._2, _2 = _._2 }
            }
          → cat.arrow { _1 = cat.op _@2, _2 = cat.op _@1 }
      }
    )
→ ∀(m : object)
→ ∀ ( group
    : { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , inverse :
          cat.arrow { _1 = m, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
    )
→ cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
</pre></dd>
</dl>
<h4>rightQuotient (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀ ( category
    : { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀ ( bifunctor
    : { map :
            { _1 : object, _2 : object }
          → { _1 : object, _2 : object }
          → { _1 :
                cat.arrow { _1 = _@1._1, _2 = _._1 }
            , _2 :
                cat.arrow { _1 = _@1._2, _2 = _._2 }
            }
          → cat.arrow { _1 = cat.op _@2, _2 = cat.op _@1 }
      }
    )
→ ∀(m : object)
→ ∀ ( group
    : { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , inverse :
          cat.arrow { _1 = m, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
    )
→ cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀ ( category
    : { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀ ( bifunctor
    : { map :
            { _1 : object, _2 : object }
          → { _1 : object, _2 : object }
          → { _1 :
                cat.arrow { _1 = _@1._1, _2 = _._1 }
            , _2 :
                cat.arrow { _1 = _@1._2, _2 = _._2 }
            }
          → cat.arrow { _1 = cat.op _@2, _2 = cat.op _@1 }
      }
    )
→ ∀(m : object)
→ ∀ ( group
    : { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , inverse :
          cat.arrow { _1 = m, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
    )
→ { identity :
      cat.arrow { _1 = cat.identity, _2 = m }
  , inverse :
      cat.arrow { _1 = m, _2 = m }
  , leftQuotient :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  , op :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  , rightQuotient :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Groupoid</h2>
<h4>Type (type)</h4>
<p>{- TODO: This would be `./../Group/Type … (./../Category/Monoidal/Profunctor
         object morphism)`, but `Category` isn’t defined via `Monoid`, so we
		 prefer compatibility with that.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ∀(morphism : { _1 : object, _2 : object } → Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ λ(morphism : { _1 : object, _2 : object } → Type)
→ { identity :
      object → cat.arrow { _1 = _, _2 = _ }
  , inverse :
      ∀(a : { _1 : object, _2 : object }) → morphism a → morphism a
  , op :
        { _1 : object, _2 : object }
      → (   Type
          → (   object
              → cat.arrow { _1 = _, _2 = _@2._2 }
              → cat.arrow { _1 = _@3._1, _2 = _@1 }
              → _@3
            )
          → _@1
        )
      → cat.arrow _@1
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Identity</h2>
<h4>Type (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
∀(object : Kind) → ∀(a : object) → object
</pre></dd>
</dl>
<h4>adjunction (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ counit :
    ∀(a : Type) → ∀(x : a) → a
, leftAdjunct :
    ∀(a : Type) → ∀(b : Type) → ∀(f : a → b) → a → b
, rightAdjunct :
    ∀(a : Type) → ∀(b : Type) → ∀(f : a → b) → a → b
, unit :
    ∀(a : Type) → ∀(x : a) → a
}
</pre></dd>
</dl>
<h4>bimonad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ∀ ( category
    : { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ { comonoid :
      { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
          object → cat.arrow { _1 = _, _2 = _ }
      }
  , monoid :
      { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
          object → cat.arrow { _1 = _, _2 = _ }
      }
  }
</pre></dd>
</dl>
<h4>comonad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ∀ ( category
    : { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ { identity :
      object → cat.arrow { _1 = _, _2 = _ }
  , op :
      object → cat.arrow { _1 = _, _2 = _ }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Identity/functor</h3>
<h4>endo (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } → Type
      , constraint :
          vObject → Type
      }
    )
→ ∀ ( vCategory
    : { identity :
          vObject → v.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : vObject, _2 : vObject }
          → (   Type
              → (   vObject
                  → v.arrow { _1 = _, _2 = _@2._2 }
                  → v.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → v.arrow _@1
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → vObject
      , constraint :
          object → Type
      }
    )
→ { map :
        ∀(a : object)
      → ∀(b : object)
      → v.arrow
        { _1 = cat.arrow { _1 = a, _2 = b }, _2 = cat.arrow { _1 = a, _2 = b } }
  }
</pre></dd>
</dl>
<h4>monoidal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    Type → ({} → _@1) → _@1
, map :
    Type → Type → (_@1 → _@1) → _@2 → _@2
, op :
      Type
    → (   Type
        → (   { _1 : Type, _2 : Type }
            → ({ _1 : _._1, _2 : _._2 } → _@3)
            → { _1 : _@1._1, _2 : _@1._2 }
            → _@3
          )
        → _@1
      )
    → _@1
}
</pre></dd>
</dl>
<h4>monad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ∀ ( category
    : { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ { identity :
      object → cat.arrow { _1 = _, _2 = _ }
  , op :
      object → cat.arrow { _1 = _, _2 = _ }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Isomorphism</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
∀(kArrow : Kind → Kind → Kind) → ∀(a : Kind) → ∀(b : Kind) → Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(a : Kind)
→ λ(b : Kind)
→ { from : kArrow b a, to : kArrow a b }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀(arrow : { _1 : object, _2 : object } → Type)
→ ∀(a : { _1 : object, _2 : object })
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ(arrow : { _1 : object, _2 : object } → Type)
→ λ(a : { _1 : object, _2 : object })
→ { from : arrow { _1 = a._2, _2 = a._1 }, to : arrow a }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Lan</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cpObject : Kind)
→ ∀ ( cp
    : { arrow :
          { _1 : cpObject, _2 : cpObject } → Type
      , constraint :
          cpObject → Type
      }
    )
→ ∀(p : cObject → cpObject)
→ ∀(f : cObject → Type)
→ ∀(a : cpObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(cpObject : Kind)
→ λ ( cp
    : { arrow :
          { _1 : cpObject, _2 : cpObject } → Type
      , constraint :
          cpObject → Type
      }
    )
→ λ(p : cObject → cpObject)
→ λ(f : cObject → Type)
→ λ(a : cpObject)
→ ∀(r : Type) → (∀(b : cObject) → cp.arrow { _1 = p b, _2 = a } → f b → r) → r
</pre></dd>
</dl>
<h4>functor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cpObject : Kind)
→ ∀ ( cp
    : { arrow :
          { _1 : cpObject, _2 : cpObject } → Type
      , constraint :
          cpObject → Type
      }
    )
→ ∀ ( cpSemigroupoid
    : { op :
            { _1 : cpObject, _2 : cpObject }
          → (   Type
              → (   cpObject
                  → cp.arrow { _1 = _, _2 = _@2._2 }
                  → cp.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cp.arrow _@1
      }
    )
→ ∀(f : cObject → cpObject)
→ ∀(g : cObject → Type)
→ { map :
        ∀(a : cpObject)
      → ∀(b : cpObject)
      → ∀(h : cp.arrow { _1 = a, _2 = b })
      → ∀ ( lan
          : Type → (cObject → cp.arrow { _1 = f _, _2 = a } → g _@1 → _@3) → _@1
          )
      → ∀(r : Type)
      → ∀(k : ∀(c : cObject) → cp.arrow { _1 = f c, _2 = b } → g c → r)
      → r
  }
</pre></dd>
</dl>
<h4>lift (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀(cat : { arrow : { _1 : Type, _2 : Type } → Type, constraint : Type → Type })
→ ∀ ( semigroupoid
    : { op :
            { _1 : Type, _2 : Type }
          → (   Type
              → (   Type
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀(f : Type → Type)
→ ∀ ( comonad
    : { identity :
          Type → cat.arrow { _1 = f _, _2 = _ }
      , op :
          Type → cat.arrow { _1 = f _, _2 = f (f _) }
      }
    )
→ ∀(g : Type → Type)
→ ∀(a : Type)
→ ∀(x : g a)
→ ∀(r : Type)
→ ∀(k : ∀(b : Type) → cat.arrow { _1 = f b, _2 = a } → g b → r)
→ r
</pre></dd>
</dl>
<h4>lower (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cpObject : Kind)
→ ∀ ( cp
    : { arrow :
          { _1 : cpObject, _2 : cpObject } → Type
      , constraint :
          cpObject → Type
      }
    )
→ ∀(h : cpObject → Type)
→ ∀ ( functor
    : { map :
          cpObject → cpObject → cp.arrow { _1 = _@1, _2 = _ } → h _@2 → h _@2
      }
    )
→ ∀(f : cObject → cpObject)
→ ∀(g : cObject → Type)
→ ∀(duplicate : ∀(b : cObject) → g b → h (f b))
→ ∀(a : cpObject)
→ ∀(lan : Type → (cObject → cp.arrow { _1 = f _, _2 = a } → g _@1 → _@3) → _@1)
→ h a
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Lattice</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { join :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  , meet :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>extractJoin (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ ∀ ( lattice
    : { join :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      , meet :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      }
    )
→ { identity :
      cat.arrow { _1 = cat.identity, _2 = m }
  , op :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  }
</pre></dd>
</dl>
<h4>extractMeet (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ ∀ ( lattice
    : { join :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      , meet :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      }
    )
→ { identity :
      cat.arrow { _1 = cat.identity, _2 = m }
  , op :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Leibniz</h2>
<h4>Kind (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ { arrow :
      ∀(a : { _1 : cObject, _2 : cObject }) → Type
  , constraint :
      cObject → Type
  }
</pre></dd>
</dl>
<h4>category (term)</h4>
<p>{- In a Leibniz category, identity is refl, and op is transitivity. -}</p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ ∀ ( dCategory
    : { identity :
          dObject → d.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : dObject, _2 : dObject }
          → (   Type
              → (   dObject
                  → d.arrow { _1 = _, _2 = _@2._2 }
                  → d.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → d.arrow _@1
      }
    )
→ { identity :
        ∀(a : cObject)
      → { subst : ∀(f : cObject → dObject) → d.arrow { _1 = f a, _2 = f a } }
  , op :
        ∀(a : { _1 : cObject, _2 : cObject })
      → ∀ ( p
          :   ∀(r : Type)
            → (   ∀(z : cObject)
                → { subst :
                      (cObject → dObject) → d.arrow { _1 = _ z, _2 = _ a._2 }
                  }
                → { subst :
                      (cObject → dObject) → d.arrow { _1 = _ a._1, _2 = _ z }
                  }
                → r
              )
            → r
          )
      → { subst :
            ∀(f : cObject → dObject) → d.arrow { _1 = f a._1, _2 = f a._2 }
        }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./List</h2>
<h3 style="background-color: #bbb; width: 100%">./List/functor</h3>
<h4>compactable (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ map :
    ∀(a : Type) → ∀(b : Type) → ∀(f : a → Optional b) → ∀(l : List a) → List b
}
</pre></dd>
</dl>
<h4 style="background-color: #bbb; width: 100%">./List/functor/endo</h4>
<h4>star (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀ ( monoidal
    : { identity :
          Type → ({} → _@1) → m _@1
      , map :
          Type → Type → (_@1 → _@1) → m _@2 → m _@2
      , op :
            Type
          → (   Type
              → (   { _1 : Type, _2 : Type }
                  → ({ _1 : _._1, _2 : _._2 } → _@3)
                  → { _1 : m _@1._1, _2 : m _@1._2 }
                  → _@3
                )
              → _@1
            )
          → m _@1
      }
    )
→ { map :
      ∀(a : Type) → ∀(b : Type) → ∀(f : a → m b) → ∀(fa : List a) → m (List b)
  }
</pre></dd>
</dl>
<h4>monoidal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    Type → ({} → _@1) → List _@1
, map :
    Type → Type → (_@1 → _@1) → List _@2 → List _@2
, op :
      Type
    → (   Type
        → (   { _1 : Type, _2 : Type }
            → ({ _1 : _._1, _2 : _._2 } → _@3)
            → { _1 : List _@1._1, _2 : List _@1._2 }
            → _@3
          )
        → _@1
      )
    → List _@1
}
</pre></dd>
</dl>
<h4>monad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    ∀(a : Type) → ∀(x : a) → List a
, op :
    ∀(a : Type) → ∀(mma : List (List a)) → List a
}
</pre></dd>
</dl>
<h4>monoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ { identity : {} → List a, op : ∀(x : { _1 : List a, _2 : List a }) → List a }
</pre></dd>
</dl>
<h4>semigroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
∀(a : Type) → { op : { _1 : List a, _2 : List a } → List a }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Loop</h2>
<h4>Kind (kind)</h4>
<p>{- NB: `identity` would ideally be defined with `: kArrow kIdentity m`, but
       there’s no Kind-level `{}` to use there.
-}</p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(m : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(m : Kind)
→ { identity : m, inverse : kArrow m m, op : kArrow (kProduct m m) m }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { identity :
      cat.arrow { _1 = cat.identity, _2 = m }
  , inverse :
      cat.arrow { _1 = m, _2 = m }
  , op :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Magma</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(m : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(m : Kind)
→ { op : kArrow (kProduct m m) m }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { op : cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m } }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Monad</h2>
<h4>Type (type)</h4>
<p>{- A monad on a category C{object, arrow} is a monoid object in the category of
   endofunctors in C induced by composition.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ (object → object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ λ(_ : object → object)
→ { identity :
      object → cat.arrow { _1 = _, _2 = _@1 _ }
  , op :
      object → cat.arrow { _1 = _@1 (_@1 _), _2 = _@1 _ }
  }
</pre></dd>
</dl>
<h4>impliedMonoidalFunctor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(f : Type → Type)
→ ∀(functor : { map : Type → Type → (_@1 → _@1) → f _@2 → f _@2 })
→ ∀(monad : { identity : Type → _ → f _@1, op : Type → f (f _) → f _@1 })
→ { identity :
      ∀(a : Type) → ∀(fn : {} → a) → f a
  , map :
      Type → Type → (_@1 → _@1) → f _@2 → f _@2
  , op :
        ∀(i : Type)
      → ∀ ( day
          :   ∀(r : Type)
            → (   { _1 : Type, _2 : Type }
                → ({ _1 : _._1, _2 : _._2 } → i)
                → { _1 : f _@1._1, _2 : f _@1._2 }
                → r
              )
            → r
          )
      → f i
  }
</pre></dd>
</dl>
<h4>impliedStarfunctor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ∀ ( semigroupoid
    : { op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀(m : object → object)
→ ∀ ( functor
    : { map :
            object
          → object
          → cat.arrow { _1 = _@1, _2 = _ }
          → cat.arrow { _1 = m _@2, _2 = m _@1 }
      }
    )
→ ∀ ( monad
    : { identity :
          object → cat.arrow { _1 = _, _2 = m _ }
      , op :
          object → cat.arrow { _1 = m (m _), _2 = m _ }
      }
    )
→ { map :
        ∀(a : object)
      → ∀(b : object)
      → ∀(f : cat.arrow { _1 = a, _2 = m b })
      → cat.arrow { _1 = m a, _2 = m b }
  }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ∀ ( semigroupoid
    : { op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀(m : object → object)
→ ∀ ( functor
    : { map :
            object
          → object
          → cat.arrow { _1 = _@1, _2 = _ }
          → cat.arrow { _1 = m _@2, _2 = m _@1 }
      }
    )
→ ∀ ( monad
    : { identity :
          object → cat.arrow { _1 = _, _2 = m _ }
      , op :
          object → cat.arrow { _1 = m (m _), _2 = m _ }
      }
    )
→ { bind :
        object
      → object
      → cat.arrow { _1 = _@1, _2 = m _ }
      → cat.arrow { _1 = m _@2, _2 = m _@1 }
  , extractStarfunctor :
      { map :
            object
          → object
          → cat.arrow { _1 = _@1, _2 = m _ }
          → cat.arrow { _1 = m _@2, _2 = m _@1 }
      }
  , join :
      object → cat.arrow { _1 = m (m _), _2 = m _ }
  , map :
        object
      → object
      → cat.arrow { _1 = _@1, _2 = _ }
      → cat.arrow { _1 = m _@2, _2 = m _@1 }
  , pure :
      object → cat.arrow { _1 = _, _2 = m _ }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Monoid</h2>
<h3 style="background-color: #bbb; width: 100%">./Monoid/Commutative</h3>
<h4>Kind (kind)</h4>
<p>{- A commutative monoid implies a preorder. However, that currently forces us
   into *Set*, so we instead just alias the non-commutative type to avoid
   specializing.
-}</p>
<dl>
<dt>sort</dt><dd><pre>
(Kind → Kind → Kind) → (Kind → Kind → Kind) → Kind → Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(_ : Kind → Kind → Kind)
→ λ(_ : Kind → Kind → Kind)
→ λ(_ : Kind)
→ { identity : _, op : _@2 (_@1 _ _) _ }
</pre></dd>
</dl>
<h4>Set (type)</h4>
<p>{- A commutative monoid implies a preorder. Technically, a preorder could be
   defined with `≤` where both `x ≤ y` and `y ≤ x` may be false. However, with
   structural typing it makes it impossible to distinguish a preordered
   structure from a totally-ordered structure.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { identity :
      {} → m
  , op :
      { _1 : m, _2 : m } → m
  , preLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p>{- A commutative monoid implies a preorder. However, that currently forces us
   into *Set*, so we instead just alias the non-commutative type to avoid specializing.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  Kind
→ { arrow :
      { _1 : _, _2 : _ } → Type
  , constraint :
      _ → Type
  , identity :
      _
  , op :
      { _1 : _, _2 : _ } → _@1
  }
→ _@1
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(_ : Kind)
→ λ ( _
    : { arrow :
          { _1 : _, _2 : _ } → Type
      , constraint :
          _ → Type
      , identity :
          _
      , op :
          { _1 : _, _2 : _ } → _@1
      }
    )
→ λ(_ : _@1)
→ { identity :
      _@1.arrow { _1 = _@1.identity, _2 = _ }
  , op :
      _@1.arrow { _1 = _@1.op { _1 = _, _2 = _ }, _2 = _ }
  }
</pre></dd>
</dl>
<h4>extractMonoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( monoid
    : { identity :
          {} → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
    )
→ { identity : {} → m, op : { _1 : m, _2 : m } → m }
</pre></dd>
</dl>
<h4>extractSemigroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ ∀ ( monoid
    : { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
    )
→ { op : cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m } }
</pre></dd>
</dl>
<h4>Kind (kind)</h4>
<p>{- NB: `identity` would ideally be defined with `: kArrow kIdentity m`, but
       there’s no Kind-level `{}` to use there.
-}</p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(m : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(m : Kind)
→ { identity : m, op : kArrow (kProduct m m) m }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { identity :
      cat.arrow { _1 = cat.identity, _2 = m }
  , op :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  }
</pre></dd>
</dl>
<h4>extractSemigroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ ∀ ( monoid
    : { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
    )
→ { op : cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m } }
</pre></dd>
</dl>
<h4>laws (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀(eq : { eq : m → m → Bool })
→ ∀(monoid : { identity : {} → m, op : { _1 : m, _2 : m } → m })
→ { associativity :
      m → m → m → Bool
  , leftIdentity :
      ∀(a : m) → Bool
  , rightIdentity :
      ∀(a : m) → Bool
  }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ ∀ ( monoid
    : { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
    )
→ { identity :
      cat.arrow { _1 = cat.identity, _2 = m }
  , op :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Natural</h2>
<h4>duoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(max : { _1 : Natural, _2 : Natural } → Natural)
→ { additive :
      { identity : {} → Natural, op : { _1 : Natural, _2 : Natural } → Natural }
  , multiplicative :
      { identity : {} → Natural, op : { _1 : Natural, _2 : Natural } → Natural }
  }
</pre></dd>
</dl>
<h4>monoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    {} → Natural
, op :
    ∀(t : { _1 : Natural, _2 : Natural }) → Natural
}
</pre></dd>
</dl>
<h4>rig (term)</h4>
<p>{- TODO: Should be a Rig/Commutative -}</p>
<dl>
<dt>type</dt><dd><pre>
{ additive :
    { identity :
        {} → Natural
    , op :
        ∀(t : { _1 : Natural, _2 : Natural }) → Natural
    }
, multiplicative :
    { identity :
        {} → Natural
    , op :
        ∀(t : { _1 : Natural, _2 : Natural }) → Natural
    }
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./NaturalTransformation</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
∀(f : Kind → Kind) → ∀(g : Kind → Kind) → ∀(a : Kind) → Kind
</pre></dd>
<dt>kind</dt><dd><pre>
λ(f : Kind → Kind) → λ(g : Kind → Kind) → λ(a : Kind) → f a → g a
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ ∀(f : { _1 : cObject → dObject, _2 : cObject → dObject })
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ λ(f : { _1 : cObject → dObject, _2 : cObject → dObject })
→ ∀(a : cObject) → d.arrow { _1 = f._1 a, _2 = f._2 a }
</pre></dd>
</dl>
<h4>category (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀(cObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀(dObject : Kind)
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ ∀ ( dCategory
    : { identity :
          dObject → d.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : dObject, _2 : dObject }
          → (   Type
              → (   dObject
                  → d.arrow { _1 = _, _2 = _@2._2 }
                  → d.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → d.arrow _@1
      }
    )
→ { identity :
      ∀(a : cObject → dObject) → ∀(i : cObject) → d.arrow { _1 = a i, _2 = a i }
  , op :
        ∀(a : { _1 : cObject → dObject, _2 : cObject → dObject })
      → ∀ ( p
          :   ∀(r : Type)
            → (   ∀(z : cObject → dObject)
                → (cObject → d.arrow { _1 = z _, _2 = a._2 _ })
                → (cObject → d.arrow { _1 = a._1 _, _2 = z _ })
                → r
              )
            → r
          )
      → ∀(i : cObject)
      → d.arrow { _1 = a._1 i, _2 = a._2 i }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Optional</h2>
<h4>eq (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ ∀(eq : { eq : a → a → Bool })
→ { eq : ∀(x : Optional a) → ∀(y : Optional a) → Bool }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Optional/functor</h3>
<h4>compactable (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ map : Type → Type → (_@1 → Optional _@1) → Optional _@2 → Optional _@2 }
</pre></dd>
</dl>
<h4 style="background-color: #bbb; width: 100%">./Optional/functor/endo</h4>
<h4>star (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀ ( monoidal
    : { identity :
          Type → ({} → _@1) → m _@1
      , map :
          Type → Type → (_@1 → _@1) → m _@2 → m _@2
      , op :
            Type
          → (   Type
              → (   { _1 : Type, _2 : Type }
                  → ({ _1 : _._1, _2 : _._2 } → _@3)
                  → { _1 : m _@1._1, _2 : m _@1._2 }
                  → _@3
                )
              → _@1
            )
          → m _@1
      }
    )
→ { map :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(f : a → m b)
      → ∀(fa : Optional a)
      → m (Optional b)
  }
</pre></dd>
</dl>
<h4>monoidal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    Type → ({} → _@1) → Optional _@1
, map :
    Type → Type → (_@1 → _@1) → Optional _@2 → Optional _@2
, op :
      Type
    → (   Type
        → (   { _1 : Type, _2 : Type }
            → ({ _1 : _._1, _2 : _._2 } → _@3)
            → { _1 : Optional _@1._1, _2 : Optional _@1._2 }
            → _@3
          )
        → _@1
      )
    → Optional _@1
}
</pre></dd>
</dl>
<h4>monad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ identity :
    ∀(a : Type) → ∀(x : a) → Optional a
, op :
    ∀(a : Type) → ∀(mma : Optional (Optional a)) → Optional a
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Quasigroup</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(m : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(m : Kind)
→ { inverse : kArrow m m, op : kArrow (kProduct m m) m }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { inverse :
      cat.arrow { _1 = m, _2 = m }
  , op :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Ran</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cpObject : Kind)
→ ∀ ( cp
    : { arrow :
          { _1 : cpObject, _2 : cpObject } → Type
      , constraint :
          cpObject → Type
      }
    )
→ ∀(p : cObject → cpObject)
→ ∀(f : cObject → Type)
→ ∀(a : cpObject)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(cpObject : Kind)
→ λ ( cp
    : { arrow :
          { _1 : cpObject, _2 : cpObject } → Type
      , constraint :
          cpObject → Type
      }
    )
→ λ(p : cObject → cpObject)
→ λ(f : cObject → Type)
→ λ(a : cpObject)
→ ∀(b : cObject) → cp.arrow { _1 = a, _2 = p b } → f b
</pre></dd>
</dl>
<h4>functor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cpObject : Kind)
→ ∀ ( cp
    : { arrow :
          { _1 : cpObject, _2 : cpObject } → Type
      , constraint :
          cpObject → Type
      }
    )
→ ∀ ( cpSemigroupoid
    : { op :
            { _1 : cpObject, _2 : cpObject }
          → (   Type
              → (   cpObject
                  → cp.arrow { _1 = _, _2 = _@2._2 }
                  → cp.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cp.arrow _@1
      }
    )
→ ∀(p : cObject → cpObject)
→ ∀(f : cObject → Type)
→ { map :
        ∀(a : cpObject)
      → ∀(b : cpObject)
      → ∀(fn : cp.arrow { _1 = a, _2 = b })
      → ∀(ran : cObject → cp.arrow { _1 = a, _2 = p _ } → f _@1)
      → ∀(c : cObject)
      → ∀(k : cp.arrow { _1 = b, _2 = p c })
      → f c
  }
</pre></dd>
</dl>
<h4>lift (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(cpObject : Kind)
→ ∀(dObject : Kind)
→ ∀ ( cp
    : { arrow :
          { _1 : cpObject, _2 : cpObject } → Type
      , constraint :
          cpObject → Type
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ ∀ ( dSemigroupoid
    : { op :
            { _1 : dObject, _2 : dObject }
          → (   Type
              → (   dObject
                  → d.arrow { _1 = _, _2 = _@2._2 }
                  → d.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → d.arrow _@1
      }
    )
→ ∀(h : cpObject → dObject)
→ ∀ ( functor
    : { map :
            cpObject
          → cpObject
          → cp.arrow { _1 = _@1, _2 = _ }
          → d.arrow { _1 = h _@2, _2 = h _@1 }
      }
    )
→ ∀(f : cObject → cpObject)
→ ∀(g : cObject → dObject)
→ ∀(join : ∀(b : cObject) → d.arrow { _1 = h (f b), _2 = g b })
→ ∀(a : cpObject)
→ ∀(b : cObject)
→ ∀(k : cp.arrow { _1 = a, _2 = f b })
→ d.arrow { _1 = h a, _2 = g b }
</pre></dd>
</dl>
<h4>lower (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(p : Type → Type)
→ ∀ ( monoidal
    : { identity :
          Type → ({} → _@1) → p _@1
      , map :
          Type → Type → (_@1 → _@1) → p _@2 → p _@2
      , op :
            Type
          → (   Type
              → (   { _1 : Type, _2 : Type }
                  → ({ _1 : _._1, _2 : _._2 } → _@3)
                  → { _1 : p _@1._1, _2 : p _@1._2 }
                  → _@3
                )
              → _@1
            )
          → p _@1
      }
    )
→ ∀(f : Type → Type)
→ ∀(a : Type)
→ ∀(ran : Type → (a → p _@1) → f _@1)
→ f a
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Rig</h2>
<h4>Kind (kind)</h4>
<p>{- This is what is often called a “semiring”, but here we follow the convention
   described in https://ncatlab.org/nlab/show/rig, reserving “semiring” for a
   rig without multiplicative identity.
-}</p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(m : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(m : Kind)
→ { additive :
      { identity : m, op : kArrow (kProduct m m) m }
  , multiplicative :
      { identity : m, op : kArrow (kProduct m m) m }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Rig/Near</h3>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(m : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(m : Kind)
→ { additive :
      { identity : m, op : kArrow (kProduct m m) m }
  , multiplicative :
      { identity : m, op : kArrow (kProduct m m) m }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { additive :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  , multiplicative :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>Set (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { additive :
      { identity :
          {} → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity : {} → m, op : { _1 : m, _2 : m } → m }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p>{- This is what is often called a “semiring”, but here we follow the convention
   described in https://ncatlab.org/nlab/show/rig, reserving “semiring” for a
   rig without multiplicative identity.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { additive :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  , multiplicative :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>extractSemiring (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ ∀ ( rig
    : { additive :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      , multiplicative :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      }
    )
→ { additive :
      { op : cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m } }
  , multiplicative :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ ∀ ( rig
    : { additive :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      , multiplicative :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      }
    )
→ { add :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  , multiply :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  , one :
      cat.arrow { _1 = cat.identity, _2 = m }
  , zero :
      cat.arrow { _1 = cat.identity, _2 = m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Ring</h2>
<h3 style="background-color: #bbb; width: 100%">./Ring/Commutative</h3>
<h4>Set (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { additive :
      { identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity :
          {} → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { additive :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , inverse :
          cat.arrow { _1 = m, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  , multiplicative :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>extractRing (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( ring
    : { additive :
          { identity :
              {} → m
          , inverse :
              m → m
          , op :
              { _1 : m, _2 : m } → m
          , preLE :
              m → m → Optional Bool
          }
      , multiplicative :
          { identity :
              {} → m
          , op :
              { _1 : m, _2 : m } → m
          , preLE :
              m → m → Optional Bool
          }
      }
    )
→ { additive :
      { identity : {} → m, inverse : m → m, op : { _1 : m, _2 : m } → m }
  , multiplicative :
      { identity : {} → m, op : { _1 : m, _2 : m } → m }
  }
</pre></dd>
</dl>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(m : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(m : Kind)
→ { additive :
      { identity : m, inverse : kArrow m m, op : kArrow (kProduct m m) m }
  , multiplicative :
      { identity : m, op : kArrow (kProduct m m) m }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Ring/Near</h3>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(m : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(m : Kind)
→ { additive :
      { identity : m, inverse : kArrow m m, op : kArrow (kProduct m m) m }
  , multiplicative :
      { identity : m, op : kArrow (kProduct m m) m }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { additive :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , inverse :
          cat.arrow { _1 = m, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  , multiplicative :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Ring/Ordered</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { additive :
      { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , le :
          m → m → Bool
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity : {} → m, op : { _1 : m, _2 : m } → m }
  }
</pre></dd>
</dl>
<h4>extractPartiallyOrderedRing (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( ring
    : { additive :
          { eq :
              m → m → Bool
          , identity :
              {} → m
          , inverse :
              m → m
          , le :
              m → m → Bool
          , op :
              { _1 : m, _2 : m } → m
          , partialLE :
              m → m → Optional Bool
          , preLE :
              m → m → Optional Bool
          }
      , multiplicative :
          { identity : {} → m, op : { _1 : m, _2 : m } → m }
      }
    )
→ { additive :
      { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity : {} → m, op : { _1 : m, _2 : m } → m }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Ring/PartiallyOrdered</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { additive :
      { eq :
          m → m → Bool
      , identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , partialLE :
          m → m → Optional Bool
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity : {} → m, op : { _1 : m, _2 : m } → m }
  }
</pre></dd>
</dl>
<h4>extractRing (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( ring
    : { additive :
          { eq :
              m → m → Bool
          , identity :
              {} → m
          , inverse :
              m → m
          , op :
              { _1 : m, _2 : m } → m
          , partialLE :
              m → m → Optional Bool
          , preLE :
              m → m → Optional Bool
          }
      , multiplicative :
          { identity : {} → m, op : { _1 : m, _2 : m } → m }
      }
    )
→ { additive :
      { identity : {} → m, inverse : m → m, op : { _1 : m, _2 : m } → m }
  , multiplicative :
      { identity : {} → m, op : { _1 : m, _2 : m } → m }
  }
</pre></dd>
</dl>
<h4>extractSetRing (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀ ( ring
    : { additive :
          { eq :
              m → m → Bool
          , identity :
              {} → m
          , inverse :
              m → m
          , op :
              { _1 : m, _2 : m } → m
          , partialLE :
              m → m → Optional Bool
          , preLE :
              m → m → Optional Bool
          }
      , multiplicative :
          { identity : {} → m, op : { _1 : m, _2 : m } → m }
      }
    )
→ { additive :
      { identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity : {} → m, op : { _1 : m, _2 : m } → m }
  }
</pre></dd>
</dl>
<h4>Set (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { additive :
      { identity :
          {} → m
      , inverse :
          m → m
      , op :
          { _1 : m, _2 : m } → m
      , preLE :
          m → m → Optional Bool
      }
  , multiplicative :
      { identity : {} → m, op : { _1 : m, _2 : m } → m }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { additive :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , inverse :
          cat.arrow { _1 = m, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  , multiplicative :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>extractRig (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ ∀ ( ring
    : { additive :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , inverse :
              cat.arrow { _1 = m, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      , multiplicative :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      }
    )
→ { additive :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  , multiplicative :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>subtract (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀ ( category
    : { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀ ( bifunctor
    : { map :
            { _1 : object, _2 : object }
          → { _1 : object, _2 : object }
          → { _1 :
                cat.arrow { _1 = _@1._1, _2 = _._1 }
            , _2 :
                cat.arrow { _1 = _@1._2, _2 = _._2 }
            }
          → cat.arrow { _1 = cat.op _@2, _2 = cat.op _@1 }
      }
    )
→ ∀(m : object)
→ ∀ ( ring
    : { additive :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , inverse :
              cat.arrow { _1 = m, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      , multiplicative :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      }
    )
→ cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀ ( category
    : { identity :
          object → cat.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀ ( bifunctor
    : { map :
            { _1 : object, _2 : object }
          → { _1 : object, _2 : object }
          → { _1 :
                cat.arrow { _1 = _@1._1, _2 = _._1 }
            , _2 :
                cat.arrow { _1 = _@1._2, _2 = _._2 }
            }
          → cat.arrow { _1 = cat.op _@2, _2 = cat.op _@1 }
      }
    )
→ ∀(m : object)
→ ∀ ( ring
    : { additive :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , inverse :
              cat.arrow { _1 = m, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      , multiplicative :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      }
    )
→ { add :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  , multiply :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  , negate :
      cat.arrow { _1 = m, _2 = m }
  , one :
      cat.arrow { _1 = cat.identity, _2 = m }
  , subtract :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  , zero :
      cat.arrow { _1 = cat.identity, _2 = m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Rng</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(m : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(m : Kind)
→ { additive :
      { identity : m, inverse : kArrow m m, op : kArrow (kProduct m m) m }
  , multiplicative :
      { op : kArrow (kProduct m m) m }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { additive :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , inverse :
          cat.arrow { _1 = m, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  , multiplicative :
      { op : cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m } }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Semigroup</h2>
<h3 style="background-color: #bbb; width: 100%">./Semigroup/Commutative</h3>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
(Kind → Kind → Kind) → (Kind → Kind → Kind) → Kind → Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(_ : Kind → Kind → Kind)
→ λ(_ : Kind → Kind → Kind)
→ λ(_ : Kind)
→ { op : _@2 (_@1 _ _) _ }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  Kind
→ { arrow :
      { _1 : _, _2 : _ } → Type
  , constraint :
      _ → Type
  , op :
      { _1 : _, _2 : _ } → _@1
  }
→ _@1
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(_ : Kind)
→ λ ( _
    : { arrow :
          { _1 : _, _2 : _ } → Type
      , constraint :
          _ → Type
      , op :
          { _1 : _, _2 : _ } → _@1
      }
    )
→ λ(_ : _@1)
→ { op : _@1.arrow { _1 = _@1.op { _1 = _, _2 = _ }, _2 = _ } }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Semigroup/Inverse</h3>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(m : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(m : Kind)
→ { inverse : kArrow m m, op : kArrow (kProduct m m) m }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { inverse :
      cat.arrow { _1 = m, _2 = m }
  , op :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  }
</pre></dd>
</dl>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
(Kind → Kind → Kind) → (Kind → Kind → Kind) → Kind → Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(_ : Kind → Kind → Kind)
→ λ(_ : Kind → Kind → Kind)
→ λ(_ : Kind)
→ { op : _@2 (_@1 _ _) _ }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  Kind
→ { arrow :
      { _1 : _, _2 : _ } → Type
  , constraint :
      _ → Type
  , op :
      { _1 : _, _2 : _ } → _@1
  }
→ _@1
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(_ : Kind)
→ λ ( _
    : { arrow :
          { _1 : _, _2 : _ } → Type
      , constraint :
          _ → Type
      , op :
          { _1 : _, _2 : _ } → _@1
      }
    )
→ λ(_ : _@1)
→ { op : _@1.arrow { _1 = _@1.op { _1 = _, _2 = _ }, _2 = _ } }
</pre></dd>
</dl>
<h4>functor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀ ( semigroupoid
    : { op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀ ( bifunctor
    : { map :
            { _1 : object, _2 : object }
          → { _1 : object, _2 : object }
          → { _1 :
                cat.arrow { _1 = _@1._1, _2 = _._1 }
            , _2 :
                cat.arrow { _1 = _@1._2, _2 = _._2 }
            }
          → cat.arrow { _1 = cat.op _@2, _2 = cat.op _@1 }
      }
    )
→ { map :
        ∀(a : object)
      → ∀(b : object)
      → ∀ ( fn
          : { from :
                cat.arrow { _1 = b, _2 = a }
            , to :
                cat.arrow { _1 = a, _2 = b }
            }
          )
      → ∀(fa : { op : cat.arrow { _1 = cat.op { _1 = a, _2 = a }, _2 = a } })
      → { op : cat.arrow { _1 = cat.op { _1 = b, _2 = b }, _2 = b } }
  }
</pre></dd>
</dl>
<h4>laws (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type)
→ ∀(eq : { eq : m → m → Bool })
→ ∀(semigroup : { op : { _1 : m, _2 : m } → m })
→ { associativity : ∀(a : m) → ∀(b : m) → ∀(c : m) → Bool }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ ∀(semigroup : { op : cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m } })
→ { op : cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m } }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Semigroupoid</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ({ _1 : object, _2 : object } → Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ λ(_ : { _1 : object, _2 : object } → Type)
→ { op :
        { _1 : object, _2 : object }
      → (   Type
          → (   object
              → _@3 { _1 = _, _2 = _@2._2 }
              → _@4 { _1 = _@3._1, _2 = _@1 }
              → _@3
            )
          → _@1
        )
      → _@2 _@1
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Semilattice</h2>
<h3 style="background-color: #bbb; width: 100%">./Semilattice/Bounded</h3>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
(Kind → Kind → Kind) → (Kind → Kind → Kind) → Kind → Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(_ : Kind → Kind → Kind)
→ λ(_ : Kind → Kind → Kind)
→ λ(_ : Kind)
→ { identity : _, op : _@2 (_@1 _ _) _ }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  Kind
→ { arrow :
      { _1 : _, _2 : _ } → Type
  , constraint :
      _ → Type
  , identity :
      _
  , op :
      { _1 : _, _2 : _ } → _@1
  }
→ _@1
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(_ : Kind)
→ λ ( _
    : { arrow :
          { _1 : _, _2 : _ } → Type
      , constraint :
          _ → Type
      , identity :
          _
      , op :
          { _1 : _, _2 : _ } → _@1
      }
    )
→ λ(_ : _@1)
→ { identity :
      _@1.arrow { _1 = _@1.identity, _2 = _ }
  , op :
      _@1.arrow { _1 = _@1.op { _1 = _, _2 = _ }, _2 = _ }
  }
</pre></dd>
</dl>
<h4>Set (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
∀(m : Type) → Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(m : Type)
→ { identity :
      {} → m
  , op :
      { _1 : m, _2 : m } → m
  , partialLE :
      m → m → Optional Bool
  , preLE :
      m → m → Optional Bool
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  Kind
→ { arrow :
      { _1 : _, _2 : _ } → Type
  , constraint :
      _ → Type
  , op :
      { _1 : _, _2 : _ } → _@1
  }
→ _@1
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(_ : Kind)
→ λ ( _
    : { arrow :
          { _1 : _, _2 : _ } → Type
      , constraint :
          _ → Type
      , op :
          { _1 : _, _2 : _ } → _@1
      }
    )
→ λ(_ : _@1)
→ { op : _@1.arrow { _1 = _@1.op { _1 = _, _2 = _ }, _2 = _ } }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Semiring</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(m : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(m : Kind)
→ { additive :
      { op : kArrow (kProduct m m) m }
  , multiplicative :
      { identity : m, op : kArrow (kProduct m m) m }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Semiring/Near</h3>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  ∀(kArrow : Kind → Kind → Kind)
→ ∀(kProduct : Kind → Kind → Kind)
→ ∀(m : Kind)
→ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  λ(kArrow : Kind → Kind → Kind)
→ λ(kProduct : Kind → Kind → Kind)
→ λ(m : Kind)
→ { additive :
      { op : kArrow (kProduct m m) m }
  , multiplicative :
      { identity : m, op : kArrow (kProduct m m) m }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { additive :
      { op : cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m } }
  , multiplicative :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p>{- This is different from what is often called a “semiring” as it lacks
   additive identity, but here we follow the convention described in
   https://ncatlab.org/nlab/show/rig, using the name “rig” for what would
   traditionally be a semiring.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ λ(m : object)
→ { additive :
      { op : cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m } }
  , multiplicative :
      { identity :
          cat.arrow { _1 = cat.identity, _2 = m }
      , op :
          cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      , identity :
          object
      , op :
          { _1 : object, _2 : object } → object
      }
    )
→ ∀(m : object)
→ ∀ ( semiring
    : { additive :
          { op : cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m } }
      , multiplicative :
          { identity :
              cat.arrow { _1 = cat.identity, _2 = m }
          , op :
              cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
          }
      }
    )
→ { add :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  , multiply :
      cat.arrow { _1 = cat.op { _1 = m, _2 = m }, _2 = m }
  , one :
      cat.arrow { _1 = cat.identity, _2 = m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Star</h2>
<h4>Type (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(vObject : Kind)
→ ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → vObject
      , constraint :
          object → Type
      }
    )
→ ∀(m : object → object)
→ ∀(a : { _1 : object, _2 : object })
→ vObject
</pre></dd>
</dl>
<h4>category (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ ∀ ( semigroupoid
    : { op :
            { _1 : object, _2 : object }
          → (   Type
              → (   object
                  → cat.arrow { _1 = _, _2 = _@2._2 }
                  → cat.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → cat.arrow _@1
      }
    )
→ ∀(m : object → object)
→ ∀ ( functor
    : { map :
            object
          → object
          → cat.arrow { _1 = _@1, _2 = _ }
          → cat.arrow { _1 = m _@2, _2 = m _@1 }
      }
    )
→ ∀ ( monad
    : { identity :
          object → cat.arrow { _1 = _, _2 = m _ }
      , op :
          object → cat.arrow { _1 = m (m _), _2 = m _ }
      }
    )
→ { identity :
      object → cat.arrow { _1 = _, _2 = m _ }
  , op :
        ∀(a : { _1 : object, _2 : object })
      → ∀ ( p
          :   ∀(r : Type)
            → (   ∀(z : object)
                → cat.arrow { _1 = z, _2 = m a._2 }
                → cat.arrow { _1 = a._1, _2 = m z }
                → r
              )
            → r
          )
      → cat.arrow { _1 = a._1, _2 = m a._2 }
  }
</pre></dd>
</dl>
<h4>semigroupoid (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Strong</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀(dObject : Kind)
→ ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ ∀(f : { _1 : dObject, _2 : cObject } → Type)
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(cObject : Kind)
→ λ(dObject : Kind)
→ λ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ λ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ λ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ λ(f : { _1 : dObject, _2 : cObject } → Type)
→ { lmap :
        ∀(h : dObject)
      → ∀(i : dObject)
      → ∀(j : cObject)
      → d.arrow { _1 = i, _2 = h }
      → f { _1 = h, _2 = j }
      → f { _1 = i, _2 = j }
  , map :
        { _1 : dObject, _2 : cObject }
      → { _1 : dObject, _2 : cObject }
      → v.arrow
        { _1 =
            v.op
            { _1 =
                d.arrow { _1 = _._1, _2 = _@1._1 }
            , _2 =
                c.arrow { _1 = _@1._2, _2 = _._2 }
            }
        , _2 =
            v.arrow { _1 = f _@1, _2 = f _ }
        }
  , rmap :
        ∀(h : dObject)
      → ∀(i : cObject)
      → ∀(j : cObject)
      → c.arrow { _1 = i, _2 = j }
      → f { _1 = h, _2 = i }
      → f { _1 = h, _2 = j }
  }
</pre></dd>
</dl>
<h4>extractProfunctor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀ ( v
    : { arrow :
          { _1 : Type, _2 : Type } → Type
      , constraint :
          Type → Type
      , identity :
          Type
      , op :
          { _1 : Type, _2 : Type } → Type
      }
    )
→ ∀(cObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀(dObject : Kind)
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ ∀(f : { _1 : dObject, _2 : cObject } → Type)
→ ∀ ( strong
    : { lmap :
            dObject
          → dObject
          → cObject
          → d.arrow { _1 = _@1, _2 = _@2 }
          → f { _1 = _@3, _2 = _@1 }
          → f { _1 = _@3, _2 = _@2 }
      , map :
            { _1 : dObject, _2 : cObject }
          → { _1 : dObject, _2 : cObject }
          → v.arrow
            { _1 =
                v.op
                { _1 =
                    d.arrow { _1 = _._1, _2 = _@1._1 }
                , _2 =
                    c.arrow { _1 = _@1._2, _2 = _._2 }
                }
            , _2 =
                v.arrow { _1 = f _@1, _2 = f _ }
            }
      , rmap :
            dObject
          → cObject
          → cObject
          → c.arrow { _1 = _@1, _2 = _ }
          → f { _1 = _@3, _2 = _@2 }
          → f { _1 = _@4, _2 = _@2 }
      }
    )
→ { map :
        { _1 : dObject, _2 : cObject }
      → { _1 : dObject, _2 : cObject }
      → v.arrow
        { _1 =
            v.op
            { _1 =
                d.arrow { _1 = _._1, _2 = _@1._1 }
            , _2 =
                c.arrow { _1 = _@1._2, _2 = _._2 }
            }
        , _2 =
            v.arrow { _1 = f _@1, _2 = f _ }
        }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Text</h2>
<h4>monoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ identity : {} → Text, op : ∀(a : { _1 : Text, _2 : Text }) → Text }
</pre></dd>
</dl>
<h4>semigroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ op : { _1 : Text, _2 : Text } → Text }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Tuple</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
∀(a : Kind) → ∀(b : Kind) → Kind
</pre></dd>
<dt>kind</dt><dd><pre>
λ(a : Kind) → λ(b : Kind) → { _1 : a, _2 : b }
</pre></dd>
</dl>
<h4>adjunction (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(s : Type)
→ { counit :
      ∀(a : Type) → ∀(x : { _1 : s, _2 : s → a }) → a
  , leftAdjunct :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(f : { _1 : s, _2 : a } → b)
      → ∀(x : a)
      → ∀(y : s)
      → b
  , rightAdjunct :
        ∀(a : Type)
      → ∀(b : Type)
      → ∀(f : a → s → b)
      → ∀(t : { _1 : s, _2 : a })
      → b
  , unit :
      ∀(a : Type) → ∀(x : a) → ∀(y : s) → { _1 : s, _2 : a }
  }
</pre></dd>
</dl>
<h4>comonad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(a : Type)
→ { identity :
      ∀(b : Type) → ∀(tup : { _1 : a, _2 : b }) → b
  , op :
        ∀(b : Type)
      → ∀(tup : { _1 : a, _2 : b })
      → { _1 : a, _2 : { _1 : a, _2 : b } }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Tuple/functor</h3>
<h4 style="background-color: #bbb; width: 100%">./Tuple/functor/endo</h4>
<h4>star (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(m : Type → Type)
→ ∀(functor : { map : Type → Type → (_@1 → _@1) → m _@2 → m _@2 })
→ ∀(a : Type)
→ { map :
        ∀(b : Type)
      → ∀(c : Type)
      → ∀(f : b → m c)
      → ∀(t : { _1 : a, _2 : b })
      → m { _1 : a, _2 : c }
  }
</pre></dd>
</dl>
<h4>pair (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ map :
      ∀(a : { _1 : Type, _2 : Type })
    → ∀(b : { _1 : Type, _2 : Type })
    → ∀(f : { _1 : a._1 → b._1, _2 : a._2 → b._2 })
    → ∀(t : { _1 : a._1, _2 : a._2 })
    → { _1 : b._1, _2 : b._2 }
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Unit</h2>
<h4>eq (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ eq : {} → {} → Bool }
</pre></dd>
</dl>
<h4>orderedGroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ eq :
    {} → {} → Bool
, identity :
    {} → {}
, inverse :
    {} → {}
, le :
    {} → {} → Bool
, op :
    { _1 : {}, _2 : {} } → {}
, partialLE :
    {} → {} → Optional Bool
}
</pre></dd>
</dl>
<h4>partiallyOrderedGroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ eq :
    {} → {} → Bool
, identity :
    {} → {}
, inverse :
    {} → {}
, op :
    { _1 : {}, _2 : {} } → {}
, partialLE :
    {} → {} → Optional Bool
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Void</h2>
<h4>eq (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ eq : <> → <> → Bool }
</pre></dd>
</dl>
<h4>semigroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ op : ∀(p : { _1 : <>, _2 : <> }) → <> }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Yoneda</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  ∀(object : Kind)
→ ∀ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ (object → Type)
→ object
→ Type
</pre></dd>
<dt>type</dt><dd><pre>
  λ(object : Kind)
→ λ ( cat
    : { arrow :
          { _1 : object, _2 : object } → Type
      , constraint :
          object → Type
      }
    )
→ λ(_ : object → Type)
→ λ(_ : object)
→ object → cat.arrow { _1 = _@1, _2 = _ } → _@3 _@1
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Yoneda/functor</h3>
<h4>instance (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀ ( cSemigroupoid
    : { op :
            { _1 : cObject, _2 : cObject }
          → (   Type
              → (   cObject
                  → c.arrow { _1 = _, _2 = _@2._2 }
                  → c.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → c.arrow _@1
      }
    )
→ ∀(f : cObject → Type)
→ { map :
        cObject
      → cObject
      → c.arrow { _1 = _@1, _2 = _ }
      → (cObject → c.arrow { _1 = _@3, _2 = _ } → f _@1)
      → cObject
      → c.arrow { _1 = _@3, _2 = _ }
      → f _@1
  }
</pre></dd>
</dl>
<h4>monoidal (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h4>lift (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  ∀(cObject : Kind)
→ ∀ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } → Type
      , constraint :
          cObject → Type
      }
    )
→ ∀(dObject : Kind)
→ ∀ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } → Type
      , constraint :
          dObject → Type
      }
    )
→ ∀ ( dCategory
    : { identity :
          dObject → d.arrow { _1 = _, _2 = _ }
      , op :
            { _1 : dObject, _2 : dObject }
          → (   Type
              → (   dObject
                  → d.arrow { _1 = _, _2 = _@2._2 }
                  → d.arrow { _1 = _@3._1, _2 = _@1 }
                  → _@3
                )
              → _@1
            )
          → d.arrow _@1
      }
    )
→ ∀(f : cObject → dObject)
→ ∀ ( functor
    : { map :
            cObject
          → cObject
          → c.arrow { _1 = _@1, _2 = _ }
          → d.arrow { _1 = f _@2, _2 = f _@1 }
      }
    )
→ cObject
→ cObject
→ c.arrow { _1 = _@1, _2 = _ }
→ d.arrow { _1 = f _@2, _2 = f _@1 }
</pre></dd>
</dl>
<h4>lower (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
(Type → Type) → Type → (Type → (_@1 → _@1) → _@3 _@1) → _@2 _@1
</pre></dd>
</dl>
<h4>monad (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./docs</h2>
<h2 style="background-color: #bbb; width: 100%">./scripts</h2>
</body></html>
