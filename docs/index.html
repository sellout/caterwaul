<html>
<head>
<title>caterwaul</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>
<h1>caterwaul</h1>
<h1 style="background-color: #bbb; width: 100%">.</h1>
<h2 style="background-color: #bbb; width: 100%">./Adjunction</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€(f : dObject â†’ cObject)
â†’ âˆ€(g : cObject â†’ dObject)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(cObject : Kind)
â†’ Î»(dObject : Kind)
â†’ Î»(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ Î» ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ Î» ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ Î»(f : dObject â†’ cObject)
â†’ Î»(g : cObject â†’ dObject)
â†’ { counit :
      âˆ€(a : cObject) â†’ c.arrow { _1 = f (g a), _2 = a }
  , leftAdjunct :
        âˆ€(a : dObject)
      â†’ âˆ€(b : cObject)
      â†’ v.arrow
        { _1 = c.arrow { _1 = f a, _2 = b }, _2 = d.arrow { _1 = a, _2 = g b } }
  , rightAdjunct :
        âˆ€(a : dObject)
      â†’ âˆ€(b : cObject)
      â†’ v.arrow
        { _1 = d.arrow { _1 = a, _2 = g b }, _2 = c.arrow { _1 = f a, _2 = b } }
  , unit :
      âˆ€(a : dObject) â†’ d.arrow { _1 = a, _2 = g (f a) }
  }
</pre></dd>
</dl>
<h4>impliedComonad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€(f : dObject â†’ cObject)
â†’ âˆ€ ( functor
    : { map :
            âˆ€(a : dObject)
          â†’ âˆ€(b : dObject)
          â†’ d.arrow { _1 = a, _2 = b }
          â†’ c.arrow { _1 = f a, _2 = f b }
      }
    )
â†’ âˆ€(g : cObject â†’ dObject)
â†’ âˆ€ ( adjunction
    : { counit :
          âˆ€(a : cObject) â†’ c.arrow { _1 = f (g a), _2 = a }
      , leftAdjunct :
            âˆ€(a : dObject)
          â†’ âˆ€(b : cObject)
          â†’ c.arrow { _1 = f a, _2 = b }
          â†’ d.arrow { _1 = a, _2 = g b }
      , rightAdjunct :
            âˆ€(a : dObject)
          â†’ âˆ€(b : cObject)
          â†’ d.arrow { _1 = a, _2 = g b }
          â†’ c.arrow { _1 = f a, _2 = b }
      , unit :
          âˆ€(a : dObject) â†’ d.arrow { _1 = a, _2 = g (f a) }
      }
    )
â†’ { product :
      âˆ€(a : cObject) â†’ c.arrow { _1 = f (g a), _2 = f (g (f (g a))) }
  , unit :
      âˆ€(a : cObject) â†’ c.arrow { _1 = f (g a), _2 = a }
  }
</pre></dd>
</dl>
<h4>impliedMonad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€(f : dObject â†’ cObject)
â†’ âˆ€(g : cObject â†’ dObject)
â†’ âˆ€ ( functor
    : { map :
            âˆ€(a : cObject)
          â†’ âˆ€(b : cObject)
          â†’ c.arrow { _1 = a, _2 = b }
          â†’ d.arrow { _1 = g a, _2 = g b }
      }
    )
â†’ âˆ€ ( adjunction
    : { counit :
          âˆ€(a : cObject) â†’ c.arrow { _1 = f (g a), _2 = a }
      , leftAdjunct :
            âˆ€(a : dObject)
          â†’ âˆ€(b : cObject)
          â†’ c.arrow { _1 = f a, _2 = b }
          â†’ d.arrow { _1 = a, _2 = g b }
      , rightAdjunct :
            âˆ€(a : dObject)
          â†’ âˆ€(b : cObject)
          â†’ d.arrow { _1 = a, _2 = g b }
          â†’ c.arrow { _1 = f a, _2 = b }
      , unit :
          âˆ€(a : dObject) â†’ d.arrow { _1 = a, _2 = g (f a) }
      }
    )
â†’ { product :
      âˆ€(a : dObject) â†’ d.arrow { _1 = g (f (g (f a))), _2 = g (f a) }
  , unit :
      âˆ€(a : dObject) â†’ d.arrow { _1 = a, _2 = g (f a) }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Bimonad</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€(m : object â†’ object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î»(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ Î»(m : object â†’ object)
â†’ { comonoid :
      { product :
          âˆ€(a : object) â†’ cat.arrow { _1 = m a, _2 = m (m a) }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = m a, _2 = a }
      }
  , monoid :
      { product :
          âˆ€(a : object) â†’ cat.arrow { _1 = m (m a), _2 = m a }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = m a }
      }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Bimonoid</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { comonoid :
      { product :
          cat.arrow { _1 = m, _2 = cat.product { _1 = m, _2 = m } }
      , unit :
          cat.arrow { _1 = m, _2 = cat.unit }
      }
  , monoid :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Bool</h2>
<h4>eq (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ eq : âˆ€(x : Bool) â†’ âˆ€(y : Bool) â†’ Bool }
</pre></dd>
</dl>
<h4>lattice (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ join :
    { product : âˆ€(p : { _1 : Bool, _2 : Bool }) â†’ Bool, unit : {} â†’ Bool }
, meet :
    { product : âˆ€(p : { _1 : Bool, _2 : Bool }) â†’ Bool, unit : {} â†’ Bool }
}
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Bool/monoid</h3>
<h4>conjunction (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ product : âˆ€(p : { _1 : Bool, _2 : Bool }) â†’ Bool, unit : {} â†’ Bool }
</pre></dd>
</dl>
<h4>disjunction (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ product : âˆ€(p : { _1 : Bool, _2 : Bool }) â†’ Bool, unit : {} â†’ Bool }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Category</h2>
<h3 style="background-color: #bbb; width: 100%">./Category/Cartesian</h3>
<h4>Kind (kind)</h4>
<p>{- Canâ€™t define `augmentation` at this level, because we have no unit `Kind`.
-}</p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(vObject : Kind)
â†’ Î»(object : Kind)
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  , diagonal :
      cat.arrow object (cat.product object object)
  , product :
      cat.arrow (cat.product object object) object
  , unit :
      object
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { category :
      { hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ v.arrow
                { _1 =
                    v.product
                    { _1 =
                        cat.arrow { _1 = b._1, _2 = a._1 }
                    , _2 =
                        cat.arrow { _1 = a._2, _2 = b._2 }
                    }
                , _2 =
                    v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
                }
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
  , comonoid :
      { product :
          cat.arrow { _1 = m, _2 = cat.product { _1 = m, _2 = m } }
      , unit :
          cat.arrow { _1 = m, _2 = cat.unit }
      }
  , monoid :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>extractCategory (term)</h4>
<p>{- FIXME: Should be able to do `cartesian.{ arrow, product }`, but Dhall doesnâ€™t like
          that for some reason.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( cartesian
    : { arrow :
          cat.arrow (cat.product object object) vObject
      , constraint :
          object â†’ Type
      , diagonal :
          cat.arrow object (cat.product object object)
      , product :
          cat.arrow (cat.product object object) object
      , unit :
          object
      }
    )
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  }
</pre></dd>
</dl>
<h4>impliedBimonoid (term)</h4>
<p>{- Every monoid in a cartesian category is a bimonoid in a unique way. -}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( cartesian
    : { category :
          { hom :
              { map :
                    âˆ€(a : { _1 : object, _2 : object })
                  â†’ âˆ€(b : { _1 : object, _2 : object })
                  â†’ v.arrow
                    { _1 =
                        v.product
                        { _1 =
                            cat.arrow { _1 = b._1, _2 = a._1 }
                        , _2 =
                            cat.arrow { _1 = a._2, _2 = b._2 }
                        }
                    , _2 =
                        v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
                    }
              }
          , product :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ (   âˆ€(r : Type)
                  â†’ (   âˆ€(z : object)
                      â†’ cat.arrow { _1 = z, _2 = a._2 }
                      â†’ cat.arrow { _1 = a._1, _2 = z }
                      â†’ r
                    )
                  â†’ r
                )
              â†’ cat.arrow a
          , unit :
              âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
          }
      , comonoid :
          { product :
              cat.arrow { _1 = m, _2 = cat.product { _1 = m, _2 = m } }
          , unit :
              cat.arrow { _1 = m, _2 = cat.unit }
          }
      , monoid :
          { product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      }
    )
â†’ âˆ€ ( monoid
    : { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
    )
â†’ { comonoid :
      { product :
          cat.arrow { _1 = m, _2 = cat.product { _1 = m, _2 = m } }
      , unit :
          cat.arrow { _1 = m, _2 = cat.unit }
      }
  , monoid :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>impliedHopfMonoid (term)</h4>
<p>{- Every group in a cartesian category is a Hopf monoid in a unique way. -}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( cartesian
    : { category :
          { hom :
              { map :
                    âˆ€(a : { _1 : object, _2 : object })
                  â†’ âˆ€(b : { _1 : object, _2 : object })
                  â†’ v.arrow
                    { _1 =
                        v.product
                        { _1 =
                            cat.arrow { _1 = b._1, _2 = a._1 }
                        , _2 =
                            cat.arrow { _1 = a._2, _2 = b._2 }
                        }
                    , _2 =
                        v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
                    }
              }
          , product :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ (   âˆ€(r : Type)
                  â†’ (   âˆ€(z : object)
                      â†’ cat.arrow { _1 = z, _2 = a._2 }
                      â†’ cat.arrow { _1 = a._1, _2 = z }
                      â†’ r
                    )
                  â†’ r
                )
              â†’ cat.arrow a
          , unit :
              âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
          }
      , comonoid :
          { product :
              cat.arrow { _1 = m, _2 = cat.product { _1 = m, _2 = m } }
          , unit :
              cat.arrow { _1 = m, _2 = cat.unit }
          }
      , monoid :
          { product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      }
    )
â†’ âˆ€ ( group
    : { inverse :
          cat.arrow { _1 = m, _2 = m }
      , product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
    )
â†’ { antipode :
      cat.arrow { _1 = m, _2 = m }
  , comonoid :
      { product :
          cat.arrow { _1 = m, _2 = cat.product { _1 = m, _2 = m } }
      , unit :
          cat.arrow { _1 = m, _2 = cat.unit }
      }
  , monoid :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Cat</h3>
<h4>semigroupal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ arrow :
    âˆ€(a : Kind) â†’ âˆ€(b : Kind) â†’ Kind
, product :
    âˆ€(a : Kind) â†’ âˆ€(b : Kind) â†’ Kind
}
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Closed</h3>
<h4>Kind (kind)</h4>
<p>{- A category enriched over itself.
-}</p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(object : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(object : Kind)
â†’ { arrow :
      cat.arrow (cat.product object object) object
  , constraint :
      object â†’ Type
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Dagger</h3>
<h4>Kind (term)</h4>
<p>{- A true â€ -category has a contravariant endofunctor on C that reverses the
   morphisms. Iâ€™m not sure how to implement that, so this structure simply uses
   pairs of morphisms as the morphism.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ { arrow :
      âˆ€(a : { _1 : object, _2 : object }) â†’ Type
  , constraint :
      object â†’ Type
  }
</pre></dd>
</dl>
<h4>category (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€ ( category
    : { hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ { hom :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ âˆ€ ( fn
              : { _1 :
                    { from :
                        cat.arrow { _1 = a._1, _2 = b._1 }
                    , to :
                        cat.arrow { _1 = b._1, _2 = a._1 }
                    }
                , _2 :
                    { from :
                        cat.arrow { _1 = b._2, _2 = a._2 }
                    , to :
                        cat.arrow { _1 = a._2, _2 = b._2 }
                    }
                }
              )
          â†’ âˆ€ ( f
              : { from : cat.arrow { _1 = a._2, _2 = a._1 }, to : cat.arrow a }
              )
          â†’ { from : cat.arrow { _1 = b._2, _2 = b._1 }, to : cat.arrow b }
      }
  , product :
        âˆ€(a : { _1 : object, _2 : object })
      â†’ âˆ€ ( p
          :   âˆ€(r : Type)
            â†’ (   âˆ€(z : object)
                â†’ { from :
                      cat.arrow { _1 = a._2, _2 = z }
                  , to :
                      cat.arrow { _1 = z, _2 = a._2 }
                  }
                â†’ { from :
                      cat.arrow { _1 = z, _2 = a._1 }
                  , to :
                      cat.arrow { _1 = a._1, _2 = z }
                  }
                â†’ r
              )
            â†’ r
          )
      â†’ { from : cat.arrow { _1 = a._2, _2 = a._1 }, to : cat.arrow a }
  , unit :
        âˆ€(a : object)
      â†’ { from :
            cat.arrow { _1 = a, _2 = a }
        , to :
            cat.arrow { _1 = a, _2 = a }
        }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Duoidal</h3>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(vObject : Kind)
â†’ Î»(object : Kind)
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  , diamond :
      { product : cat.arrow (cat.product object object) object, unit : object }
  , star :
      { product : cat.arrow (cat.product object object) object, unit : object }
  }
</pre></dd>
</dl>
<h4>Sort (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
Sort
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p>{- TODO: Ideally, the diamond and star monoids shouldnâ€™t _also_ have
         the category members (as they just duplicate the ones on the rig), but
  	     it was more trouble to avoid them for the time being.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , diamond :
          { product : { _1 : object, _2 : object } â†’ object, unit : object }
      , star :
          { product : { _1 : object, _2 : object } â†’ object, unit : object }
      }
    )
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , diamond :
          { product : { _1 : object, _2 : object } â†’ object, unit : object }
      , star :
          { product : { _1 : object, _2 : object } â†’ object, unit : object }
      }
    )
â†’ { combine :
      cat.arrow
      { _1 =
          ( cat.diamond âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
          ).product
          { _1 =
              ( cat.star âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
              ).unit
          , _2 =
              ( cat.star âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
              ).unit
          }
      , _2 =
          (cat.star âˆ§ { arrow = cat.arrow, constraint = cat.constraint }).unit
      }
  , diamond :
      { associativity :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ âˆ€(c : object)
          â†’ { from :
                (   cat.diamond
                  âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                ).arrow
                { _1 =
                    (   cat.diamond
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).product
                    { _1 =
                        a
                    , _2 =
                        (   cat.diamond
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).product
                        { _1 = b, _2 = c }
                    }
                , _2 =
                    (   cat.diamond
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).product
                    { _1 =
                        (   cat.diamond
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).product
                        { _1 = a, _2 = b }
                    , _2 =
                        c
                    }
                }
            , to :
                (   cat.diamond
                  âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                ).arrow
                { _1 =
                    (   cat.diamond
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).product
                    { _1 =
                        (   cat.diamond
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).product
                        { _1 = a, _2 = b }
                    , _2 =
                        c
                    }
                , _2 =
                    (   cat.diamond
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).product
                    { _1 =
                        a
                    , _2 =
                        (   cat.diamond
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).product
                        { _1 = b, _2 = c }
                    }
                }
            }
      , hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ v.arrow
                { _1 =
                    v.product
                    { _1 =
                        (   cat.diamond
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).arrow
                        { _1 = b._1, _2 = a._1 }
                    , _2 =
                        (   cat.diamond
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).arrow
                        { _1 = a._2, _2 = b._2 }
                    }
                , _2 =
                    v.arrow
                    { _1 =
                        (   cat.diamond
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).arrow
                        a
                    , _2 =
                        (   cat.diamond
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).arrow
                        b
                    }
                }
          }
      , leftIdentity :
            âˆ€(a : object)
          â†’ { from :
                (   cat.diamond
                  âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                ).arrow
                { _1 =
                    a
                , _2 =
                    (   cat.diamond
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).product
                    { _1 =
                        (   cat.diamond
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).unit
                    , _2 =
                        a
                    }
                }
            , to :
                (   cat.diamond
                  âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                ).arrow
                { _1 =
                    (   cat.diamond
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).product
                    { _1 =
                        (   cat.diamond
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).unit
                    , _2 =
                        a
                    }
                , _2 =
                    a
                }
            }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ (   cat.diamond
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).arrow
                    { _1 = z, _2 = a._2 }
                  â†’ (   cat.diamond
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).arrow
                    { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ ( cat.diamond âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
            ).arrow
            a
      , rightIdentity :
            âˆ€(a : object)
          â†’ { from :
                (   cat.diamond
                  âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                ).arrow
                { _1 =
                    a
                , _2 =
                    (   cat.diamond
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).product
                    { _1 =
                        a
                    , _2 =
                        (   cat.diamond
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).unit
                    }
                }
            , to :
                (   cat.diamond
                  âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                ).arrow
                { _1 =
                    (   cat.diamond
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).product
                    { _1 =
                        a
                    , _2 =
                        (   cat.diamond
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).unit
                    }
                , _2 =
                    a
                }
            }
      , tensor :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ v.arrow
                { _1 =
                    v.product
                    { _1 =
                        (   cat.diamond
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).arrow
                        { _1 = a._1, _2 = b._1 }
                    , _2 =
                        (   cat.diamond
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).arrow
                        { _1 = a._2, _2 = b._2 }
                    }
                , _2 =
                    (   cat.diamond
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).arrow
                    { _1 =
                        (   cat.diamond
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).product
                        a
                    , _2 =
                        (   cat.diamond
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).product
                        b
                    }
                }
          }
      , unit :
            âˆ€(a : object)
          â†’ ( cat.diamond âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
            ).arrow
            { _1 = a, _2 = a }
      }
  , hom :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
            }
      }
  , product :
        âˆ€(a : { _1 : object, _2 : object })
      â†’ (   âˆ€(r : Type)
          â†’ (   âˆ€(z : object)
              â†’ cat.arrow { _1 = z, _2 = a._2 }
              â†’ cat.arrow { _1 = a._1, _2 = z }
              â†’ r
            )
          â†’ r
        )
      â†’ cat.arrow a
  , split :
      cat.arrow
      { _1 =
          ( cat.diamond âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
          ).unit
      , _2 =
          ( cat.star âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
          ).product
          { _1 =
              ( cat.diamond âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
              ).unit
          , _2 =
              ( cat.diamond âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
              ).unit
          }
      }
  , star :
      { associativity :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ âˆ€(c : object)
          â†’ { from :
                ( cat.star âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                ).arrow
                { _1 =
                    (   cat.star
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).product
                    { _1 =
                        a
                    , _2 =
                        (   cat.star
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).product
                        { _1 = b, _2 = c }
                    }
                , _2 =
                    (   cat.star
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).product
                    { _1 =
                        (   cat.star
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).product
                        { _1 = a, _2 = b }
                    , _2 =
                        c
                    }
                }
            , to :
                ( cat.star âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                ).arrow
                { _1 =
                    (   cat.star
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).product
                    { _1 =
                        (   cat.star
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).product
                        { _1 = a, _2 = b }
                    , _2 =
                        c
                    }
                , _2 =
                    (   cat.star
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).product
                    { _1 =
                        a
                    , _2 =
                        (   cat.star
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).product
                        { _1 = b, _2 = c }
                    }
                }
            }
      , hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ v.arrow
                { _1 =
                    v.product
                    { _1 =
                        (   cat.star
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).arrow
                        { _1 = b._1, _2 = a._1 }
                    , _2 =
                        (   cat.star
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).arrow
                        { _1 = a._2, _2 = b._2 }
                    }
                , _2 =
                    v.arrow
                    { _1 =
                        (   cat.star
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).arrow
                        a
                    , _2 =
                        (   cat.star
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).arrow
                        b
                    }
                }
          }
      , leftIdentity :
            âˆ€(a : object)
          â†’ { from :
                ( cat.star âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                ).arrow
                { _1 =
                    a
                , _2 =
                    (   cat.star
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).product
                    { _1 =
                        (   cat.star
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).unit
                    , _2 =
                        a
                    }
                }
            , to :
                ( cat.star âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                ).arrow
                { _1 =
                    (   cat.star
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).product
                    { _1 =
                        (   cat.star
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).unit
                    , _2 =
                        a
                    }
                , _2 =
                    a
                }
            }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ (   cat.star
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).arrow
                    { _1 = z, _2 = a._2 }
                  â†’ (   cat.star
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).arrow
                    { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ ( cat.star âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
            ).arrow
            a
      , rightIdentity :
            âˆ€(a : object)
          â†’ { from :
                ( cat.star âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                ).arrow
                { _1 =
                    a
                , _2 =
                    (   cat.star
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).product
                    { _1 =
                        a
                    , _2 =
                        (   cat.star
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).unit
                    }
                }
            , to :
                ( cat.star âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                ).arrow
                { _1 =
                    (   cat.star
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).product
                    { _1 =
                        a
                    , _2 =
                        (   cat.star
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).unit
                    }
                , _2 =
                    a
                }
            }
      , tensor :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ v.arrow
                { _1 =
                    v.product
                    { _1 =
                        (   cat.star
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).arrow
                        { _1 = a._1, _2 = b._1 }
                    , _2 =
                        (   cat.star
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).arrow
                        { _1 = a._2, _2 = b._2 }
                    }
                , _2 =
                    (   cat.star
                      âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                    ).arrow
                    { _1 =
                        (   cat.star
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).product
                        a
                    , _2 =
                        (   cat.star
                          âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                        ).product
                        b
                    }
                }
          }
      , unit :
            âˆ€(a : object)
          â†’ ( cat.star âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
            ).arrow
            { _1 = a, _2 = a }
      }
  , swap :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ âˆ€(c : object)
      â†’ âˆ€(d : object)
      â†’ cat.arrow
        { _1 =
            ( cat.diamond âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
            ).product
            { _1 =
                ( cat.star âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                ).product
                { _1 = a, _2 = b }
            , _2 =
                ( cat.star âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                ).product
                { _1 = c, _2 = d }
            }
        , _2 =
            ( cat.star âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
            ).product
            { _1 =
                (   cat.diamond
                  âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                ).product
                { _1 = a, _2 = c }
            , _2 =
                (   cat.diamond
                  âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
                ).product
                { _1 = b, _2 = d }
            }
        }
  , switch :
      cat.arrow
      { _1 =
          ( cat.diamond âˆ§ { arrow = cat.arrow, constraint = cat.constraint }
          ).unit
      , _2 =
          (cat.star âˆ§ { arrow = cat.arrow, constraint = cat.constraint }).unit
      }
  , unit :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
  }
</pre></dd>
</dl>
<h4>extractCategory (term)</h4>
<p>{- FIXME: Should be able to do `duoidal.{ arrow, product }`, but Dhall doesnâ€™t like
          that for some reason.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( duoidal
    : { arrow :
          cat.arrow (cat.product object object) vObject
      , constraint :
          object â†’ Type
      , diamond :
          { product :
              cat.arrow (cat.product object object) object
          , unit :
              object
          }
      , star :
          { product :
              cat.arrow (cat.product object object) object
          , unit :
              object
          }
      }
    )
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  }
</pre></dd>
</dl>
<h4>extractDiamond (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( duoidal
    : { arrow :
          cat.arrow (cat.product object object) vObject
      , constraint :
          object â†’ Type
      , diamond :
          { product :
              cat.arrow (cat.product object object) object
          , unit :
              object
          }
      , star :
          { product :
              cat.arrow (cat.product object object) object
          , unit :
              object
          }
      }
    )
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  , product :
      cat.arrow (cat.product object object) object
  , unit :
      object
  }
</pre></dd>
</dl>
<h4>extractStar (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( duoidal
    : { arrow :
          cat.arrow (cat.product object object) vObject
      , constraint :
          object â†’ Type
      , diamond :
          { product :
              cat.arrow (cat.product object object) object
          , unit :
              object
          }
      , star :
          { product :
              cat.arrow (cat.product object object) object
          , unit :
              object
          }
      }
    )
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  , product :
      cat.arrow (cat.product object object) object
  , unit :
      object
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Endofunctor</h3>
<h4>duoidal (term)</h4>
<p>{- NB: This is defined in terms of the monoidal categories instead of the other
       way around because this is more restrictive than either monoidal
       category.
     â€¢ Applicative requires that the target category is **Set** and
     â€¢ monadic requires an endofunctor`object`.
       When you combine these two restrictions, you end up only being able to
       support endofunctors in **Set**.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ { arrow :
      âˆ€(f : { _1 : Type â†’ Type, _2 : Type â†’ Type }) â†’ Type
  , constraint :
      âˆ€(f : Type â†’ Type) â†’ Type
  , diamond :
      { product :
          âˆ€(f : { _1 : Type â†’ Type, _2 : Type â†’ Type }) â†’ âˆ€(a : Type) â†’ Type
      , unit :
          âˆ€(x : Type) â†’ Type
      }
  , star :
      { product :
          âˆ€(f : { _1 : Type â†’ Type, _2 : Type â†’ Type }) â†’ âˆ€(a : Type) â†’ Type
      , unit :
          âˆ€(a : Type) â†’ Type
      }
  }
</pre></dd>
</dl>
<h4 style="background-color: #bbb; width: 100%">./Category/Endofunctor/monoidal</h4>
<h4>functor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ { arrow :
      âˆ€(f : { _1 : Type â†’ Type, _2 : Type â†’ Type }) â†’ Type
  , constraint :
      âˆ€(f : Type â†’ Type) â†’ Type
  , product :
      âˆ€(f : { _1 : Type â†’ Type, _2 : Type â†’ Type }) â†’ âˆ€(a : Type) â†’ Type
  , unit :
      âˆ€(x : Type) â†’ Type
  }
</pre></dd>
</dl>
<h4>monadic (term)</h4>
<p>{- NB: This doesnâ€™t use `Duoidal/extractMultiplicative` because that has a fixed
      `object`.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ { arrow :
      âˆ€(f : { _1 : object â†’ object, _2 : object â†’ object }) â†’ Type
  , constraint :
      âˆ€(f : object â†’ object) â†’ Type
  , product :
        âˆ€(f : { _1 : object â†’ object, _2 : object â†’ object })
      â†’ âˆ€(a : object)
      â†’ object
  , unit :
      âˆ€(a : object) â†’ object
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Functor</h3>
<h4>category (term)</h4>
<p>{- This cheats a bit on the unit, since `dObject` is Type, we donâ€™t need a
   functor **Set** â†’ ğ’Ÿ.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ { arrow :
      âˆ€(f : { _1 : cObject â†’ dObject, _2 : cObject â†’ dObject }) â†’ Type
  , constraint :
      âˆ€(f : cObject â†’ dObject) â†’ Type
  }
</pre></dd>
</dl>
<h4>inducedFunctor (term)</h4>
<p>{- Any functor `p : C â†’ C'` induces a functor between functor categories
  `[C', D] â†’ [C, D]`.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€(cpObject : Kind)
â†’ âˆ€ ( cp
    : { arrow :
          { _1 : cpObject, _2 : cpObject } â†’ Type
      , constraint :
          cpObject â†’ Type
      }
    )
â†’ âˆ€(p : cObject â†’ cpObject)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ { map :
        âˆ€(a : cpObject â†’ dObject)
      â†’ âˆ€(b : cpObject â†’ dObject)
      â†’ âˆ€(fn : âˆ€(a : cpObject) â†’ d.arrow { _1 = a@1 a, _2 = b a })
      â†’ âˆ€(i : cObject)
      â†’ d.arrow { _1 = a (p i), _2 = b (p i) }
  }
</pre></dd>
</dl>
<h4>liftedDuoidal (term)</h4>
<p>{- For any rig category ğ’, any ğ’-valued functor category is a rig category in
   the same way by â€œliftingâ€ the rig structure of ğ’.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , diamond :
          { product : { _1 : Type, _2 : Type } â†’ Type, unit : Type }
      , star :
          { product : { _1 : Type, _2 : Type } â†’ Type, unit : Type }
      }
    )
â†’ { arrow :
      âˆ€(f : { _1 : cObject â†’ Type, _2 : cObject â†’ Type }) â†’ Type
  , constraint :
      âˆ€(f : cObject â†’ Type) â†’ Type
  , diamond :
      { product :
            âˆ€(f : { _1 : cObject â†’ Type, _2 : cObject â†’ Type })
          â†’ âˆ€(x : cObject)
          â†’ Type
      , unit :
          âˆ€(x : cObject) â†’ Type
      }
  , star :
      { product :
            âˆ€(f : { _1 : cObject â†’ Type, _2 : cObject â†’ Type })
          â†’ âˆ€(x : cObject)
          â†’ Type
      , unit :
          âˆ€(x : cObject) â†’ Type
      }
  }
</pre></dd>
</dl>
<h4>liftedMonoidal (term)</h4>
<p>{- For any monoidal category ğ’, any ğ’-valued functor category is monoidal in the
   same way by â€œliftingâ€ the monoidal structure of ğ’.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ { arrow :
      âˆ€(f : { _1 : cObject â†’ Type, _2 : cObject â†’ Type }) â†’ Type
  , constraint :
      âˆ€(f : cObject â†’ Type) â†’ Type
  , product :
        âˆ€(f : { _1 : cObject â†’ Type, _2 : cObject â†’ Type })
      â†’ âˆ€(x : cObject)
      â†’ Type
  , unit :
      âˆ€(x : cObject) â†’ Type
  }
</pre></dd>
</dl>
<h4>liftedRig (term)</h4>
<p>{- For any rig category ğ’, any ğ’-valued functor category is a rig category in
   the same way by â€œliftingâ€ the rig structure of ğ’.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { additive :
          { product : { _1 : Type, _2 : Type } â†’ Type, unit : Type }
      , arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , multiplicative :
          { product : { _1 : Type, _2 : Type } â†’ Type, unit : Type }
      }
    )
â†’ { additive :
      { product :
            âˆ€(f : { _1 : cObject â†’ Type, _2 : cObject â†’ Type })
          â†’ âˆ€(x : cObject)
          â†’ Type
      , unit :
          âˆ€(x : cObject) â†’ Type
      }
  , arrow :
      âˆ€(f : { _1 : cObject â†’ Type, _2 : cObject â†’ Type }) â†’ Type
  , constraint :
      âˆ€(f : cObject â†’ Type) â†’ Type
  , multiplicative :
      { product :
            âˆ€(f : { _1 : cObject â†’ Type, _2 : cObject â†’ Type })
          â†’ âˆ€(x : cObject)
          â†’ Type
      , unit :
          âˆ€(x : cObject) â†’ Type
      }
  }
</pre></dd>
</dl>
<h4>monoidal (term)</h4>
<p>{- This cheats a bit on the unit, since `dObject` is Type, we donâ€™t need a
   functor **Set** â†’ ğ’Ÿ.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      , product :
          { _1 : cObject, _2 : cObject } â†’ cObject
      , unit :
          cObject
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ { arrow :
      âˆ€(f : { _1 : cObject â†’ Type, _2 : cObject â†’ Type }) â†’ Type
  , constraint :
      âˆ€(f : cObject â†’ Type) â†’ Type
  , product :
        âˆ€(f : { _1 : cObject â†’ Type, _2 : cObject â†’ Type })
      â†’ âˆ€(a : cObject)
      â†’ Type
  , unit :
      âˆ€(x : cObject) â†’ Type
  }
</pre></dd>
</dl>
<h4>types.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ { Adjunction :
        âˆ€(f : (cObject â†’ dObject) â†’ cObject â†’ dObject)
      â†’ âˆ€(g : (cObject â†’ dObject) â†’ cObject â†’ dObject)
      â†’ Type
  , Bifunctor :
        âˆ€ ( f
          :   { _1 : cObject â†’ dObject, _2 : cObject â†’ dObject }
            â†’ cObject
            â†’ dObject
          )
      â†’ Type
  , Category :
        âˆ€ ( v
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            , product :
                { _1 : Type, _2 : Type } â†’ Type
            , unit :
                Type
            }
          )
      â†’ âˆ€ ( cat
          : { arrow :
                { _1 : cObject â†’ dObject, _2 : cObject â†’ dObject } â†’ Type
            , constraint :
                (cObject â†’ dObject) â†’ Type
            }
          )
      â†’ Type
  , Codensity :
        âˆ€ ( d
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            }
          )
      â†’ âˆ€(m : (cObject â†’ dObject) â†’ Type)
      â†’ âˆ€(a : Type)
      â†’ Type
  , Comonad :
      âˆ€(m : (cObject â†’ dObject) â†’ cObject â†’ dObject) â†’ Type
  , Compose :
        âˆ€ ( f
          : { _1 :
                (cObject â†’ dObject) â†’ cObject â†’ dObject
            , _2 :
                (cObject â†’ dObject) â†’ cObject â†’ dObject
            }
          )
      â†’ âˆ€(a : cObject â†’ dObject)
      â†’ cObject
      â†’ dObject
  , Const :
        âˆ€(a : { _1 : cObject â†’ dObject, _2 : cObject â†’ dObject })
      â†’ cObject
      â†’ dObject
  , Costar :
        âˆ€(m : (cObject â†’ dObject) â†’ cObject â†’ dObject)
      â†’ âˆ€(a : { _1 : cObject â†’ dObject, _2 : cObject â†’ dObject })
      â†’ Type
  , Coyoneda :
      âˆ€(f : (cObject â†’ dObject) â†’ Type) â†’ âˆ€(a : cObject â†’ dObject) â†’ Type
  , Density :
        âˆ€ ( d
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            }
          )
      â†’ âˆ€(f : (cObject â†’ dObject) â†’ Type)
      â†’ âˆ€(a : Type)
      â†’ Type
  , Endofunctor :
      âˆ€(f : (cObject â†’ dObject) â†’ cObject â†’ dObject) â†’ Type
  , Identity :
      âˆ€(a : cObject â†’ dObject) â†’ cObject â†’ dObject
  , Lan :
        âˆ€(p : (cObject â†’ dObject) â†’ cObject â†’ dObject)
      â†’ âˆ€(f : (cObject â†’ dObject) â†’ Type)
      â†’ âˆ€(a : cObject â†’ dObject)
      â†’ Type
  , Leibniz :
      { arrow :
          âˆ€(a : { _1 : cObject â†’ dObject, _2 : cObject â†’ dObject }) â†’ Type
      , constraint :
          âˆ€(f : cObject â†’ dObject) â†’ Type
      }
  , Monad :
      âˆ€(m : (cObject â†’ dObject) â†’ cObject â†’ dObject) â†’ Type
  , NaturalTransformation :
        âˆ€ ( f
          : { _1 :
                (cObject â†’ dObject) â†’ cObject â†’ dObject
            , _2 :
                (cObject â†’ dObject) â†’ cObject â†’ dObject
            }
          )
      â†’ Type
  , Profunctor :
      âˆ€(f : { _1 : cObject â†’ dObject, _2 : cObject â†’ dObject } â†’ Type) â†’ Type
  , Ran :
        âˆ€(p : (cObject â†’ dObject) â†’ cObject â†’ dObject)
      â†’ âˆ€(f : (cObject â†’ dObject) â†’ Type)
      â†’ âˆ€(a : cObject â†’ dObject)
      â†’ Type
  , Semigroupoid :
        âˆ€ ( v
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            , product :
                { _1 : Type, _2 : Type } â†’ Type
            , unit :
                Type
            }
          )
      â†’ âˆ€ ( cat
          : { arrow :
                { _1 : cObject â†’ dObject, _2 : cObject â†’ dObject } â†’ Type
            , constraint :
                (cObject â†’ dObject) â†’ Type
            }
          )
      â†’ âˆ€(m : { _1 : cObject â†’ dObject, _2 : cObject â†’ dObject } â†’ Type)
      â†’ Type
  , Star :
        âˆ€(m : (cObject â†’ dObject) â†’ cObject â†’ dObject)
      â†’ âˆ€(a : { _1 : cObject â†’ dObject, _2 : cObject â†’ dObject })
      â†’ Type
  , Traversable :
        âˆ€(m : (cObject â†’ dObject) â†’ cObject â†’ dObject)
      â†’ âˆ€(f : (cObject â†’ dObject) â†’ cObject â†’ dObject)
      â†’ Type
  , Yoneda :
      âˆ€(f : (cObject â†’ dObject) â†’ Type) â†’ âˆ€(a : cObject â†’ dObject) â†’ Type
  }
</pre></dd>
</dl>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(vObject : Kind)
â†’ Î»(object : Kind)
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Kleisli</h3>
<h4>category (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ vObject
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€(m : object â†’ object)
â†’ { arrow :
      âˆ€(a : { _1 : object, _2 : object }) â†’ vObject
  , constraint :
      object â†’ Type
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Monoidal</h3>
<h4 style="background-color: #bbb; width: 100%">./Category/Monoidal/Braided</h4>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ { associativity :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ âˆ€(c : object)
      â†’ { from :
            cat.arrow
            { _1 =
                cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
            , _2 =
                cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
            }
        , to :
            cat.arrow
            { _1 =
                cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
            , _2 =
                cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
            }
        }
  , braid :
        âˆ€(x : object)
      â†’ âˆ€(y : object)
      â†’ cat.arrow
        { _1 =
            cat.product { _1 = x, _2 = y }
        , _2 =
            cat.product { _1 = y, _2 = x }
        }
  , hom :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
            }
      }
  , leftIdentity :
        âˆ€(a : object)
      â†’ { from :
            cat.arrow { _1 = a, _2 = cat.product { _1 = cat.unit, _2 = a } }
        , to :
            cat.arrow { _1 = cat.product { _1 = cat.unit, _2 = a }, _2 = a }
        }
  , product :
        âˆ€(a : { _1 : object, _2 : object })
      â†’ (   âˆ€(r : Type)
          â†’ (   âˆ€(z : object)
              â†’ cat.arrow { _1 = z, _2 = a._2 }
              â†’ cat.arrow { _1 = a._1, _2 = z }
              â†’ r
            )
          â†’ r
        )
      â†’ cat.arrow a
  , rightIdentity :
        âˆ€(a : object)
      â†’ { from :
            cat.arrow { _1 = a, _2 = cat.product { _1 = a, _2 = cat.unit } }
        , to :
            cat.arrow { _1 = cat.product { _1 = a, _2 = cat.unit }, _2 = a }
        }
  , tensor :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = a._1, _2 = b._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                cat.arrow { _1 = cat.product a, _2 = cat.product b }
            }
      }
  , unit :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
  }
</pre></dd>
</dl>
<h4 style="background-color: #bbb; width: 100%">./Category/Monoidal/Cartesian</h4>
<h4>Kind (kind)</h4>
<p>{- Canâ€™t define `augmentation` at this level, because we have no unit `Kind`.
-}</p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(vObject : Kind)
â†’ Î»(object : Kind)
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  , diagonal :
      cat.arrow object (cat.product object object)
  , product :
      cat.arrow (cat.product object object) object
  , unit :
      object
  }
</pre></dd>
</dl>
<h4>extractCategory (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( cartesian
    : { arrow :
          cat.arrow (cat.product object object) vObject
      , constraint :
          object â†’ Type
      , diagonal :
          cat.arrow object (cat.product object object)
      , product :
          cat.arrow (cat.product object object) object
      , unit :
          object
      }
    )
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  }
</pre></dd>
</dl>
<h4>extractMonoidal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( cartesian
    : { arrow :
          cat.arrow (cat.product object object) vObject
      , constraint :
          object â†’ Type
      , diagonal :
          cat.arrow object (cat.product object object)
      , product :
          cat.arrow (cat.product object object) object
      , unit :
          object
      }
    )
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  , product :
      cat.arrow (cat.product object object) object
  , unit :
      object
  }
</pre></dd>
</dl>
<h4>extractSemigroupal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( cartesian
    : { arrow :
          cat.arrow (cat.product object object) vObject
      , constraint :
          object â†’ Type
      , diagonal :
          cat.arrow object (cat.product object object)
      , product :
          cat.arrow (cat.product object object) object
      , unit :
          object
      }
    )
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  , product :
      cat.arrow (cat.product object object) object
  }
</pre></dd>
</dl>
<h4 style="background-color: #bbb; width: 100%">./Category/Monoidal/Closed</h4>
<h5 style="background-color: #bbb; width: 100%">./Category/Monoidal/Closed/Cartesian</h5>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(object : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(object : Kind)
â†’ { arrow :
      cat.arrow (cat.product object object) object
  , constraint :
      object â†’ Type
  , diagonal :
      cat.arrow object (cat.product object object)
  , product :
      cat.arrow (cat.product object object) object
  , unit :
      object
  }
</pre></dd>
</dl>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(object : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(object : Kind)
â†’ { arrow :
      cat.arrow (cat.product object object) object
  , constraint :
      object â†’ Type
  , product :
      cat.arrow (cat.product object object) object
  , unit :
      object
  }
</pre></dd>
</dl>
<h4>curry (type)</h4>
<p>{- The currying isomorphism is defined for any closed monoidal (semigroupal?)
   category (semigroupoid?), based on the â€“ âŠ— X âŠ£ Hom(X, â€“) odjunction.

   FIXME: Because closed categories are self-enriched and `Isomorphism`
          currently has to be enriched by a category where the objects are
          types, this is currently restricted to categories where the objects
          are types.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€ ( cat
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î» ( cat
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’   âˆ€(a : Type)
  â†’ âˆ€(b : Type)
  â†’ âˆ€(c : Type)
  â†’ { from :
        cat.arrow
        { _1 =
            cat.arrow { _1 = a, _2 = cat.arrow { _1 = b, _2 = c } }
        , _2 =
            cat.arrow { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
        }
    , to :
        cat.arrow
        { _1 =
            cat.arrow { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
        , _2 =
            cat.arrow { _1 = a, _2 = cat.arrow { _1 = b, _2 = c } }
        }
    }
</pre></dd>
</dl>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(vObject : Kind)
â†’ Î»(object : Kind)
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  , product :
      cat.arrow (cat.product object object) object
  , unit :
      object
  }
</pre></dd>
</dl>
<h4>Sort (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
Sort
</pre></dd>
</dl>
<h4 style="background-color: #bbb; width: 100%">./Category/Monoidal/Symmetric</h4>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ { associativity :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ âˆ€(c : object)
      â†’ { from :
            cat.arrow
            { _1 =
                cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
            , _2 =
                cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
            }
        , to :
            cat.arrow
            { _1 =
                cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
            , _2 =
                cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
            }
        }
  , braid :
        âˆ€(x : object)
      â†’ âˆ€(y : object)
      â†’ cat.arrow
        { _1 =
            cat.product { _1 = x, _2 = y }
        , _2 =
            cat.product { _1 = y, _2 = x }
        }
  , hom :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
            }
      }
  , leftIdentity :
        âˆ€(a : object)
      â†’ { from :
            cat.arrow { _1 = a, _2 = cat.product { _1 = cat.unit, _2 = a } }
        , to :
            cat.arrow { _1 = cat.product { _1 = cat.unit, _2 = a }, _2 = a }
        }
  , product :
        âˆ€(a : { _1 : object, _2 : object })
      â†’ (   âˆ€(r : Type)
          â†’ (   âˆ€(z : object)
              â†’ cat.arrow { _1 = z, _2 = a._2 }
              â†’ cat.arrow { _1 = a._1, _2 = z }
              â†’ r
            )
          â†’ r
        )
      â†’ cat.arrow a
  , rightIdentity :
        âˆ€(a : object)
      â†’ { from :
            cat.arrow { _1 = a, _2 = cat.product { _1 = a, _2 = cat.unit } }
        , to :
            cat.arrow { _1 = cat.product { _1 = a, _2 = cat.unit }, _2 = a }
        }
  , tensor :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = a._1, _2 = b._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                cat.arrow { _1 = cat.product a, _2 = cat.product b }
            }
      }
  , unit :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ { associativity :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ âˆ€(c : object)
      â†’ { from :
            cat.arrow
            { _1 =
                cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
            , _2 =
                cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
            }
        , to :
            cat.arrow
            { _1 =
                cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
            , _2 =
                cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
            }
        }
  , hom :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
            }
      }
  , leftIdentity :
        âˆ€(a : object)
      â†’ { from :
            cat.arrow { _1 = a, _2 = cat.product { _1 = cat.unit, _2 = a } }
        , to :
            cat.arrow { _1 = cat.product { _1 = cat.unit, _2 = a }, _2 = a }
        }
  , product :
        âˆ€(a : { _1 : object, _2 : object })
      â†’ (   âˆ€(r : Type)
          â†’ (   âˆ€(z : object)
              â†’ cat.arrow { _1 = z, _2 = a._2 }
              â†’ cat.arrow { _1 = a._1, _2 = z }
              â†’ r
            )
          â†’ r
        )
      â†’ cat.arrow a
  , rightIdentity :
        âˆ€(a : object)
      â†’ { from :
            cat.arrow { _1 = a, _2 = cat.product { _1 = a, _2 = cat.unit } }
        , to :
            cat.arrow { _1 = cat.product { _1 = a, _2 = cat.unit }, _2 = a }
        }
  , tensor :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = a._1, _2 = b._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                cat.arrow { _1 = cat.product a, _2 = cat.product b }
            }
      }
  , unit :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
  }
</pre></dd>
</dl>
<h4>extractCategory (term)</h4>
<p>{- FIXME: Should be able to do `monoidal.{ arrow, product }`, but Dhall doesnâ€™t like
          that for some reason.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( monoidal
    : { arrow :
          cat.arrow (cat.product object object) vObject
      , constraint :
          object â†’ Type
      , product :
          cat.arrow (cat.product object object) object
      , unit :
          object
      }
    )
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  }
</pre></dd>
</dl>
<h4>extractCategoryInstance (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€ ( category
    : { associativity :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ âˆ€(c : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                , _2 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                , _2 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                }
            }
      , hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ v.arrow
                { _1 =
                    v.product
                    { _1 =
                        cat.arrow { _1 = b._1, _2 = a._1 }
                    , _2 =
                        cat.arrow { _1 = a._2, _2 = b._2 }
                    }
                , _2 =
                    v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
                }
          }
      , leftIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow { _1 = a, _2 = cat.product { _1 = cat.unit, _2 = a } }
            , to :
                cat.arrow { _1 = cat.product { _1 = cat.unit, _2 = a }, _2 = a }
            }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , rightIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow { _1 = a, _2 = cat.product { _1 = a, _2 = cat.unit } }
            , to :
                cat.arrow { _1 = cat.product { _1 = a, _2 = cat.unit }, _2 = a }
            }
      , tensor :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ v.arrow
                { _1 =
                    v.product
                    { _1 =
                        cat.arrow { _1 = a._1, _2 = b._1 }
                    , _2 =
                        cat.arrow { _1 = a._2, _2 = b._2 }
                    }
                , _2 =
                    cat.arrow { _1 = cat.product a, _2 = cat.product b }
                }
          }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ { hom :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
            }
      }
  , product :
        âˆ€(a : { _1 : object, _2 : object })
      â†’ (   âˆ€(r : Type)
          â†’ (   âˆ€(z : object)
              â†’ cat.arrow { _1 = z, _2 = a._2 }
              â†’ cat.arrow { _1 = a._1, _2 = z }
              â†’ r
            )
          â†’ r
        )
      â†’ cat.arrow a
  , unit :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
  }
</pre></dd>
</dl>
<h4>extractSemigroupal (term)</h4>
<p>{- FIXME: Should be able to do `monoidal.{ arrow, product }`, but Dhall doesnâ€™t like
          that for some reason.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( monoidal
    : { arrow :
          cat.arrow (cat.product object object) vObject
      , constraint :
          object â†’ Type
      , product :
          cat.arrow (cat.product object object) object
      , unit :
          object
      }
    )
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  , product :
      cat.arrow (cat.product object object) object
  }
</pre></dd>
</dl>
<h4>types.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ { Adjunction :
      âˆ€(f : object â†’ object) â†’ âˆ€(g : object â†’ object) â†’ Type
  , Bifunctor :
      âˆ€(f : { _1 : object, _2 : object } â†’ object) â†’ Type
  , Category :
        âˆ€ ( v
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            , product :
                { _1 : Type, _2 : Type } â†’ Type
            , unit :
                Type
            }
          )
      â†’ âˆ€ ( cat
          : { arrow :
                { _1 : object, _2 : object } â†’ Type
            , constraint :
                object â†’ Type
            }
          )
      â†’ Type
  , Codensity :
        âˆ€ ( d
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            }
          )
      â†’ âˆ€(m : object â†’ Type)
      â†’ âˆ€(a : Type)
      â†’ Type
  , CommutativeGroup :
      âˆ€(m : object) â†’ Type
  , CommutativeMonoid :
      âˆ€(m : object) â†’ Type
  , Comonad :
      âˆ€(m : object â†’ object) â†’ Type
  , Compose :
        âˆ€(f : { _1 : object â†’ object, _2 : object â†’ object })
      â†’ âˆ€(a : object)
      â†’ object
  , Const :
      âˆ€(a : { _1 : object, _2 : object }) â†’ object
  , Costar :
      âˆ€(m : object â†’ object) â†’ âˆ€(a : { _1 : object, _2 : object }) â†’ Type
  , Coyoneda :
      âˆ€(f : object â†’ Type) â†’ âˆ€(a : object) â†’ Type
  , Day :
      âˆ€(f : { _1 : object â†’ Type, _2 : object â†’ Type }) â†’ âˆ€(a : object) â†’ Type
  , Density :
        âˆ€ ( d
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            }
          )
      â†’ âˆ€(f : object â†’ Type)
      â†’ âˆ€(a : Type)
      â†’ Type
  , Endofunctor :
      âˆ€(f : object â†’ object) â†’ Type
  , Field :
      âˆ€(m : object) â†’ Type
  , Group :
      âˆ€(m : object) â†’ Type
  , Identity :
      âˆ€(a : object) â†’ object
  , Lan :
      âˆ€(p : object â†’ object) â†’ âˆ€(f : object â†’ Type) â†’ âˆ€(a : object) â†’ Type
  , Leibniz :
      { arrow :
          âˆ€(a : { _1 : object, _2 : object }) â†’ Type
      , constraint :
          object â†’ Type
      }
  , Monad :
      âˆ€(m : object â†’ object) â†’ Type
  , Monoid :
      âˆ€(m : object) â†’ Type
  , MonoidalFunctor :
      âˆ€(f : object â†’ Type) â†’ Type
  , NaturalTransformation :
      âˆ€(f : { _1 : object â†’ object, _2 : object â†’ object }) â†’ Type
  , Profunctor :
      âˆ€(f : { _1 : object, _2 : object } â†’ Type) â†’ Type
  , Ran :
      âˆ€(p : object â†’ object) â†’ âˆ€(f : object â†’ Type) â†’ âˆ€(a : object) â†’ Type
  , Rig :
      âˆ€(m : object) â†’ Type
  , Ring :
      âˆ€(m : object) â†’ Type
  , Semigroup :
      âˆ€(m : object) â†’ Type
  , Semigroupoid :
        âˆ€ ( v
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            , product :
                { _1 : Type, _2 : Type } â†’ Type
            , unit :
                Type
            }
          )
      â†’ âˆ€ ( cat
          : { arrow :
                { _1 : object, _2 : object } â†’ Type
            , constraint :
                object â†’ Type
            }
          )
      â†’ âˆ€(m : { _1 : object, _2 : object } â†’ Type)
      â†’ Type
  , Semiring :
      âˆ€(m : object) â†’ Type
  , Star :
      âˆ€(m : object â†’ object) â†’ âˆ€(a : { _1 : object, _2 : object }) â†’ Type
  , StrongFunctor :
      âˆ€(f : object â†’ object) â†’ Type
  , Traversable :
      âˆ€(m : object â†’ object) â†’ âˆ€(f : object â†’ object) â†’ Type
  , Yoneda :
      âˆ€(f : object â†’ Type) â†’ âˆ€(a : object) â†’ Type
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Op</h3>
<h4>Kind (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ vObject
      , constraint :
          object â†’ Type
      }
    )
â†’ { arrow :
      âˆ€(a : { _1 : object, _2 : object }) â†’ vObject
  , constraint :
      object â†’ Type
  }
</pre></dd>
</dl>
<h4>category (term)</h4>
<p>{- TODO: This currently forces ğ’± = ğ’ğğ­, because of the Hom instance. It would be
         good to abstract that via composition with some symmetric category,
         like `category.product (hom.map a b) flip`.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€ ( category
    : { hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ { hom :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ âˆ€ ( f
              : { _1 :
                    cat.arrow { _1 = a._1, _2 = b._1 }
                , _2 :
                    cat.arrow { _1 = b._2, _2 = a._2 }
                }
              )
          â†’ cat.arrow { _1 = a._2, _2 = a._1 }
          â†’ cat.arrow { _1 = b._2, _2 = b._1 }
      }
  , product :
        âˆ€(a : { _1 : object, _2 : object })
      â†’ âˆ€ ( p
          :   âˆ€(r : Type)
            â†’ (   âˆ€(z : object)
                â†’ cat.arrow { _1 = a._2, _2 = z }
                â†’ cat.arrow { _1 = z, _2 = a._1 }
                â†’ r
              )
            â†’ r
          )
      â†’ cat.arrow { _1 = a._2, _2 = a._1 }
  , unit :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
  }
</pre></dd>
</dl>
<h4>categorySort (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind })
â†’ { arrow : âˆ€(a : Kind) â†’ âˆ€(b : Kind) â†’ Kind }
</pre></dd>
</dl>
<h4>duoidal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ vObject
      , constraint :
          object â†’ Type
      , diamond :
          { product : { _1 : object, _2 : object } â†’ object, unit : object }
      , star :
          { product : { _1 : object, _2 : object } â†’ object, unit : object }
      }
    )
â†’ { arrow :
      âˆ€(a : { _1 : object, _2 : object }) â†’ vObject
  , constraint :
      object â†’ Type
  , diamond :
      { product : { _1 : object, _2 : object } â†’ object, unit : object }
  , star :
      { product : { _1 : object, _2 : object } â†’ object, unit : object }
  }
</pre></dd>
</dl>
<h4>monoidal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ vObject
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ { arrow :
      âˆ€(a : { _1 : object, _2 : object }) â†’ vObject
  , constraint :
      object â†’ Type
  , product :
      { _1 : object, _2 : object } â†’ object
  , unit :
      object
  }
</pre></dd>
</dl>
<h4>semigroupal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ vObject
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ { arrow :
      âˆ€(a : { _1 : object, _2 : object }) â†’ vObject
  , constraint :
      object â†’ Type
  , product :
      { _1 : object, _2 : object } â†’ object
  }
</pre></dd>
</dl>
<h4>semigroupalSort (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ { arrow : âˆ€(a : Kind) â†’ âˆ€(b : Kind) â†’ Kind, product : Kind â†’ Kind â†’ Kind }
</pre></dd>
</dl>
<h4>types.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ { Adjunction :
      âˆ€(f : object â†’ object) â†’ âˆ€(g : object â†’ object) â†’ Type
  , Bifunctor :
      âˆ€(f : { _1 : object, _2 : object } â†’ object) â†’ Type
  , Category :
        âˆ€ ( v
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            , product :
                { _1 : Type, _2 : Type } â†’ Type
            , unit :
                Type
            }
          )
      â†’ âˆ€ ( cat
          : { arrow :
                { _1 : object, _2 : object } â†’ Type
            , constraint :
                object â†’ Type
            }
          )
      â†’ Type
  , Codensity :
        âˆ€ ( d
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            }
          )
      â†’ âˆ€(m : object â†’ Type)
      â†’ âˆ€(a : Type)
      â†’ Type
  , CommutativeGroup :
      âˆ€(m : object) â†’ Type
  , CommutativeMonoid :
      âˆ€(m : object) â†’ Type
  , Comonad :
      âˆ€(m : object â†’ object) â†’ Type
  , Compose :
        âˆ€(f : { _1 : object â†’ object, _2 : object â†’ object })
      â†’ âˆ€(a : object)
      â†’ object
  , Const :
      âˆ€(a : { _1 : object, _2 : object }) â†’ object
  , Costar :
      âˆ€(m : object â†’ object) â†’ âˆ€(a : { _1 : object, _2 : object }) â†’ Type
  , Coyoneda :
      âˆ€(f : object â†’ Type) â†’ âˆ€(a : object) â†’ Type
  , Day :
      âˆ€(f : { _1 : object â†’ Type, _2 : object â†’ Type }) â†’ âˆ€(a : object) â†’ Type
  , Density :
        âˆ€ ( d
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            }
          )
      â†’ âˆ€(f : object â†’ Type)
      â†’ âˆ€(a : Type)
      â†’ Type
  , Endofunctor :
      âˆ€(f : object â†’ object) â†’ Type
  , Field :
      âˆ€(m : object) â†’ Type
  , Group :
      âˆ€(m : object) â†’ Type
  , Identity :
      âˆ€(a : object) â†’ object
  , Lan :
      âˆ€(p : object â†’ object) â†’ âˆ€(f : object â†’ Type) â†’ âˆ€(a : object) â†’ Type
  , Leibniz :
      { arrow :
          âˆ€(a : { _1 : object, _2 : object }) â†’ Type
      , constraint :
          object â†’ Type
      }
  , Monad :
      âˆ€(m : object â†’ object) â†’ Type
  , Monoid :
      âˆ€(m : object) â†’ Type
  , MonoidalFunctor :
      âˆ€(f : object â†’ Type) â†’ Type
  , NaturalTransformation :
      âˆ€(f : { _1 : object â†’ object, _2 : object â†’ object }) â†’ Type
  , Profunctor :
      âˆ€(f : { _1 : object, _2 : object } â†’ Type) â†’ Type
  , Ran :
      âˆ€(p : object â†’ object) â†’ âˆ€(f : object â†’ Type) â†’ âˆ€(a : object) â†’ Type
  , Rig :
      âˆ€(m : object) â†’ Type
  , Ring :
      âˆ€(m : object) â†’ Type
  , Semigroup :
      âˆ€(m : object) â†’ Type
  , Semigroupoid :
        âˆ€ ( v
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            , product :
                { _1 : Type, _2 : Type } â†’ Type
            , unit :
                Type
            }
          )
      â†’ âˆ€ ( cat
          : { arrow :
                { _1 : object, _2 : object } â†’ Type
            , constraint :
                object â†’ Type
            }
          )
      â†’ âˆ€(m : { _1 : object, _2 : object } â†’ Type)
      â†’ Type
  , Semiring :
      âˆ€(m : object) â†’ Type
  , Star :
      âˆ€(m : object â†’ object) â†’ âˆ€(a : { _1 : object, _2 : object }) â†’ Type
  , StrongFunctor :
      âˆ€(f : object â†’ object) â†’ Type
  , Traversable :
      âˆ€(m : object â†’ object) â†’ âˆ€(f : object â†’ object) â†’ Type
  , Yoneda :
      âˆ€(f : object â†’ Type) â†’ âˆ€(a : object) â†’ Type
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Product</h3>
<h4>Kind (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      }
    )
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ { arrow :
        âˆ€ ( a
          : { _1 :
                { _1 : cObject, _2 : dObject }
            , _2 :
                { _1 : cObject, _2 : dObject }
            }
          )
      â†’ Type
  , constraint :
      âˆ€(x : { _1 : cObject, _2 : dObject }) â†’ Type
  }
</pre></dd>
</dl>
<h4>Type (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€(cObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      , product :
          { _1 : vObject, _2 : vObject } â†’ vObject
      , unit :
          vObject
      }
    )
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ vObject
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ vObject
      , constraint :
          dObject â†’ Type
      }
    )
â†’ { arrow :
        âˆ€ ( a
          : { _1 :
                { _1 : cObject, _2 : dObject }
            , _2 :
                { _1 : cObject, _2 : dObject }
            }
          )
      â†’ vObject
  , constraint :
      âˆ€(obj : { _1 : cObject, _2 : dObject }) â†’ Type
  }
</pre></dd>
</dl>
<h4>category (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( cCategory
    : { hom :
          { map :
                âˆ€(a : { _1 : cObject, _2 : cObject })
              â†’ âˆ€(b : { _1 : cObject, _2 : cObject })
              â†’ { _1 :
                    c.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    c.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ c.arrow a
              â†’ c.arrow b
          }
      , product :
            âˆ€(a : { _1 : cObject, _2 : cObject })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : cObject)
                  â†’ c.arrow { _1 = z, _2 = a._2 }
                  â†’ c.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ c.arrow a
      , unit :
          âˆ€(a : cObject) â†’ c.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€ ( dCategory
    : { hom :
          { map :
                âˆ€(a : { _1 : dObject, _2 : dObject })
              â†’ âˆ€(b : { _1 : dObject, _2 : dObject })
              â†’ { _1 :
                    d.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    d.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ d.arrow a
              â†’ d.arrow b
          }
      , product :
            âˆ€(a : { _1 : dObject, _2 : dObject })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : dObject)
                  â†’ d.arrow { _1 = z, _2 = a._2 }
                  â†’ d.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ d.arrow a
      , unit :
          âˆ€(a : dObject) â†’ d.arrow { _1 = a, _2 = a }
      }
    )
â†’ { hom :
      { map :
            âˆ€ ( a
              : { _1 :
                    { _1 : cObject, _2 : dObject }
                , _2 :
                    { _1 : cObject, _2 : dObject }
                }
              )
          â†’ âˆ€ ( b
              : { _1 :
                    { _1 : cObject, _2 : dObject }
                , _2 :
                    { _1 : cObject, _2 : dObject }
                }
              )
          â†’ âˆ€ ( fn
              : { _1 :
                    { _1 :
                        c.arrow { _1 = b._1._1, _2 = a._1._1 }
                    , _2 :
                        d.arrow { _1 = b._1._2, _2 = a._1._2 }
                    }
                , _2 :
                    { _1 :
                        c.arrow { _1 = a._2._1, _2 = b._2._1 }
                    , _2 :
                        d.arrow { _1 = a._2._2, _2 = b._2._2 }
                    }
                }
              )
          â†’ âˆ€ ( f
              : { _1 :
                    c.arrow { _1 = a._1._1, _2 = a._2._1 }
                , _2 :
                    d.arrow { _1 = a._1._2, _2 = a._2._2 }
                }
              )
          â†’ { _1 :
                c.arrow { _1 = b._1._1, _2 = b._2._1 }
            , _2 :
                d.arrow { _1 = b._1._2, _2 = b._2._2 }
            }
      }
  , product :
        âˆ€ ( a
          : { _1 :
                { _1 : cObject, _2 : dObject }
            , _2 :
                { _1 : cObject, _2 : dObject }
            }
          )
      â†’ âˆ€ ( p
          :   âˆ€(r : Type)
            â†’ (   âˆ€(z : { _1 : cObject, _2 : dObject })
                â†’ { _1 :
                      c.arrow { _1 = z._1, _2 = a._2._1 }
                  , _2 :
                      d.arrow { _1 = z._2, _2 = a._2._2 }
                  }
                â†’ { _1 :
                      c.arrow { _1 = a._1._1, _2 = z._1 }
                  , _2 :
                      d.arrow { _1 = a._1._2, _2 = z._2 }
                  }
                â†’ r
              )
            â†’ r
          )
      â†’ { _1 :
            c.arrow { _1 = a._1._1, _2 = a._2._1 }
        , _2 :
            d.arrow { _1 = a._1._2, _2 = a._2._2 }
        }
  , unit :
        âˆ€(a : { _1 : cObject, _2 : dObject })
      â†’ { _1 :
            c.arrow { _1 = a._1, _2 = a._1 }
        , _2 :
            d.arrow { _1 = a._2, _2 = a._2 }
        }
  }
</pre></dd>
</dl>
<h4>types.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ { Adjunction :
        âˆ€(f : { _1 : cObject, _2 : dObject } â†’ { _1 : cObject, _2 : dObject })
      â†’ âˆ€(g : { _1 : cObject, _2 : dObject } â†’ { _1 : cObject, _2 : dObject })
      â†’ Type
  , Bifunctor :
        âˆ€ ( f
          :   { _1 :
                  { _1 : cObject, _2 : dObject }
              , _2 :
                  { _1 : cObject, _2 : dObject }
              }
            â†’ { _1 : cObject, _2 : dObject }
          )
      â†’ Type
  , Category :
        âˆ€ ( v
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            , product :
                { _1 : Type, _2 : Type } â†’ Type
            , unit :
                Type
            }
          )
      â†’ âˆ€ ( cat
          : { arrow :
                  { _1 :
                      { _1 : cObject, _2 : dObject }
                  , _2 :
                      { _1 : cObject, _2 : dObject }
                  }
                â†’ Type
            , constraint :
                { _1 : cObject, _2 : dObject } â†’ Type
            }
          )
      â†’ Type
  , Codensity :
        âˆ€ ( d
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            }
          )
      â†’ âˆ€(m : { _1 : cObject, _2 : dObject } â†’ Type)
      â†’ âˆ€(a : Type)
      â†’ Type
  , Comonad :
        âˆ€(m : { _1 : cObject, _2 : dObject } â†’ { _1 : cObject, _2 : dObject })
      â†’ Type
  , Compose :
        âˆ€ ( f
          : { _1 :
                { _1 : cObject, _2 : dObject } â†’ { _1 : cObject, _2 : dObject }
            , _2 :
                { _1 : cObject, _2 : dObject } â†’ { _1 : cObject, _2 : dObject }
            }
          )
      â†’ âˆ€(a : { _1 : cObject, _2 : dObject })
      â†’ { _1 : cObject, _2 : dObject }
  , Const :
        âˆ€ ( a
          : { _1 :
                { _1 : cObject, _2 : dObject }
            , _2 :
                { _1 : cObject, _2 : dObject }
            }
          )
      â†’ { _1 : cObject, _2 : dObject }
  , Costar :
        âˆ€(m : { _1 : cObject, _2 : dObject } â†’ { _1 : cObject, _2 : dObject })
      â†’ âˆ€ ( a
          : { _1 :
                { _1 : cObject, _2 : dObject }
            , _2 :
                { _1 : cObject, _2 : dObject }
            }
          )
      â†’ Type
  , Coyoneda :
        âˆ€(f : { _1 : cObject, _2 : dObject } â†’ Type)
      â†’ âˆ€(a : { _1 : cObject, _2 : dObject })
      â†’ Type
  , Density :
        âˆ€ ( d
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            }
          )
      â†’ âˆ€(f : { _1 : cObject, _2 : dObject } â†’ Type)
      â†’ âˆ€(a : Type)
      â†’ Type
  , Endofunctor :
        âˆ€(f : { _1 : cObject, _2 : dObject } â†’ { _1 : cObject, _2 : dObject })
      â†’ Type
  , Identity :
      âˆ€(a : { _1 : cObject, _2 : dObject }) â†’ { _1 : cObject, _2 : dObject }
  , Lan :
        âˆ€(p : { _1 : cObject, _2 : dObject } â†’ { _1 : cObject, _2 : dObject })
      â†’ âˆ€(f : { _1 : cObject, _2 : dObject } â†’ Type)
      â†’ âˆ€(a : { _1 : cObject, _2 : dObject })
      â†’ Type
  , Leibniz :
      { arrow :
            âˆ€ ( a
              : { _1 :
                    { _1 : cObject, _2 : dObject }
                , _2 :
                    { _1 : cObject, _2 : dObject }
                }
              )
          â†’ Type
      , constraint :
          âˆ€(x : { _1 : cObject, _2 : dObject }) â†’ Type
      }
  , Monad :
        âˆ€(m : { _1 : cObject, _2 : dObject } â†’ { _1 : cObject, _2 : dObject })
      â†’ Type
  , NaturalTransformation :
        âˆ€ ( f
          : { _1 :
                { _1 : cObject, _2 : dObject } â†’ { _1 : cObject, _2 : dObject }
            , _2 :
                { _1 : cObject, _2 : dObject } â†’ { _1 : cObject, _2 : dObject }
            }
          )
      â†’ Type
  , Profunctor :
        âˆ€ ( f
          :   { _1 :
                  { _1 : cObject, _2 : dObject }
              , _2 :
                  { _1 : cObject, _2 : dObject }
              }
            â†’ Type
          )
      â†’ Type
  , Ran :
        âˆ€(p : { _1 : cObject, _2 : dObject } â†’ { _1 : cObject, _2 : dObject })
      â†’ âˆ€(f : { _1 : cObject, _2 : dObject } â†’ Type)
      â†’ âˆ€(a : { _1 : cObject, _2 : dObject })
      â†’ Type
  , Semigroupoid :
        âˆ€ ( v
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            , product :
                { _1 : Type, _2 : Type } â†’ Type
            , unit :
                Type
            }
          )
      â†’ âˆ€ ( cat
          : { arrow :
                  { _1 :
                      { _1 : cObject, _2 : dObject }
                  , _2 :
                      { _1 : cObject, _2 : dObject }
                  }
                â†’ Type
            , constraint :
                { _1 : cObject, _2 : dObject } â†’ Type
            }
          )
      â†’ âˆ€ ( m
          :   { _1 :
                  { _1 : cObject, _2 : dObject }
              , _2 :
                  { _1 : cObject, _2 : dObject }
              }
            â†’ Type
          )
      â†’ Type
  , Star :
        âˆ€(m : { _1 : cObject, _2 : dObject } â†’ { _1 : cObject, _2 : dObject })
      â†’ âˆ€ ( a
          : { _1 :
                { _1 : cObject, _2 : dObject }
            , _2 :
                { _1 : cObject, _2 : dObject }
            }
          )
      â†’ Type
  , Traversable :
        âˆ€(m : { _1 : cObject, _2 : dObject } â†’ { _1 : cObject, _2 : dObject })
      â†’ âˆ€(f : { _1 : cObject, _2 : dObject } â†’ { _1 : cObject, _2 : dObject })
      â†’ Type
  , Yoneda :
        âˆ€(f : { _1 : cObject, _2 : dObject } â†’ Type)
      â†’ âˆ€(a : { _1 : cObject, _2 : dObject })
      â†’ Type
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Profunctor</h3>
<h4>monoidal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€(morphism : { _1 : object, _2 : object } â†’ Type)
â†’ { arrow :
        âˆ€ ( p
          : { _1 :
                { _1 : object, _2 : object } â†’ Type
            , _2 :
                { _1 : object, _2 : object } â†’ Type
            }
          )
      â†’ Type
  , constraint :
      âˆ€(f : { _1 : object, _2 : object } â†’ Type) â†’ Type
  , product :
        âˆ€ ( p
          : { _1 :
                { _1 : object, _2 : object } â†’ Type
            , _2 :
                { _1 : object, _2 : object } â†’ Type
            }
          )
      â†’ âˆ€(a : { _1 : object, _2 : object })
      â†’ Type
  , unit :
      { _1 : object, _2 : object } â†’ Type
  }
</pre></dd>
</dl>
<h4>semigroupal (term)</h4>
<p>{- This doesnâ€™t use `extractSemigroupal` because I donâ€™t know how to apply the
  `morphism` in the monoidal category instance.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ { arrow :
        âˆ€ ( p
          : { _1 :
                { _1 : object, _2 : object } â†’ Type
            , _2 :
                { _1 : object, _2 : object } â†’ Type
            }
          )
      â†’ Type
  , constraint :
      âˆ€(f : { _1 : object, _2 : object } â†’ Type) â†’ Type
  , product :
        âˆ€ ( p
          : { _1 :
                { _1 : object, _2 : object } â†’ Type
            , _2 :
                { _1 : object, _2 : object } â†’ Type
            }
          )
      â†’ âˆ€(a : { _1 : object, _2 : object })
      â†’ Type
  }
</pre></dd>
</dl>
<h4>types.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ { Adjunction :
        âˆ€ ( f
          :   ({ _1 : object, _2 : object } â†’ Type)
            â†’ { _1 : object, _2 : object }
            â†’ Type
          )
      â†’ âˆ€ ( g
          :   ({ _1 : object, _2 : object } â†’ Type)
            â†’ { _1 : object, _2 : object }
            â†’ Type
          )
      â†’ Type
  , Bifunctor :
        âˆ€ ( f
          :   { _1 :
                  { _1 : object, _2 : object } â†’ Type
              , _2 :
                  { _1 : object, _2 : object } â†’ Type
              }
            â†’ { _1 : object, _2 : object }
            â†’ Type
          )
      â†’ Type
  , Category :
        âˆ€ ( v
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            , product :
                { _1 : Type, _2 : Type } â†’ Type
            , unit :
                Type
            }
          )
      â†’ âˆ€ ( cat
          : { arrow :
                  { _1 :
                      { _1 : object, _2 : object } â†’ Type
                  , _2 :
                      { _1 : object, _2 : object } â†’ Type
                  }
                â†’ Type
            , constraint :
                ({ _1 : object, _2 : object } â†’ Type) â†’ Type
            }
          )
      â†’ Type
  , Codensity :
        âˆ€ ( d
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            }
          )
      â†’ âˆ€(m : ({ _1 : object, _2 : object } â†’ Type) â†’ Type)
      â†’ âˆ€(a : Type)
      â†’ Type
  , Comonad :
        âˆ€ ( m
          :   ({ _1 : object, _2 : object } â†’ Type)
            â†’ { _1 : object, _2 : object }
            â†’ Type
          )
      â†’ Type
  , Compose :
        âˆ€ ( f
          : { _1 :
                  ({ _1 : object, _2 : object } â†’ Type)
                â†’ { _1 : object, _2 : object }
                â†’ Type
            , _2 :
                  ({ _1 : object, _2 : object } â†’ Type)
                â†’ { _1 : object, _2 : object }
                â†’ Type
            }
          )
      â†’ âˆ€(a : { _1 : object, _2 : object } â†’ Type)
      â†’ { _1 : object, _2 : object }
      â†’ Type
  , Const :
        âˆ€ ( a
          : { _1 :
                { _1 : object, _2 : object } â†’ Type
            , _2 :
                { _1 : object, _2 : object } â†’ Type
            }
          )
      â†’ { _1 : object, _2 : object }
      â†’ Type
  , Costar :
        âˆ€ ( m
          :   ({ _1 : object, _2 : object } â†’ Type)
            â†’ { _1 : object, _2 : object }
            â†’ Type
          )
      â†’ âˆ€ ( a
          : { _1 :
                { _1 : object, _2 : object } â†’ Type
            , _2 :
                { _1 : object, _2 : object } â†’ Type
            }
          )
      â†’ Type
  , Coyoneda :
        âˆ€(f : ({ _1 : object, _2 : object } â†’ Type) â†’ Type)
      â†’ âˆ€(a : { _1 : object, _2 : object } â†’ Type)
      â†’ Type
  , Density :
        âˆ€ ( d
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            }
          )
      â†’ âˆ€(f : ({ _1 : object, _2 : object } â†’ Type) â†’ Type)
      â†’ âˆ€(a : Type)
      â†’ Type
  , Endofunctor :
        âˆ€ ( f
          :   ({ _1 : object, _2 : object } â†’ Type)
            â†’ { _1 : object, _2 : object }
            â†’ Type
          )
      â†’ Type
  , Identity :
        âˆ€(a : { _1 : object, _2 : object } â†’ Type)
      â†’ { _1 : object, _2 : object }
      â†’ Type
  , Lan :
        âˆ€ ( p
          :   ({ _1 : object, _2 : object } â†’ Type)
            â†’ { _1 : object, _2 : object }
            â†’ Type
          )
      â†’ âˆ€(f : ({ _1 : object, _2 : object } â†’ Type) â†’ Type)
      â†’ âˆ€(a : { _1 : object, _2 : object } â†’ Type)
      â†’ Type
  , Leibniz :
      { arrow :
            âˆ€ ( a
              : { _1 :
                    { _1 : object, _2 : object } â†’ Type
                , _2 :
                    { _1 : object, _2 : object } â†’ Type
                }
              )
          â†’ Type
      , constraint :
          âˆ€(f : { _1 : object, _2 : object } â†’ Type) â†’ Type
      }
  , Monad :
        âˆ€ ( m
          :   ({ _1 : object, _2 : object } â†’ Type)
            â†’ { _1 : object, _2 : object }
            â†’ Type
          )
      â†’ Type
  , NaturalTransformation :
        âˆ€ ( f
          : { _1 :
                  ({ _1 : object, _2 : object } â†’ Type)
                â†’ { _1 : object, _2 : object }
                â†’ Type
            , _2 :
                  ({ _1 : object, _2 : object } â†’ Type)
                â†’ { _1 : object, _2 : object }
                â†’ Type
            }
          )
      â†’ Type
  , Profunctor :
        âˆ€ ( f
          :   { _1 :
                  { _1 : object, _2 : object } â†’ Type
              , _2 :
                  { _1 : object, _2 : object } â†’ Type
              }
            â†’ Type
          )
      â†’ Type
  , Ran :
        âˆ€ ( p
          :   ({ _1 : object, _2 : object } â†’ Type)
            â†’ { _1 : object, _2 : object }
            â†’ Type
          )
      â†’ âˆ€(f : ({ _1 : object, _2 : object } â†’ Type) â†’ Type)
      â†’ âˆ€(a : { _1 : object, _2 : object } â†’ Type)
      â†’ Type
  , Semigroup :
      âˆ€(m : { _1 : object, _2 : object } â†’ Type) â†’ Type
  , Semigroupoid :
        âˆ€ ( v
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            , product :
                { _1 : Type, _2 : Type } â†’ Type
            , unit :
                Type
            }
          )
      â†’ âˆ€ ( cat
          : { arrow :
                  { _1 :
                      { _1 : object, _2 : object } â†’ Type
                  , _2 :
                      { _1 : object, _2 : object } â†’ Type
                  }
                â†’ Type
            , constraint :
                ({ _1 : object, _2 : object } â†’ Type) â†’ Type
            }
          )
      â†’ âˆ€ ( m
          :   { _1 :
                  { _1 : object, _2 : object } â†’ Type
              , _2 :
                  { _1 : object, _2 : object } â†’ Type
              }
            â†’ Type
          )
      â†’ Type
  , Star :
        âˆ€ ( m
          :   ({ _1 : object, _2 : object } â†’ Type)
            â†’ { _1 : object, _2 : object }
            â†’ Type
          )
      â†’ âˆ€ ( a
          : { _1 :
                { _1 : object, _2 : object } â†’ Type
            , _2 :
                { _1 : object, _2 : object } â†’ Type
            }
          )
      â†’ Type
  , Traversable :
        âˆ€ ( m
          :   ({ _1 : object, _2 : object } â†’ Type)
            â†’ { _1 : object, _2 : object }
            â†’ Type
          )
      â†’ âˆ€ ( f
          :   ({ _1 : object, _2 : object } â†’ Type)
            â†’ { _1 : object, _2 : object }
            â†’ Type
          )
      â†’ Type
  , Yoneda :
        âˆ€(f : ({ _1 : object, _2 : object } â†’ Type) â†’ Type)
      â†’ âˆ€(a : { _1 : object, _2 : object } â†’ Type)
      â†’ Type
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Rig</h3>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(vObject : Kind)
â†’ Î»(object : Kind)
â†’ { additive :
      { product : cat.arrow (cat.product object object) object, unit : object }
  , arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  , multiplicative :
      { product : cat.arrow (cat.product object object) object, unit : object }
  }
</pre></dd>
</dl>
<h4>Sort (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
Sort
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p>{- TODO: Ideally, the additive and multiplicative monoids shouldnâ€™t _also_ have
         the category members (as they just duplicate the ones on the rig), but
  	     it was more trouble to avoid them for the time being.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { additive :
          { product : { _1 : object, _2 : object } â†’ object, unit : object }
      , arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , multiplicative :
          { product : { _1 : object, _2 : object } â†’ object, unit : object }
      }
    )
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ Î» ( cat
    : { additive :
          { product : { _1 : object, _2 : object } â†’ object, unit : object }
      , arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , multiplicative :
          { product : { _1 : object, _2 : object } â†’ object, unit : object }
      }
    )
â†’ { additive :
      { associativity :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ âˆ€(c : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    cat.additive.product
                    { _1 = a, _2 = cat.additive.product { _1 = b, _2 = c } }
                , _2 =
                    cat.additive.product
                    { _1 = cat.additive.product { _1 = a, _2 = b }, _2 = c }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.additive.product
                    { _1 = cat.additive.product { _1 = a, _2 = b }, _2 = c }
                , _2 =
                    cat.additive.product
                    { _1 = a, _2 = cat.additive.product { _1 = b, _2 = c } }
                }
            }
      , hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ v.arrow
                { _1 =
                    v.product
                    { _1 =
                        cat.arrow { _1 = b._1, _2 = a._1 }
                    , _2 =
                        cat.arrow { _1 = a._2, _2 = b._2 }
                    }
                , _2 =
                    v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
                }
          }
      , leftIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    a
                , _2 =
                    cat.additive.product { _1 = cat.additive.unit, _2 = a }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.additive.product { _1 = cat.additive.unit, _2 = a }
                , _2 =
                    a
                }
            }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , rightIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    a
                , _2 =
                    cat.additive.product { _1 = a, _2 = cat.additive.unit }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.additive.product { _1 = a, _2 = cat.additive.unit }
                , _2 =
                    a
                }
            }
      , tensor :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ v.arrow
                { _1 =
                    v.product
                    { _1 =
                        cat.arrow { _1 = a._1, _2 = b._1 }
                    , _2 =
                        cat.arrow { _1 = a._2, _2 = b._2 }
                    }
                , _2 =
                    cat.arrow
                    { _1 = cat.additive.product a, _2 = cat.additive.product b }
                }
          }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
  , distributivity :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ âˆ€(c : object)
      â†’ { from :
            cat.arrow
            { _1 =
                cat.additive.product
                { _1 =
                    cat.multiplicative.product { _1 = a, _2 = b }
                , _2 =
                    cat.multiplicative.product { _1 = a, _2 = c }
                }
            , _2 =
                cat.multiplicative.product
                { _1 = a, _2 = cat.additive.product { _1 = b, _2 = c } }
            }
        , to :
            cat.arrow
            { _1 =
                cat.multiplicative.product
                { _1 = a, _2 = cat.additive.product { _1 = b, _2 = c } }
            , _2 =
                cat.additive.product
                { _1 =
                    cat.multiplicative.product { _1 = a, _2 = b }
                , _2 =
                    cat.multiplicative.product { _1 = a, _2 = c }
                }
            }
        }
  , hom :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
            }
      }
  , leftAnnihilation :
        âˆ€(a : object)
      â†’ { from :
            cat.arrow
            { _1 =
                cat.additive.unit
            , _2 =
                cat.multiplicative.product { _1 = cat.additive.unit, _2 = a }
            }
        , to :
            cat.arrow
            { _1 =
                cat.multiplicative.product { _1 = cat.additive.unit, _2 = a }
            , _2 =
                cat.additive.unit
            }
        }
  , multiplicative :
      { associativity :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ âˆ€(c : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    cat.multiplicative.product
                    { _1 =
                        a
                    , _2 =
                        cat.multiplicative.product { _1 = b, _2 = c }
                    }
                , _2 =
                    cat.multiplicative.product
                    { _1 =
                        cat.multiplicative.product { _1 = a, _2 = b }
                    , _2 =
                        c
                    }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.multiplicative.product
                    { _1 =
                        cat.multiplicative.product { _1 = a, _2 = b }
                    , _2 =
                        c
                    }
                , _2 =
                    cat.multiplicative.product
                    { _1 =
                        a
                    , _2 =
                        cat.multiplicative.product { _1 = b, _2 = c }
                    }
                }
            }
      , hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ v.arrow
                { _1 =
                    v.product
                    { _1 =
                        cat.arrow { _1 = b._1, _2 = a._1 }
                    , _2 =
                        cat.arrow { _1 = a._2, _2 = b._2 }
                    }
                , _2 =
                    v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
                }
          }
      , leftIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    a
                , _2 =
                    cat.multiplicative.product
                    { _1 = cat.multiplicative.unit, _2 = a }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.multiplicative.product
                    { _1 = cat.multiplicative.unit, _2 = a }
                , _2 =
                    a
                }
            }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , rightIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    a
                , _2 =
                    cat.multiplicative.product
                    { _1 = a, _2 = cat.multiplicative.unit }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.multiplicative.product
                    { _1 = a, _2 = cat.multiplicative.unit }
                , _2 =
                    a
                }
            }
      , tensor :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ v.arrow
                { _1 =
                    v.product
                    { _1 =
                        cat.arrow { _1 = a._1, _2 = b._1 }
                    , _2 =
                        cat.arrow { _1 = a._2, _2 = b._2 }
                    }
                , _2 =
                    cat.arrow
                    { _1 =
                        cat.multiplicative.product a
                    , _2 =
                        cat.multiplicative.product b
                    }
                }
          }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
  , product :
        âˆ€(a : { _1 : object, _2 : object })
      â†’ (   âˆ€(r : Type)
          â†’ (   âˆ€(z : object)
              â†’ cat.arrow { _1 = z, _2 = a._2 }
              â†’ cat.arrow { _1 = a._1, _2 = z }
              â†’ r
            )
          â†’ r
        )
      â†’ cat.arrow a
  , rightAnnihilation :
        âˆ€(a : object)
      â†’ { from :
            cat.arrow
            { _1 =
                cat.additive.unit
            , _2 =
                cat.multiplicative.product { _1 = a, _2 = cat.additive.unit }
            }
        , to :
            cat.arrow
            { _1 =
                cat.multiplicative.product { _1 = a, _2 = cat.additive.unit }
            , _2 =
                cat.additive.unit
            }
        }
  , unit :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
  }
</pre></dd>
</dl>
<h4>extractAdditive (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( rig
    : { additive :
          { product :
              cat.arrow (cat.product object object) object
          , unit :
              object
          }
      , arrow :
          cat.arrow (cat.product object object) vObject
      , constraint :
          object â†’ Type
      , multiplicative :
          { product :
              cat.arrow (cat.product object object) object
          , unit :
              object
          }
      }
    )
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  , product :
      cat.arrow (cat.product object object) object
  , unit :
      object
  }
</pre></dd>
</dl>
<h4>extractAdditiveInstance (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { additive :
          { product : { _1 : object, _2 : object } â†’ object, unit : object }
      , arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , multiplicative :
          { product : { _1 : object, _2 : object } â†’ object, unit : object }
      }
    )
â†’ âˆ€ ( rig
    : { additive :
          { associativity :
                âˆ€(a : object)
              â†’ âˆ€(b : object)
              â†’ âˆ€(c : object)
              â†’ { from :
                    cat.arrow
                    { _1 =
                        cat.additive.product
                        { _1 = a, _2 = cat.additive.product { _1 = b, _2 = c } }
                    , _2 =
                        cat.additive.product
                        { _1 = cat.additive.product { _1 = a, _2 = b }, _2 = c }
                    }
                , to :
                    cat.arrow
                    { _1 =
                        cat.additive.product
                        { _1 = cat.additive.product { _1 = a, _2 = b }, _2 = c }
                    , _2 =
                        cat.additive.product
                        { _1 = a, _2 = cat.additive.product { _1 = b, _2 = c } }
                    }
                }
          , hom :
              { map :
                    âˆ€(a : { _1 : object, _2 : object })
                  â†’ âˆ€(b : { _1 : object, _2 : object })
                  â†’ v.arrow
                    { _1 =
                        v.product
                        { _1 =
                            cat.arrow { _1 = b._1, _2 = a._1 }
                        , _2 =
                            cat.arrow { _1 = a._2, _2 = b._2 }
                        }
                    , _2 =
                        v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
                    }
              }
          , leftIdentity :
                âˆ€(a : object)
              â†’ { from :
                    cat.arrow
                    { _1 =
                        a
                    , _2 =
                        cat.additive.product { _1 = cat.additive.unit, _2 = a }
                    }
                , to :
                    cat.arrow
                    { _1 =
                        cat.additive.product { _1 = cat.additive.unit, _2 = a }
                    , _2 =
                        a
                    }
                }
          , product :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ (   âˆ€(r : Type)
                  â†’ (   âˆ€(z : object)
                      â†’ cat.arrow { _1 = z, _2 = a._2 }
                      â†’ cat.arrow { _1 = a._1, _2 = z }
                      â†’ r
                    )
                  â†’ r
                )
              â†’ cat.arrow a
          , rightIdentity :
                âˆ€(a : object)
              â†’ { from :
                    cat.arrow
                    { _1 =
                        a
                    , _2 =
                        cat.additive.product { _1 = a, _2 = cat.additive.unit }
                    }
                , to :
                    cat.arrow
                    { _1 =
                        cat.additive.product { _1 = a, _2 = cat.additive.unit }
                    , _2 =
                        a
                    }
                }
          , tensor :
              { map :
                    âˆ€(a : { _1 : object, _2 : object })
                  â†’ âˆ€(b : { _1 : object, _2 : object })
                  â†’ v.arrow
                    { _1 =
                        v.product
                        { _1 =
                            cat.arrow { _1 = a._1, _2 = b._1 }
                        , _2 =
                            cat.arrow { _1 = a._2, _2 = b._2 }
                        }
                    , _2 =
                        cat.arrow
                        { _1 =
                            cat.additive.product a
                        , _2 =
                            cat.additive.product b
                        }
                    }
              }
          , unit :
              âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
          }
      , distributivity :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ âˆ€(c : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    cat.additive.product
                    { _1 =
                        cat.multiplicative.product { _1 = a, _2 = b }
                    , _2 =
                        cat.multiplicative.product { _1 = a, _2 = c }
                    }
                , _2 =
                    cat.multiplicative.product
                    { _1 = a, _2 = cat.additive.product { _1 = b, _2 = c } }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.multiplicative.product
                    { _1 = a, _2 = cat.additive.product { _1 = b, _2 = c } }
                , _2 =
                    cat.additive.product
                    { _1 =
                        cat.multiplicative.product { _1 = a, _2 = b }
                    , _2 =
                        cat.multiplicative.product { _1 = a, _2 = c }
                    }
                }
            }
      , hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ v.arrow
                { _1 =
                    v.product
                    { _1 =
                        cat.arrow { _1 = b._1, _2 = a._1 }
                    , _2 =
                        cat.arrow { _1 = a._2, _2 = b._2 }
                    }
                , _2 =
                    v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
                }
          }
      , leftAnnihilation :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    cat.additive.unit
                , _2 =
                    cat.multiplicative.product
                    { _1 = cat.additive.unit, _2 = a }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.multiplicative.product
                    { _1 = cat.additive.unit, _2 = a }
                , _2 =
                    cat.additive.unit
                }
            }
      , multiplicative :
          { associativity :
                âˆ€(a : object)
              â†’ âˆ€(b : object)
              â†’ âˆ€(c : object)
              â†’ { from :
                    cat.arrow
                    { _1 =
                        cat.multiplicative.product
                        { _1 =
                            a
                        , _2 =
                            cat.multiplicative.product { _1 = b, _2 = c }
                        }
                    , _2 =
                        cat.multiplicative.product
                        { _1 =
                            cat.multiplicative.product { _1 = a, _2 = b }
                        , _2 =
                            c
                        }
                    }
                , to :
                    cat.arrow
                    { _1 =
                        cat.multiplicative.product
                        { _1 =
                            cat.multiplicative.product { _1 = a, _2 = b }
                        , _2 =
                            c
                        }
                    , _2 =
                        cat.multiplicative.product
                        { _1 =
                            a
                        , _2 =
                            cat.multiplicative.product { _1 = b, _2 = c }
                        }
                    }
                }
          , hom :
              { map :
                    âˆ€(a : { _1 : object, _2 : object })
                  â†’ âˆ€(b : { _1 : object, _2 : object })
                  â†’ v.arrow
                    { _1 =
                        v.product
                        { _1 =
                            cat.arrow { _1 = b._1, _2 = a._1 }
                        , _2 =
                            cat.arrow { _1 = a._2, _2 = b._2 }
                        }
                    , _2 =
                        v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
                    }
              }
          , leftIdentity :
                âˆ€(a : object)
              â†’ { from :
                    cat.arrow
                    { _1 =
                        a
                    , _2 =
                        cat.multiplicative.product
                        { _1 = cat.multiplicative.unit, _2 = a }
                    }
                , to :
                    cat.arrow
                    { _1 =
                        cat.multiplicative.product
                        { _1 = cat.multiplicative.unit, _2 = a }
                    , _2 =
                        a
                    }
                }
          , product :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ (   âˆ€(r : Type)
                  â†’ (   âˆ€(z : object)
                      â†’ cat.arrow { _1 = z, _2 = a._2 }
                      â†’ cat.arrow { _1 = a._1, _2 = z }
                      â†’ r
                    )
                  â†’ r
                )
              â†’ cat.arrow a
          , rightIdentity :
                âˆ€(a : object)
              â†’ { from :
                    cat.arrow
                    { _1 =
                        a
                    , _2 =
                        cat.multiplicative.product
                        { _1 = a, _2 = cat.multiplicative.unit }
                    }
                , to :
                    cat.arrow
                    { _1 =
                        cat.multiplicative.product
                        { _1 = a, _2 = cat.multiplicative.unit }
                    , _2 =
                        a
                    }
                }
          , tensor :
              { map :
                    âˆ€(a : { _1 : object, _2 : object })
                  â†’ âˆ€(b : { _1 : object, _2 : object })
                  â†’ v.arrow
                    { _1 =
                        v.product
                        { _1 =
                            cat.arrow { _1 = a._1, _2 = b._1 }
                        , _2 =
                            cat.arrow { _1 = a._2, _2 = b._2 }
                        }
                    , _2 =
                        cat.arrow
                        { _1 =
                            cat.multiplicative.product a
                        , _2 =
                            cat.multiplicative.product b
                        }
                    }
              }
          , unit :
              âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , rightAnnihilation :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    cat.additive.unit
                , _2 =
                    cat.multiplicative.product
                    { _1 = a, _2 = cat.additive.unit }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.multiplicative.product
                    { _1 = a, _2 = cat.additive.unit }
                , _2 =
                    cat.additive.unit
                }
            }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ { associativity :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ âˆ€(c : object)
      â†’ { from :
            cat.arrow
            { _1 =
                cat.additive.product
                { _1 = a, _2 = cat.additive.product { _1 = b, _2 = c } }
            , _2 =
                cat.additive.product
                { _1 = cat.additive.product { _1 = a, _2 = b }, _2 = c }
            }
        , to :
            cat.arrow
            { _1 =
                cat.additive.product
                { _1 = cat.additive.product { _1 = a, _2 = b }, _2 = c }
            , _2 =
                cat.additive.product
                { _1 = a, _2 = cat.additive.product { _1 = b, _2 = c } }
            }
        }
  , hom :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
            }
      }
  , leftIdentity :
        âˆ€(a : object)
      â†’ { from :
            cat.arrow
            { _1 =
                a
            , _2 =
                cat.additive.product { _1 = cat.additive.unit, _2 = a }
            }
        , to :
            cat.arrow
            { _1 =
                cat.additive.product { _1 = cat.additive.unit, _2 = a }
            , _2 =
                a
            }
        }
  , product :
        âˆ€(a : { _1 : object, _2 : object })
      â†’ (   âˆ€(r : Type)
          â†’ (   âˆ€(z : object)
              â†’ cat.arrow { _1 = z, _2 = a._2 }
              â†’ cat.arrow { _1 = a._1, _2 = z }
              â†’ r
            )
          â†’ r
        )
      â†’ cat.arrow a
  , rightIdentity :
        âˆ€(a : object)
      â†’ { from :
            cat.arrow
            { _1 =
                a
            , _2 =
                cat.additive.product { _1 = a, _2 = cat.additive.unit }
            }
        , to :
            cat.arrow
            { _1 =
                cat.additive.product { _1 = a, _2 = cat.additive.unit }
            , _2 =
                a
            }
        }
  , tensor :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = a._1, _2 = b._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                cat.arrow
                { _1 = cat.additive.product a, _2 = cat.additive.product b }
            }
      }
  , unit :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
  }
</pre></dd>
</dl>
<h4>extractCategory (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( rig
    : { additive :
          { product :
              cat.arrow (cat.product object object) object
          , unit :
              object
          }
      , arrow :
          cat.arrow (cat.product object object) vObject
      , constraint :
          object â†’ Type
      , multiplicative :
          { product :
              cat.arrow (cat.product object object) object
          , unit :
              object
          }
      }
    )
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  }
</pre></dd>
</dl>
<h4>extractMultiplicative (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( rig
    : { additive :
          { product :
              cat.arrow (cat.product object object) object
          , unit :
              object
          }
      , arrow :
          cat.arrow (cat.product object object) vObject
      , constraint :
          object â†’ Type
      , multiplicative :
          { product :
              cat.arrow (cat.product object object) object
          , unit :
              object
          }
      }
    )
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  , product :
      cat.arrow (cat.product object object) object
  , unit :
      object
  }
</pre></dd>
</dl>
<h4>extractMultiplicativeInstance (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { additive :
          { product : { _1 : object, _2 : object } â†’ object, unit : object }
      , arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , multiplicative :
          { product : { _1 : object, _2 : object } â†’ object, unit : object }
      }
    )
â†’ âˆ€ ( rig
    : { additive :
          { associativity :
                âˆ€(a : object)
              â†’ âˆ€(b : object)
              â†’ âˆ€(c : object)
              â†’ { from :
                    cat.arrow
                    { _1 =
                        cat.additive.product
                        { _1 = a, _2 = cat.additive.product { _1 = b, _2 = c } }
                    , _2 =
                        cat.additive.product
                        { _1 = cat.additive.product { _1 = a, _2 = b }, _2 = c }
                    }
                , to :
                    cat.arrow
                    { _1 =
                        cat.additive.product
                        { _1 = cat.additive.product { _1 = a, _2 = b }, _2 = c }
                    , _2 =
                        cat.additive.product
                        { _1 = a, _2 = cat.additive.product { _1 = b, _2 = c } }
                    }
                }
          , hom :
              { map :
                    âˆ€(a : { _1 : object, _2 : object })
                  â†’ âˆ€(b : { _1 : object, _2 : object })
                  â†’ v.arrow
                    { _1 =
                        v.product
                        { _1 =
                            cat.arrow { _1 = b._1, _2 = a._1 }
                        , _2 =
                            cat.arrow { _1 = a._2, _2 = b._2 }
                        }
                    , _2 =
                        v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
                    }
              }
          , leftIdentity :
                âˆ€(a : object)
              â†’ { from :
                    cat.arrow
                    { _1 =
                        a
                    , _2 =
                        cat.additive.product { _1 = cat.additive.unit, _2 = a }
                    }
                , to :
                    cat.arrow
                    { _1 =
                        cat.additive.product { _1 = cat.additive.unit, _2 = a }
                    , _2 =
                        a
                    }
                }
          , product :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ (   âˆ€(r : Type)
                  â†’ (   âˆ€(z : object)
                      â†’ cat.arrow { _1 = z, _2 = a._2 }
                      â†’ cat.arrow { _1 = a._1, _2 = z }
                      â†’ r
                    )
                  â†’ r
                )
              â†’ cat.arrow a
          , rightIdentity :
                âˆ€(a : object)
              â†’ { from :
                    cat.arrow
                    { _1 =
                        a
                    , _2 =
                        cat.additive.product { _1 = a, _2 = cat.additive.unit }
                    }
                , to :
                    cat.arrow
                    { _1 =
                        cat.additive.product { _1 = a, _2 = cat.additive.unit }
                    , _2 =
                        a
                    }
                }
          , tensor :
              { map :
                    âˆ€(a : { _1 : object, _2 : object })
                  â†’ âˆ€(b : { _1 : object, _2 : object })
                  â†’ v.arrow
                    { _1 =
                        v.product
                        { _1 =
                            cat.arrow { _1 = a._1, _2 = b._1 }
                        , _2 =
                            cat.arrow { _1 = a._2, _2 = b._2 }
                        }
                    , _2 =
                        cat.arrow
                        { _1 =
                            cat.additive.product a
                        , _2 =
                            cat.additive.product b
                        }
                    }
              }
          , unit :
              âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
          }
      , distributivity :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ âˆ€(c : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    cat.additive.product
                    { _1 =
                        cat.multiplicative.product { _1 = a, _2 = b }
                    , _2 =
                        cat.multiplicative.product { _1 = a, _2 = c }
                    }
                , _2 =
                    cat.multiplicative.product
                    { _1 = a, _2 = cat.additive.product { _1 = b, _2 = c } }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.multiplicative.product
                    { _1 = a, _2 = cat.additive.product { _1 = b, _2 = c } }
                , _2 =
                    cat.additive.product
                    { _1 =
                        cat.multiplicative.product { _1 = a, _2 = b }
                    , _2 =
                        cat.multiplicative.product { _1 = a, _2 = c }
                    }
                }
            }
      , hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ v.arrow
                { _1 =
                    v.product
                    { _1 =
                        cat.arrow { _1 = b._1, _2 = a._1 }
                    , _2 =
                        cat.arrow { _1 = a._2, _2 = b._2 }
                    }
                , _2 =
                    v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
                }
          }
      , leftAnnihilation :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    cat.additive.unit
                , _2 =
                    cat.multiplicative.product
                    { _1 = cat.additive.unit, _2 = a }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.multiplicative.product
                    { _1 = cat.additive.unit, _2 = a }
                , _2 =
                    cat.additive.unit
                }
            }
      , multiplicative :
          { associativity :
                âˆ€(a : object)
              â†’ âˆ€(b : object)
              â†’ âˆ€(c : object)
              â†’ { from :
                    cat.arrow
                    { _1 =
                        cat.multiplicative.product
                        { _1 =
                            a
                        , _2 =
                            cat.multiplicative.product { _1 = b, _2 = c }
                        }
                    , _2 =
                        cat.multiplicative.product
                        { _1 =
                            cat.multiplicative.product { _1 = a, _2 = b }
                        , _2 =
                            c
                        }
                    }
                , to :
                    cat.arrow
                    { _1 =
                        cat.multiplicative.product
                        { _1 =
                            cat.multiplicative.product { _1 = a, _2 = b }
                        , _2 =
                            c
                        }
                    , _2 =
                        cat.multiplicative.product
                        { _1 =
                            a
                        , _2 =
                            cat.multiplicative.product { _1 = b, _2 = c }
                        }
                    }
                }
          , hom :
              { map :
                    âˆ€(a : { _1 : object, _2 : object })
                  â†’ âˆ€(b : { _1 : object, _2 : object })
                  â†’ v.arrow
                    { _1 =
                        v.product
                        { _1 =
                            cat.arrow { _1 = b._1, _2 = a._1 }
                        , _2 =
                            cat.arrow { _1 = a._2, _2 = b._2 }
                        }
                    , _2 =
                        v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
                    }
              }
          , leftIdentity :
                âˆ€(a : object)
              â†’ { from :
                    cat.arrow
                    { _1 =
                        a
                    , _2 =
                        cat.multiplicative.product
                        { _1 = cat.multiplicative.unit, _2 = a }
                    }
                , to :
                    cat.arrow
                    { _1 =
                        cat.multiplicative.product
                        { _1 = cat.multiplicative.unit, _2 = a }
                    , _2 =
                        a
                    }
                }
          , product :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ (   âˆ€(r : Type)
                  â†’ (   âˆ€(z : object)
                      â†’ cat.arrow { _1 = z, _2 = a._2 }
                      â†’ cat.arrow { _1 = a._1, _2 = z }
                      â†’ r
                    )
                  â†’ r
                )
              â†’ cat.arrow a
          , rightIdentity :
                âˆ€(a : object)
              â†’ { from :
                    cat.arrow
                    { _1 =
                        a
                    , _2 =
                        cat.multiplicative.product
                        { _1 = a, _2 = cat.multiplicative.unit }
                    }
                , to :
                    cat.arrow
                    { _1 =
                        cat.multiplicative.product
                        { _1 = a, _2 = cat.multiplicative.unit }
                    , _2 =
                        a
                    }
                }
          , tensor :
              { map :
                    âˆ€(a : { _1 : object, _2 : object })
                  â†’ âˆ€(b : { _1 : object, _2 : object })
                  â†’ v.arrow
                    { _1 =
                        v.product
                        { _1 =
                            cat.arrow { _1 = a._1, _2 = b._1 }
                        , _2 =
                            cat.arrow { _1 = a._2, _2 = b._2 }
                        }
                    , _2 =
                        cat.arrow
                        { _1 =
                            cat.multiplicative.product a
                        , _2 =
                            cat.multiplicative.product b
                        }
                    }
              }
          , unit :
              âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , rightAnnihilation :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    cat.additive.unit
                , _2 =
                    cat.multiplicative.product
                    { _1 = a, _2 = cat.additive.unit }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.multiplicative.product
                    { _1 = a, _2 = cat.additive.unit }
                , _2 =
                    cat.additive.unit
                }
            }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ { associativity :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ âˆ€(c : object)
      â†’ { from :
            cat.arrow
            { _1 =
                cat.multiplicative.product
                { _1 = a, _2 = cat.multiplicative.product { _1 = b, _2 = c } }
            , _2 =
                cat.multiplicative.product
                { _1 = cat.multiplicative.product { _1 = a, _2 = b }, _2 = c }
            }
        , to :
            cat.arrow
            { _1 =
                cat.multiplicative.product
                { _1 = cat.multiplicative.product { _1 = a, _2 = b }, _2 = c }
            , _2 =
                cat.multiplicative.product
                { _1 = a, _2 = cat.multiplicative.product { _1 = b, _2 = c } }
            }
        }
  , hom :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
            }
      }
  , leftIdentity :
        âˆ€(a : object)
      â†’ { from :
            cat.arrow
            { _1 =
                a
            , _2 =
                cat.multiplicative.product
                { _1 = cat.multiplicative.unit, _2 = a }
            }
        , to :
            cat.arrow
            { _1 =
                cat.multiplicative.product
                { _1 = cat.multiplicative.unit, _2 = a }
            , _2 =
                a
            }
        }
  , product :
        âˆ€(a : { _1 : object, _2 : object })
      â†’ (   âˆ€(r : Type)
          â†’ (   âˆ€(z : object)
              â†’ cat.arrow { _1 = z, _2 = a._2 }
              â†’ cat.arrow { _1 = a._1, _2 = z }
              â†’ r
            )
          â†’ r
        )
      â†’ cat.arrow a
  , rightIdentity :
        âˆ€(a : object)
      â†’ { from :
            cat.arrow
            { _1 =
                a
            , _2 =
                cat.multiplicative.product
                { _1 = a, _2 = cat.multiplicative.unit }
            }
        , to :
            cat.arrow
            { _1 =
                cat.multiplicative.product
                { _1 = a, _2 = cat.multiplicative.unit }
            , _2 =
                a
            }
        }
  , tensor :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = a._1, _2 = b._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                cat.arrow
                { _1 =
                    cat.multiplicative.product a
                , _2 =
                    cat.multiplicative.product b
                }
            }
      }
  , unit :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Semigroupal</h3>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(vObject : Kind)
â†’ Î»(object : Kind)
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  , product :
      cat.arrow (cat.product object object) object
  }
</pre></dd>
</dl>
<h4>Sort (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
Sort
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ { associativity :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ âˆ€(c : object)
      â†’ { from :
            cat.arrow
            { _1 =
                cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
            , _2 =
                cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
            }
        , to :
            cat.arrow
            { _1 =
                cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
            , _2 =
                cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
            }
        }
  , hom :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
            }
      }
  , product :
        âˆ€(a : { _1 : object, _2 : object })
      â†’ (   âˆ€(r : Type)
          â†’ (   âˆ€(z : object)
              â†’ cat.arrow { _1 = z, _2 = a._2 }
              â†’ cat.arrow { _1 = a._1, _2 = z }
              â†’ r
            )
          â†’ r
        )
      â†’ cat.arrow a
  , tensor :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = a._1, _2 = b._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                cat.arrow { _1 = cat.product a, _2 = cat.product b }
            }
      }
  , unit :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
  }
</pre></dd>
</dl>
<h4>extractCategory (term)</h4>
<p>{- FIXME: Should be able to do `semigroupal.{ arrow, product }`, but Dhall doesnâ€™t like
          that for some reason.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( semigroupal
    : { arrow :
          cat.arrow (cat.product object object) vObject
      , constraint :
          object â†’ Type
      , product :
          cat.arrow (cat.product object object) object
      }
    )
â†’ { arrow :
      cat.arrow (cat.product object object) vObject
  , constraint :
      object â†’ Type
  }
</pre></dd>
</dl>
<h4>extractCategoryInstance (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ âˆ€ ( category
    : { associativity :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ âˆ€(c : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                , _2 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                , _2 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                }
            }
      , hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ v.arrow
                { _1 =
                    v.product
                    { _1 =
                        cat.arrow { _1 = b._1, _2 = a._1 }
                    , _2 =
                        cat.arrow { _1 = a._2, _2 = b._2 }
                    }
                , _2 =
                    v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
                }
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , tensor :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ v.arrow
                { _1 =
                    v.product
                    { _1 =
                        cat.arrow { _1 = a._1, _2 = b._1 }
                    , _2 =
                        cat.arrow { _1 = a._2, _2 = b._2 }
                    }
                , _2 =
                    cat.arrow { _1 = cat.product a, _2 = cat.product b }
                }
          }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ { hom :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
            }
      }
  , product :
        âˆ€(a : { _1 : object, _2 : object })
      â†’ (   âˆ€(r : Type)
          â†’ (   âˆ€(z : object)
              â†’ cat.arrow { _1 = z, _2 = a._2 }
              â†’ cat.arrow { _1 = a._1, _2 = z }
              â†’ r
            )
          â†’ r
        )
      â†’ cat.arrow a
  , unit :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
  }
</pre></dd>
</dl>
<h4>extractCategorySort (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(semigroupal : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ { arrow : Kind â†’ Kind â†’ Kind }
</pre></dd>
</dl>
<h4>types.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ { Adjunction :
      âˆ€(f : object â†’ object) â†’ âˆ€(g : object â†’ object) â†’ Type
  , Bifunctor :
      âˆ€(f : { _1 : object, _2 : object } â†’ object) â†’ Type
  , Category :
        âˆ€ ( v
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            , product :
                { _1 : Type, _2 : Type } â†’ Type
            , unit :
                Type
            }
          )
      â†’ âˆ€ ( cat
          : { arrow :
                { _1 : object, _2 : object } â†’ Type
            , constraint :
                object â†’ Type
            }
          )
      â†’ Type
  , Codensity :
        âˆ€ ( d
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            }
          )
      â†’ âˆ€(m : object â†’ Type)
      â†’ âˆ€(a : Type)
      â†’ Type
  , Comonad :
      âˆ€(m : object â†’ object) â†’ Type
  , Compose :
        âˆ€(f : { _1 : object â†’ object, _2 : object â†’ object })
      â†’ âˆ€(a : object)
      â†’ object
  , Const :
      âˆ€(a : { _1 : object, _2 : object }) â†’ object
  , Costar :
      âˆ€(m : object â†’ object) â†’ âˆ€(a : { _1 : object, _2 : object }) â†’ Type
  , Coyoneda :
      âˆ€(f : object â†’ Type) â†’ âˆ€(a : object) â†’ Type
  , Density :
        âˆ€ ( d
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            }
          )
      â†’ âˆ€(f : object â†’ Type)
      â†’ âˆ€(a : Type)
      â†’ Type
  , Endofunctor :
      âˆ€(f : object â†’ object) â†’ Type
  , Identity :
      âˆ€(a : object) â†’ object
  , Lan :
      âˆ€(p : object â†’ object) â†’ âˆ€(f : object â†’ Type) â†’ âˆ€(a : object) â†’ Type
  , Leibniz :
      { arrow :
          âˆ€(a : { _1 : object, _2 : object }) â†’ Type
      , constraint :
          object â†’ Type
      }
  , Monad :
      âˆ€(m : object â†’ object) â†’ Type
  , NaturalTransformation :
      âˆ€(f : { _1 : object â†’ object, _2 : object â†’ object }) â†’ Type
  , Profunctor :
      âˆ€(f : { _1 : object, _2 : object } â†’ Type) â†’ Type
  , Ran :
      âˆ€(p : object â†’ object) â†’ âˆ€(f : object â†’ Type) â†’ âˆ€(a : object) â†’ Type
  , Semigroup :
      âˆ€(m : object) â†’ Type
  , Semigroupoid :
        âˆ€ ( v
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            , product :
                { _1 : Type, _2 : Type } â†’ Type
            , unit :
                Type
            }
          )
      â†’ âˆ€ ( cat
          : { arrow :
                { _1 : object, _2 : object } â†’ Type
            , constraint :
                object â†’ Type
            }
          )
      â†’ âˆ€(m : { _1 : object, _2 : object } â†’ Type)
      â†’ Type
  , Star :
      âˆ€(m : object â†’ object) â†’ âˆ€(a : { _1 : object, _2 : object }) â†’ Type
  , Traversable :
      âˆ€(m : object â†’ object) â†’ âˆ€(f : object â†’ object) â†’ Type
  , Yoneda :
      âˆ€(f : object â†’ Type) â†’ âˆ€(a : object) â†’ Type
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Category/Set</h3>
<h4 style="background-color: #bbb; width: 100%">./Category/Set/category</h4>
<h4>instance (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ hom :
    { map :
          âˆ€(a : { _1 : Type, _2 : Type })
        â†’ âˆ€(b : { _1 : Type, _2 : Type })
        â†’ âˆ€(f : { _1 : b._1 â†’ a._1, _2 : a._2 â†’ b._2 })
        â†’ âˆ€(fn : a._1 â†’ a._2)
        â†’ âˆ€(x : b._1)
        â†’ b._2
    }
, product :
      âˆ€(a : { _1 : Type, _2 : Type })
    â†’ âˆ€(p : âˆ€(r : Type) â†’ (âˆ€(z : Type) â†’ (z â†’ a._2) â†’ (a._1 â†’ z) â†’ r) â†’ r)
    â†’ a._1
    â†’ a._2
, unit :
    âˆ€(a : Type) â†’ âˆ€(x : a) â†’ a
}
</pre></dd>
</dl>
<h4>monoidal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ associativity :
      âˆ€(a : Type)
    â†’ âˆ€(b : Type)
    â†’ âˆ€(c : Type)
    â†’ { from :
            âˆ€(p : { _1 : a, _2 : { _1 : b, _2 : c } })
          â†’ { _1 : { _1 : a, _2 : b }, _2 : c }
      , to :
            âˆ€(p : { _1 : { _1 : a, _2 : b }, _2 : c })
          â†’ { _1 : a, _2 : { _1 : b, _2 : c } }
      }
, hom :
    { map :
          âˆ€(a : { _1 : Type, _2 : Type })
        â†’ âˆ€(b : { _1 : Type, _2 : Type })
        â†’ âˆ€(f : { _1 : b._1 â†’ a._1, _2 : a._2 â†’ b._2 })
        â†’ âˆ€(fn : a._1 â†’ a._2)
        â†’ âˆ€(x : b._1)
        â†’ b._2
    }
, leftIdentity :
      âˆ€(a : Type)
    â†’ { from :
          âˆ€(x : a) â†’ { _1 : {}, _2 : a }
      , to :
          âˆ€(p : { _1 : {}, _2 : a }) â†’ a
      }
, product :
      âˆ€(a : { _1 : Type, _2 : Type })
    â†’ âˆ€(p : âˆ€(r : Type) â†’ (âˆ€(z : Type) â†’ (z â†’ a._2) â†’ (a._1 â†’ z) â†’ r) â†’ r)
    â†’ a._1
    â†’ a._2
, rightIdentity :
      âˆ€(a : Type)
    â†’ { from :
          âˆ€(x : a) â†’ { _1 : a, _2 : {} }
      , to :
          âˆ€(p : { _1 : a, _2 : {} }) â†’ a
      }
, tensor :
    { map :
          âˆ€(a : { _1 : Type, _2 : Type })
        â†’ âˆ€(b : { _1 : Type, _2 : Type })
        â†’ âˆ€(f : { _1 : a._1 â†’ b._1, _2 : a._2 â†’ b._2 })
        â†’ âˆ€(t : { _1 : a._1, _2 : a._2 })
        â†’ { _1 : b._1, _2 : b._2 }
    }
, unit :
    âˆ€(a : Type) â†’ âˆ€(x : a) â†’ a
}
</pre></dd>
</dl>
<h4>rig (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ additive :
    { associativity :
          âˆ€(a : Type)
        â†’ âˆ€(b : Type)
        â†’ âˆ€(c : Type)
        â†’ { from :
                âˆ€(e : < Left : a | Right : < Left : b | Right : c > >)
              â†’ < Left : < Left : a | Right : b > | Right : c >
          , to :
                âˆ€(e : < Left : < Left : a | Right : b > | Right : c >)
              â†’ < Left : a | Right : < Left : b | Right : c > >
          }
    , hom :
        { map :
              âˆ€(a : { _1 : Type, _2 : Type })
            â†’ âˆ€(b : { _1 : Type, _2 : Type })
            â†’ âˆ€(f : { _1 : b._1 â†’ a._1, _2 : a._2 â†’ b._2 })
            â†’ âˆ€(fn : a._1 â†’ a._2)
            â†’ âˆ€(x : b._1)
            â†’ b._2
        }
    , leftIdentity :
          âˆ€(a : Type)
        â†’ { from :
              âˆ€(Right : a) â†’ < Left : <> | Right : a >
          , to :
              âˆ€(e : < Left : <> | Right : a >) â†’ a
          }
    , product :
          âˆ€(a : { _1 : Type, _2 : Type })
        â†’ âˆ€(p : âˆ€(r : Type) â†’ (âˆ€(z : Type) â†’ (z â†’ a._2) â†’ (a._1 â†’ z) â†’ r) â†’ r)
        â†’ a._1
        â†’ a._2
    , rightIdentity :
          âˆ€(a : Type)
        â†’ { from :
              âˆ€(Left : a) â†’ < Left : a | Right : <> >
          , to :
              âˆ€(e : < Left : a | Right : <> >) â†’ a
          }
    , tensor :
        { map :
              âˆ€(a : { _1 : Type, _2 : Type })
            â†’ âˆ€(b : { _1 : Type, _2 : Type })
            â†’ âˆ€(f : { _1 : a._1 â†’ b._1, _2 : a._2 â†’ b._2 })
            â†’ âˆ€(e : < Left : a._1 | Right : a._2 >)
            â†’ < Left : b._1 | Right : b._2 >
        }
    , unit :
        âˆ€(a : Type) â†’ âˆ€(x : a) â†’ a
    }
, distributivity :
      âˆ€(a : Type)
    â†’ âˆ€(b : Type)
    â†’ âˆ€(c : Type)
    â†’ { from :
            âˆ€(e : < Left : { _1 : a, _2 : b } | Right : { _1 : a, _2 : c } >)
          â†’ { _1 : a, _2 : < Left : b | Right : c > }
      , to :
            âˆ€(p : { _1 : a, _2 : < Left : b | Right : c > })
          â†’ < Left : { _1 : a, _2 : b } | Right : { _1 : a, _2 : c } >
      }
, hom :
    { map :
          âˆ€(a : { _1 : Type, _2 : Type })
        â†’ âˆ€(b : { _1 : Type, _2 : Type })
        â†’ âˆ€(f : { _1 : b._1 â†’ a._1, _2 : a._2 â†’ b._2 })
        â†’ âˆ€(fn : a._1 â†’ a._2)
        â†’ âˆ€(x : b._1)
        â†’ b._2
    }
, leftAnnihilation :
      âˆ€(a : Type)
    â†’ { from :
          âˆ€(v : <>) â†’ { _1 : <>, _2 : a }
      , to :
          âˆ€(p : { _1 : <>, _2 : a }) â†’ <>
      }
, multiplicative :
    { associativity :
          âˆ€(a : Type)
        â†’ âˆ€(b : Type)
        â†’ âˆ€(c : Type)
        â†’ { from :
                âˆ€(p : { _1 : a, _2 : { _1 : b, _2 : c } })
              â†’ { _1 : { _1 : a, _2 : b }, _2 : c }
          , to :
                âˆ€(p : { _1 : { _1 : a, _2 : b }, _2 : c })
              â†’ { _1 : a, _2 : { _1 : b, _2 : c } }
          }
    , hom :
        { map :
              âˆ€(a : { _1 : Type, _2 : Type })
            â†’ âˆ€(b : { _1 : Type, _2 : Type })
            â†’ âˆ€(f : { _1 : b._1 â†’ a._1, _2 : a._2 â†’ b._2 })
            â†’ âˆ€(fn : a._1 â†’ a._2)
            â†’ âˆ€(x : b._1)
            â†’ b._2
        }
    , leftIdentity :
          âˆ€(a : Type)
        â†’ { from :
              âˆ€(x : a) â†’ { _1 : {}, _2 : a }
          , to :
              âˆ€(p : { _1 : {}, _2 : a }) â†’ a
          }
    , product :
          âˆ€(a : { _1 : Type, _2 : Type })
        â†’ âˆ€(p : âˆ€(r : Type) â†’ (âˆ€(z : Type) â†’ (z â†’ a._2) â†’ (a._1 â†’ z) â†’ r) â†’ r)
        â†’ a._1
        â†’ a._2
    , rightIdentity :
          âˆ€(a : Type)
        â†’ { from :
              âˆ€(x : a) â†’ { _1 : a, _2 : {} }
          , to :
              âˆ€(p : { _1 : a, _2 : {} }) â†’ a
          }
    , tensor :
        { map :
              âˆ€(a : { _1 : Type, _2 : Type })
            â†’ âˆ€(b : { _1 : Type, _2 : Type })
            â†’ âˆ€(f : { _1 : a._1 â†’ b._1, _2 : a._2 â†’ b._2 })
            â†’ âˆ€(t : { _1 : a._1, _2 : a._2 })
            â†’ { _1 : b._1, _2 : b._2 }
        }
    , unit :
        âˆ€(a : Type) â†’ âˆ€(x : a) â†’ a
    }
, product :
      âˆ€(a : { _1 : Type, _2 : Type })
    â†’ âˆ€(p : âˆ€(r : Type) â†’ (âˆ€(z : Type) â†’ (z â†’ a._2) â†’ (a._1 â†’ z) â†’ r) â†’ r)
    â†’ a._1
    â†’ a._2
, rightAnnihilation :
      âˆ€(a : Type)
    â†’ { from :
          âˆ€(v : <>) â†’ { _1 : a, _2 : <> }
      , to :
          âˆ€(p : { _1 : a, _2 : <> }) â†’ <>
      }
, unit :
    âˆ€(a : Type) â†’ âˆ€(x : a) â†’ a
}
</pre></dd>
</dl>
<h4>comonoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
âˆ€(a : Type) â†’ { product : âˆ€(x : a) â†’ { _1 : a, _2 : a }, unit : a â†’ {} }
</pre></dd>
</dl>
<h4>curry (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(a : Type)
â†’ âˆ€(b : Type)
â†’ âˆ€(c : Type)
â†’ { from :
      âˆ€(f : a â†’ b â†’ c) â†’ âˆ€(p : { _1 : a, _2 : b }) â†’ c
  , to :
      âˆ€(f : { _1 : a, _2 : b } â†’ c) â†’ âˆ€(x : a) â†’ âˆ€(y : b) â†’ c
  }
</pre></dd>
</dl>
<h4 style="background-color: #bbb; width: 100%">./Category/Set/monoidal</h4>
<h4>cartesian (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ arrow :
    âˆ€(a : { _1 : Type, _2 : Type }) â†’ Type
, constraint :
    âˆ€(t : Type) â†’ Type
, diagonal :
    âˆ€(a : Type) â†’ { _1 : Type, _2 : Type }
, product :
    âˆ€(a : { _1 : Type, _2 : Type }) â†’ Type
, unit :
    Type
}
</pre></dd>
</dl>
<h4>rig (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ additive :
    { product : âˆ€(a : { _1 : Type, _2 : Type }) â†’ Type, unit : Type }
, arrow :
    âˆ€(a : { _1 : Type, _2 : Type }) â†’ Type
, constraint :
    âˆ€(t : Type) â†’ Type
, multiplicative :
    { product : âˆ€(a : { _1 : Type, _2 : Type }) â†’ Type, unit : Type }
}
</pre></dd>
</dl>
<h4>semigroupoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ hom :
    { map :
          âˆ€(a : { _1 : Type, _2 : Type })
        â†’ âˆ€(b : { _1 : Type, _2 : Type })
        â†’ âˆ€(f : { _1 : b._1 â†’ a._1, _2 : a._2 â†’ b._2 })
        â†’ âˆ€(fn : a._1 â†’ a._2)
        â†’ âˆ€(x : b._1)
        â†’ b._2
    }
, product :
      âˆ€(a : { _1 : Type, _2 : Type })
    â†’ âˆ€(p : âˆ€(r : Type) â†’ (âˆ€(z : Type) â†’ (z â†’ a._2) â†’ (a._1 â†’ z) â†’ r) â†’ r)
    â†’ a._1
    â†’ a._2
}
</pre></dd>
</dl>
<h4>types.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ { Adjunction :
      âˆ€(f : Type â†’ Type) â†’ âˆ€(g : Type â†’ Type) â†’ Type
  , Bifunctor :
      âˆ€(f : { _1 : Type, _2 : Type } â†’ Type) â†’ Type
  , Category :
        âˆ€ ( v
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            , product :
                { _1 : Type, _2 : Type } â†’ Type
            , unit :
                Type
            }
          )
      â†’ âˆ€ ( cat
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            }
          )
      â†’ Type
  , Codensity :
        âˆ€ ( d
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            }
          )
      â†’ âˆ€(m : Type â†’ Type)
      â†’ âˆ€(a : Type)
      â†’ Type
  , CommutativeGroup :
      âˆ€(m : Type) â†’ Type
  , CommutativeMonoid :
      âˆ€(m : Type) â†’ Type
  , Comonad :
      âˆ€(m : Type â†’ Type) â†’ Type
  , Compose :
      âˆ€(f : { _1 : Type â†’ Type, _2 : Type â†’ Type }) â†’ âˆ€(a : Type) â†’ Type
  , Const :
      âˆ€(a : { _1 : Type, _2 : Type }) â†’ Type
  , Costar :
      âˆ€(m : Type â†’ Type) â†’ âˆ€(a : { _1 : Type, _2 : Type }) â†’ Type
  , Coyoneda :
      âˆ€(f : Type â†’ Type) â†’ âˆ€(a : Type) â†’ Type
  , Day :
      âˆ€(f : { _1 : Type â†’ Type, _2 : Type â†’ Type }) â†’ âˆ€(a : Type) â†’ Type
  , Density :
        âˆ€ ( d
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            }
          )
      â†’ âˆ€(f : Type â†’ Type)
      â†’ âˆ€(a : Type)
      â†’ Type
  , Endofunctor :
      âˆ€(f : Type â†’ Type) â†’ Type
  , Eq :
      âˆ€(a : Type) â†’ Type
  , Field :
      âˆ€(m : Type) â†’ Type
  , Group :
      âˆ€(m : Type) â†’ Type
  , Identity :
      âˆ€(a : Type) â†’ Type
  , Lan :
      âˆ€(p : Type â†’ Type) â†’ âˆ€(f : Type â†’ Type) â†’ âˆ€(a : Type) â†’ Type
  , Leibniz :
      { arrow :
          âˆ€(a : { _1 : Type, _2 : Type }) â†’ Type
      , constraint :
          âˆ€(t : Type) â†’ Type
      }
  , Monad :
      âˆ€(m : Type â†’ Type) â†’ Type
  , Monoid :
      âˆ€(m : Type) â†’ Type
  , MonoidalFunctor :
      âˆ€(f : Type â†’ Type) â†’ Type
  , NaturalTransformation :
      âˆ€(f : { _1 : Type â†’ Type, _2 : Type â†’ Type }) â†’ Type
  , OrderedField :
      âˆ€(m : Type) â†’ Type
  , OrderedGroup :
      âˆ€(m : Type) â†’ Type
  , OrderedRing :
      âˆ€(m : Type) â†’ Type
  , PartiallyOrderedField :
      âˆ€(m : Type) â†’ Type
  , PartiallyOrderedGroup :
      âˆ€(m : Type) â†’ Type
  , PartiallyOrderedRing :
      âˆ€(m : Type) â†’ Type
  , Profunctor :
      âˆ€(f : { _1 : Type, _2 : Type } â†’ Type) â†’ Type
  , Ran :
      âˆ€(p : Type â†’ Type) â†’ âˆ€(f : Type â†’ Type) â†’ âˆ€(a : Type) â†’ Type
  , Rig :
      âˆ€(m : Type) â†’ Type
  , Ring :
      âˆ€(m : Type) â†’ Type
  , Semigroup :
      âˆ€(m : Type) â†’ Type
  , Semigroupoid :
        âˆ€ ( v
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            , product :
                { _1 : Type, _2 : Type } â†’ Type
            , unit :
                Type
            }
          )
      â†’ âˆ€ ( cat
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            }
          )
      â†’ âˆ€(m : { _1 : Type, _2 : Type } â†’ Type)
      â†’ Type
  , Semiring :
      âˆ€(m : Type) â†’ Type
  , Star :
      âˆ€(m : Type â†’ Type) â†’ âˆ€(a : { _1 : Type, _2 : Type }) â†’ Type
  , StrongFunctor :
      âˆ€(f : Type â†’ Type) â†’ Type
  , Traversable :
      âˆ€(m : Type â†’ Type) â†’ âˆ€(f : Type â†’ Type) â†’ Type
  , Yoneda :
      âˆ€(f : Type â†’ Type) â†’ âˆ€(a : Type) â†’ Type
  }
</pre></dd>
</dl>
<h4>Sort (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
Sort
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p>{- FIXME: This should use `./../Monoid/Type â€¦ (./../Category/Monoidal/Profunctor
          object morphism)`, but the unit in that monoidal category
          definition isnâ€™t correct (or, if it is, I canâ€™t figure out how to use
          it). So instead, we just build the `Semigroup`, and then write a
          custom unit. But this means weâ€™re not structurally a `Monoid`.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ { hom :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
            }
      }
  , product :
        âˆ€(a : { _1 : object, _2 : object })
      â†’ (   âˆ€(r : Type)
          â†’ (   âˆ€(z : object)
              â†’ cat.arrow { _1 = z, _2 = a._2 }
              â†’ cat.arrow { _1 = a._1, _2 = z }
              â†’ r
            )
          â†’ r
        )
      â†’ cat.arrow a
  , unit :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
  }
</pre></dd>
</dl>
<h4>extractSemigroupoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€ ( category
    : { hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ v.arrow
                { _1 =
                    v.product
                    { _1 =
                        cat.arrow { _1 = b._1, _2 = a._1 }
                    , _2 =
                        cat.arrow { _1 = a._2, _2 = b._2 }
                    }
                , _2 =
                    v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
                }
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ { hom :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
            }
      }
  , product :
        âˆ€(a : { _1 : object, _2 : object })
      â†’ (   âˆ€(r : Type)
          â†’ (   âˆ€(z : object)
              â†’ cat.arrow { _1 = z, _2 = a._2 }
              â†’ cat.arrow { _1 = a._1, _2 = z }
              â†’ r
            )
          â†’ r
        )
      â†’ cat.arrow a
  }
</pre></dd>
</dl>
<h4>postcomposition (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€ ( category
    : { hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(c : object)
â†’ { map :
        âˆ€(x : object)
      â†’ âˆ€(y : object)
      â†’ âˆ€(fn : cat.arrow { _1 = x, _2 = y })
      â†’ âˆ€(input : cat.arrow { _1 = c, _2 = x })
      â†’ cat.arrow { _1 = c, _2 = y }
  }
</pre></dd>
</dl>
<h4>precomposition (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€ ( category
    : { hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(c : object)
â†’ { map :
        âˆ€(x : object)
      â†’ âˆ€(y : object)
      â†’ âˆ€(fn : cat.arrow { _1 = y, _2 = x })
      â†’ âˆ€(input : cat.arrow { _1 = x, _2 = c })
      â†’ cat.arrow { _1 = y, _2 = c }
  }
</pre></dd>
</dl>
<h4>types.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ { Adjunction :
      âˆ€(f : object â†’ object) â†’ âˆ€(g : object â†’ object) â†’ Type
  , Bifunctor :
      âˆ€(f : { _1 : object, _2 : object } â†’ object) â†’ Type
  , Category :
        âˆ€ ( v
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            , product :
                { _1 : Type, _2 : Type } â†’ Type
            , unit :
                Type
            }
          )
      â†’ âˆ€ ( cat
          : { arrow :
                { _1 : object, _2 : object } â†’ Type
            , constraint :
                object â†’ Type
            }
          )
      â†’ Type
  , Codensity :
        âˆ€ ( d
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            }
          )
      â†’ âˆ€(m : object â†’ Type)
      â†’ âˆ€(a : Type)
      â†’ Type
  , Comonad :
      âˆ€(m : object â†’ object) â†’ Type
  , Compose :
        âˆ€(f : { _1 : object â†’ object, _2 : object â†’ object })
      â†’ âˆ€(a : object)
      â†’ object
  , Const :
      âˆ€(a : { _1 : object, _2 : object }) â†’ object
  , Costar :
      âˆ€(m : object â†’ object) â†’ âˆ€(a : { _1 : object, _2 : object }) â†’ Type
  , Coyoneda :
      âˆ€(f : object â†’ Type) â†’ âˆ€(a : object) â†’ Type
  , Density :
        âˆ€ ( d
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            }
          )
      â†’ âˆ€(f : object â†’ Type)
      â†’ âˆ€(a : Type)
      â†’ Type
  , Endofunctor :
      âˆ€(f : object â†’ object) â†’ Type
  , Identity :
      âˆ€(a : object) â†’ object
  , Lan :
      âˆ€(p : object â†’ object) â†’ âˆ€(f : object â†’ Type) â†’ âˆ€(a : object) â†’ Type
  , Leibniz :
      { arrow :
          âˆ€(a : { _1 : object, _2 : object }) â†’ Type
      , constraint :
          object â†’ Type
      }
  , Monad :
      âˆ€(m : object â†’ object) â†’ Type
  , NaturalTransformation :
      âˆ€(f : { _1 : object â†’ object, _2 : object â†’ object }) â†’ Type
  , Profunctor :
      âˆ€(f : { _1 : object, _2 : object } â†’ Type) â†’ Type
  , Ran :
      âˆ€(p : object â†’ object) â†’ âˆ€(f : object â†’ Type) â†’ âˆ€(a : object) â†’ Type
  , Semigroupoid :
        âˆ€ ( v
          : { arrow :
                { _1 : Type, _2 : Type } â†’ Type
            , constraint :
                Type â†’ Type
            , product :
                { _1 : Type, _2 : Type } â†’ Type
            , unit :
                Type
            }
          )
      â†’ âˆ€ ( cat
          : { arrow :
                { _1 : object, _2 : object } â†’ Type
            , constraint :
                object â†’ Type
            }
          )
      â†’ âˆ€(m : { _1 : object, _2 : object } â†’ Type)
      â†’ Type
  , Star :
      âˆ€(m : object â†’ object) â†’ âˆ€(a : { _1 : object, _2 : object }) â†’ Type
  , Traversable :
      âˆ€(m : object â†’ object) â†’ âˆ€(f : object â†’ object) â†’ Type
  , Yoneda :
      âˆ€(f : object â†’ Type) â†’ âˆ€(a : object) â†’ Type
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Codensity</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(d : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€(m : cObject â†’ Type)
â†’ âˆ€(a : Type)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(cObject : Kind)
â†’ Î»(d : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ Î»(m : cObject â†’ Type)
â†’ Î»(a : Type)
â†’ âˆ€(b : cObject) â†’ d.arrow { _1 = a, _2 = m b } â†’ m b
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Codensity/functor</h3>
<h4>endo (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type â†’ Type)
â†’ { map :
        âˆ€(a : Type)
      â†’ âˆ€(b : Type)
      â†’ âˆ€(fn : a â†’ b)
      â†’ âˆ€(ran : âˆ€(b : Type) â†’ (a â†’ m b) â†’ m b)
      â†’ âˆ€(c : Type)
      â†’ âˆ€(k : b â†’ m c)
      â†’ m c
  }
</pre></dd>
</dl>
<h4>monoidal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type â†’ Type)
â†’ { map :
        âˆ€(a : Type)
      â†’ âˆ€(b : Type)
      â†’ âˆ€(fn : a â†’ b)
      â†’ âˆ€(ran : âˆ€(b : Type) â†’ (a â†’ m b) â†’ m b)
      â†’ âˆ€(c : Type)
      â†’ âˆ€(k : b â†’ m c)
      â†’ m c
  , product :
        âˆ€(i : Type)
      â†’ âˆ€ ( day
          :   âˆ€(r : Type)
            â†’ (   âˆ€(b : { _1 : Type, _2 : Type })
                â†’ ({ _1 : b._1, _2 : b._2 } â†’ i)
                â†’ { _1 :
                      âˆ€(b : Type) â†’ (b@1._1 â†’ m b) â†’ m b
                  , _2 :
                      âˆ€(b : Type) â†’ (b@1._2 â†’ m b) â†’ m b
                  }
                â†’ r
              )
            â†’ r
          )
      â†’ âˆ€(b : Type)
      â†’ (i â†’ m b)
      â†’ m b
  , unit :
      âˆ€(a : Type) â†’ âˆ€(fn : {} â†’ a) â†’ âˆ€(b : Type) â†’ âˆ€(k : a â†’ m b) â†’ m b
  }
</pre></dd>
</dl>
<h4>lift (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€ ( semigroupoid
    : { hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      }
    )
â†’ âˆ€(f : object â†’ object)
â†’ âˆ€ ( functor
    : { map :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ cat.arrow { _1 = a, _2 = b }
          â†’ cat.arrow { _1 = f a, _2 = f b }
      }
    )
â†’ âˆ€ ( monad
    : { product :
          âˆ€(a : object) â†’ cat.arrow { _1 = f (f a), _2 = f a }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = f a }
      }
    )
â†’ âˆ€(a : object)
â†’ âˆ€(b : object)
â†’ âˆ€(k : cat.arrow { _1 = a, _2 = f b })
â†’ cat.arrow { _1 = f a, _2 = f b }
</pre></dd>
</dl>
<h4>lower (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type â†’ Type)
â†’ âˆ€ ( monoidal
    : { map :
          âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ (a â†’ b) â†’ m a â†’ m b
      , product :
            âˆ€(a : Type)
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(b : { _1 : Type, _2 : Type })
                  â†’ ({ _1 : b._1, _2 : b._2 } â†’ a)
                  â†’ { _1 : m b._1, _2 : m b._2 }
                  â†’ r
                )
              â†’ r
            )
          â†’ m a
      , unit :
          âˆ€(a : Type) â†’ ({} â†’ a) â†’ m a
      }
    )
â†’ âˆ€(a : Type)
â†’ âˆ€(ran : âˆ€(b : Type) â†’ (a â†’ m b) â†’ m b)
â†’ m a
</pre></dd>
</dl>
<h4>monad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€ ( category
    : { hom :
          { map :
                âˆ€(a : { _1 : Type, _2 : Type })
              â†’ âˆ€(b : { _1 : Type, _2 : Type })
              â†’ { _1 : b._1 â†’ a._1, _2 : a._2 â†’ b._2 }
              â†’ (a._1 â†’ a._2)
              â†’ b._1
              â†’ b._2
          }
      , product :
            âˆ€(a : { _1 : Type, _2 : Type })
          â†’ (âˆ€(r : Type) â†’ (âˆ€(z : Type) â†’ (z â†’ a._2) â†’ (a._1 â†’ z) â†’ r) â†’ r)
          â†’ a._1
          â†’ a._2
      , unit :
          âˆ€(a : Type) â†’ a â†’ a
      }
    )
â†’ âˆ€(m : Type â†’ Type)
â†’ { product :
        âˆ€(a : Type)
      â†’ âˆ€ ( codensity
          : âˆ€(b : Type) â†’ ((âˆ€(b : Type) â†’ (a â†’ m b) â†’ m b) â†’ m b) â†’ m b
          )
      â†’ âˆ€(c : Type)
      â†’ âˆ€(l : a â†’ m c)
      â†’ m c
  , unit :
      âˆ€(a : Type) â†’ âˆ€(x : a) â†’ âˆ€(b : Type) â†’ âˆ€(k : a â†’ m b) â†’ m b
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Comonad</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€(m : object â†’ object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ Î»(m : object â†’ object)
â†’ { product :
      âˆ€(a : object) â†’ cat.arrow { _1 = m a, _2 = m (m a) }
  , unit :
      âˆ€(a : object) â†’ cat.arrow { _1 = m a, _2 = a }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Comonoid</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { product : cat.arrow m (cat.product m m), unit : m }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { product :
      cat.arrow { _1 = m, _2 = cat.product { _1 = m, _2 = m } }
  , unit :
      cat.arrow { _1 = m, _2 = cat.unit }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Compose</h2>
<h4>Type (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€(eObject : Kind)
â†’ âˆ€(f : { _1 : dObject â†’ eObject, _2 : cObject â†’ dObject })
â†’ âˆ€(a : cObject)
â†’ eObject
</pre></dd>
</dl>
<h4>adjunction (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h4>comonad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€(f : dObject â†’ cObject)
â†’ âˆ€ ( fFunctor
    : { map :
            âˆ€(a : dObject)
          â†’ âˆ€(b : dObject)
          â†’ d.arrow { _1 = a, _2 = b }
          â†’ c.arrow { _1 = f a, _2 = f b }
      }
    )
â†’ âˆ€(g : cObject â†’ dObject)
â†’ âˆ€ ( adjunction
    : { counit :
          âˆ€(a : cObject) â†’ c.arrow { _1 = f (g a), _2 = a }
      , leftAdjunct :
            âˆ€(a : dObject)
          â†’ âˆ€(b : cObject)
          â†’ c.arrow { _1 = f a, _2 = b }
          â†’ d.arrow { _1 = a, _2 = g b }
      , rightAdjunct :
            âˆ€(a : dObject)
          â†’ âˆ€(b : cObject)
          â†’ d.arrow { _1 = a, _2 = g b }
          â†’ c.arrow { _1 = f a, _2 = b }
      , unit :
          âˆ€(a : dObject) â†’ d.arrow { _1 = a, _2 = g (f a) }
      }
    )
â†’ { product :
      âˆ€(a : cObject) â†’ c.arrow { _1 = f (g a), _2 = f (g (f (g a))) }
  , unit :
      âˆ€(a : cObject) â†’ c.arrow { _1 = f (g a), _2 = a }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Compose/functor</h3>
<h4>instance (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      }
    )
â†’ âˆ€ ( vCategory
    : { hom :
          { map :
                âˆ€(a : { _1 : vObject, _2 : vObject })
              â†’ âˆ€(b : { _1 : vObject, _2 : vObject })
              â†’ { _1 :
                    v.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    v.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ v.arrow a
              â†’ v.arrow b
          }
      , product :
            âˆ€(a : { _1 : vObject, _2 : vObject })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : vObject)
                  â†’ v.arrow { _1 = z, _2 = a._2 }
                  â†’ v.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ v.arrow a
      , unit :
          âˆ€(a : vObject) â†’ v.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(cObject : Kind)
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ vObject
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ vObject
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€(eObject : Kind)
â†’ âˆ€ ( e
    : { arrow :
          { _1 : eObject, _2 : eObject } â†’ vObject
      , constraint :
          eObject â†’ Type
      }
    )
â†’ âˆ€(f : dObject â†’ eObject)
â†’ âˆ€ ( fFunctor
    : { map :
            âˆ€(a : dObject)
          â†’ âˆ€(b : dObject)
          â†’ v.arrow
            { _1 =
                d.arrow { _1 = a, _2 = b }
            , _2 =
                e.arrow { _1 = f a, _2 = f b }
            }
      }
    )
â†’ âˆ€(g : cObject â†’ dObject)
â†’ âˆ€ ( gFunctor
    : { map :
            âˆ€(a : cObject)
          â†’ âˆ€(b : cObject)
          â†’ v.arrow
            { _1 =
                c.arrow { _1 = a, _2 = b }
            , _2 =
                d.arrow { _1 = g a, _2 = g b }
            }
      }
    )
â†’ { map :
        âˆ€(a : cObject)
      â†’ âˆ€(b : cObject)
      â†’ v.arrow
        { _1 =
            c.arrow { _1 = a, _2 = b }
        , _2 =
            e.arrow { _1 = f (g a), _2 = f (g b) }
        }
  }
</pre></dd>
</dl>
<h4>monoidal (term)</h4>
<p>{- NB: Since this is currently forced to be in *Set*, itâ€™s quite possible that
       some of the uses of _C_ and _D_ are wrong, since the type system canâ€™t
       distinguish them. So take them with a grain of salt if youâ€™re editing
       this file.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( vCategory
    : { hom :
          { map :
                âˆ€(a : { _1 : Type, _2 : Type })
              â†’ âˆ€(b : { _1 : Type, _2 : Type })
              â†’ { _1 :
                    v.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    v.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ v.arrow a
              â†’ v.arrow b
          }
      , product :
            âˆ€(a : { _1 : Type, _2 : Type })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : Type)
                  â†’ v.arrow { _1 = z, _2 = a._2 }
                  â†’ v.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ v.arrow a
      , unit :
          âˆ€(a : Type) â†’ v.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      , product :
          { _1 : cObject, _2 : cObject } â†’ cObject
      , unit :
          cObject
      }
    )
â†’ âˆ€(f : Type â†’ Type)
â†’ âˆ€ ( fMonoidal
    : { map :
          âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ v.arrow { _1 = a â†’ b, _2 = f a â†’ f b }
      , product :
            âˆ€(a : Type)
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(b : { _1 : Type, _2 : Type })
                  â†’ ({ _1 : b._1, _2 : b._2 } â†’ a)
                  â†’ { _1 : f b._1, _2 : f b._2 }
                  â†’ r
                )
              â†’ r
            )
          â†’ f a
      , unit :
          âˆ€(a : Type) â†’ ({} â†’ a) â†’ f a
      }
    )
â†’ âˆ€(g : cObject â†’ Type)
â†’ âˆ€ ( gMonoidal
    : { map :
            âˆ€(a : cObject)
          â†’ âˆ€(b : cObject)
          â†’ v.arrow { _1 = c.arrow { _1 = a, _2 = b }, _2 = g a â†’ g b }
      , product :
            âˆ€(a : cObject)
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(b : { _1 : cObject, _2 : cObject })
                  â†’ c.arrow { _1 = c.product b, _2 = a }
                  â†’ { _1 : g b._1, _2 : g b._2 }
                  â†’ r
                )
              â†’ r
            )
          â†’ g a
      , unit :
          âˆ€(a : cObject) â†’ c.arrow { _1 = c.unit, _2 = a } â†’ g a
      }
    )
â†’ { map :
        âˆ€(a : cObject)
      â†’ âˆ€(b : cObject)
      â†’ v.arrow { _1 = c.arrow { _1 = a, _2 = b }, _2 = f (g a) â†’ f (g b) }
  , product :
        âˆ€(i : cObject)
      â†’ âˆ€ ( day
          :   âˆ€(r : Type)
            â†’ (   âˆ€(b : { _1 : cObject, _2 : cObject })
                â†’ c.arrow { _1 = c.product b, _2 = i }
                â†’ { _1 : f (g b._1), _2 : f (g b._2) }
                â†’ r
              )
            â†’ r
          )
      â†’ f (g i)
  , unit :
      âˆ€(a : cObject) â†’ âˆ€(fn : c.arrow { _1 = c.unit, _2 = a }) â†’ f (g a)
  }
</pre></dd>
</dl>
<h4>monad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€(f : dObject â†’ cObject)
â†’ âˆ€(g : cObject â†’ dObject)
â†’ âˆ€ ( gFunctor
    : { map :
            âˆ€(a : cObject)
          â†’ âˆ€(b : cObject)
          â†’ c.arrow { _1 = a, _2 = b }
          â†’ d.arrow { _1 = g a, _2 = g b }
      }
    )
â†’ âˆ€ ( adjunction
    : { counit :
          âˆ€(a : cObject) â†’ c.arrow { _1 = f (g a), _2 = a }
      , leftAdjunct :
            âˆ€(a : dObject)
          â†’ âˆ€(b : cObject)
          â†’ c.arrow { _1 = f a, _2 = b }
          â†’ d.arrow { _1 = a, _2 = g b }
      , rightAdjunct :
            âˆ€(a : dObject)
          â†’ âˆ€(b : cObject)
          â†’ d.arrow { _1 = a, _2 = g b }
          â†’ c.arrow { _1 = f a, _2 = b }
      , unit :
          âˆ€(a : dObject) â†’ d.arrow { _1 = a, _2 = g (f a) }
      }
    )
â†’ { product :
      âˆ€(a : dObject) â†’ d.arrow { _1 = g (f (g (f a))), _2 = g (f a) }
  , unit :
      âˆ€(a : dObject) â†’ d.arrow { _1 = a, _2 = g (f a) }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Const</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
âˆ€(a : { _1 : Kind, _2 : Kind }) â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
Î»(a : { _1 : Kind, _2 : Kind }) â†’ a._1
</pre></dd>
</dl>
<h4>Type (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€(a : { _1 : cObject, _2 : dObject })
â†’ cObject
</pre></dd>
</dl>
<h4>functor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( cCategory
    : { hom :
          { map :
                âˆ€(a : { _1 : cObject, _2 : cObject })
              â†’ âˆ€(b : { _1 : cObject, _2 : cObject })
              â†’ { _1 :
                    c.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    c.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ c.arrow a
              â†’ c.arrow b
          }
      , product :
            âˆ€(a : { _1 : cObject, _2 : cObject })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : cObject)
                  â†’ c.arrow { _1 = z, _2 = a._2 }
                  â†’ c.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ c.arrow a
      , unit :
          âˆ€(a : cObject) â†’ c.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ { map :
        âˆ€(a : { _1 : cObject, _2 : dObject })
      â†’ âˆ€(b : { _1 : cObject, _2 : dObject })
      â†’ âˆ€ ( f
          : { _1 :
                c.arrow { _1 = a._1, _2 = b._1 }
            , _2 :
                d.arrow { _1 = a._2, _2 = b._2 }
            }
          )
      â†’ c.arrow { _1 = a._1, _2 = b._1 }
  }
</pre></dd>
</dl>
<h4>term (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Type)
â†’ âˆ€(dObject : Type)
â†’ âˆ€(a : { _1 : cObject, _2 : dObject })
â†’ cObject
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Cosemigroup</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ Î»(m : object)
â†’ { product : cat.arrow { _1 = m, _2 = cat.product { _1 = m, _2 = m } } }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Costar</h2>
<h4>Type (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ vObject
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€(m : object â†’ object)
â†’ âˆ€(a : { _1 : object, _2 : object })
â†’ vObject
</pre></dd>
</dl>
<h4>category (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h4>semigroupoid (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Coyoneda</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€(f : object â†’ Type)
â†’ âˆ€(a : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ Î»(f : object â†’ Type)
â†’ Î»(a : object)
â†’ âˆ€(r : Type) â†’ (âˆ€(b : object) â†’ cat.arrow { _1 = b, _2 = a } â†’ f b â†’ r) â†’ r
</pre></dd>
</dl>
<h4>functor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€ ( semigroupoid
    : { hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      }
    )
â†’ âˆ€(g : object â†’ Type)
â†’ { map :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ âˆ€(h : cat.arrow { _1 = a, _2 = b })
      â†’ âˆ€ ( lan
          :   âˆ€(r : Type)
            â†’ (âˆ€(b : object) â†’ cat.arrow { _1 = b, _2 = a } â†’ g b â†’ r)
            â†’ r
          )
      â†’ âˆ€(r : Type)
      â†’ âˆ€(k : âˆ€(c : object) â†’ cat.arrow { _1 = c, _2 = b } â†’ g c â†’ r)
      â†’ r
  }
</pre></dd>
</dl>
<h4>lift (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cat : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( category
    : { hom :
          { map :
                âˆ€(a : { _1 : Type, _2 : Type })
              â†’ âˆ€(b : { _1 : Type, _2 : Type })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , product :
            âˆ€(a : { _1 : Type, _2 : Type })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : Type)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , unit :
          âˆ€(a : Type) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(g : Type â†’ Type)
â†’ âˆ€(a : Type)
â†’ âˆ€(x : g a)
â†’ âˆ€(r : Type)
â†’ âˆ€(k : âˆ€(b : Type) â†’ cat.arrow { _1 = b, _2 = a } â†’ g b â†’ r)
â†’ r
</pre></dd>
</dl>
<h4>lower (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€(f : cObject â†’ Type)
â†’ âˆ€ ( functor
    : { map :
            âˆ€(a : cObject)
          â†’ âˆ€(b : cObject)
          â†’ c.arrow { _1 = a, _2 = b }
          â†’ f a
          â†’ f b
      }
    )
â†’ âˆ€(a : cObject)
â†’ âˆ€ ( lan
    : âˆ€(r : Type) â†’ (âˆ€(b : cObject) â†’ c.arrow { _1 = b, _2 = a } â†’ f b â†’ r) â†’ r
    )
â†’ f a
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Day</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      , product :
          { _1 : cObject, _2 : cObject } â†’ cObject
      , unit :
          cObject
      }
    )
â†’ âˆ€(f : { _1 : cObject â†’ Type, _2 : cObject â†’ Type })
â†’ âˆ€(a : cObject)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(cObject : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ Î» ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      , product :
          { _1 : cObject, _2 : cObject } â†’ cObject
      , unit :
          cObject
      }
    )
â†’ Î»(f : { _1 : cObject â†’ Type, _2 : cObject â†’ Type })
â†’ Î»(a : cObject)
â†’   âˆ€(r : Type)
  â†’ (   âˆ€(b : { _1 : cObject, _2 : cObject })
      â†’ c.arrow { _1 = c.product b, _2 = a }
      â†’ v.product { _1 = f._1 b._1, _2 = f._2 b._2 }
      â†’ r
    )
  â†’ r
</pre></dd>
</dl>
<h4>comonad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€ ( semigroupoid
    : { hom :
          { map :
                âˆ€(a : { _1 : Type, _2 : Type })
              â†’ âˆ€(b : { _1 : Type, _2 : Type })
              â†’ { _1 : b._1 â†’ a._1, _2 : a._2 â†’ b._2 }
              â†’ (a._1 â†’ a._2)
              â†’ b._1
              â†’ b._2
          }
      , product :
            âˆ€(a : { _1 : Type, _2 : Type })
          â†’ (âˆ€(r : Type) â†’ (âˆ€(z : Type) â†’ (z â†’ a._2) â†’ (a._1 â†’ z) â†’ r) â†’ r)
          â†’ a._1
          â†’ a._2
      }
    )
â†’ âˆ€(f : Type â†’ Type)
â†’ âˆ€ ( fComonad
    : { product : âˆ€(a : Type) â†’ f a â†’ f (f a), unit : âˆ€(a : Type) â†’ f a â†’ a }
    )
â†’ âˆ€(g : Type â†’ Type)
â†’ âˆ€ ( gComonad
    : { product : âˆ€(a : Type) â†’ g a â†’ g (g a), unit : âˆ€(a : Type) â†’ g a â†’ a }
    )
â†’ { product :
        âˆ€(a : Type)
      â†’ âˆ€ ( day
          :   âˆ€(r : Type)
            â†’ (   âˆ€(b : { _1 : Type, _2 : Type })
                â†’ ({ _1 : b._1, _2 : b._2 } â†’ a)
                â†’ { _1 : f b._1, _2 : g b._2 }
                â†’ r
              )
            â†’ r
          )
      â†’ âˆ€(r : Type)
      â†’ (   âˆ€(b : { _1 : Type, _2 : Type })
          â†’ (   { _1 : b._1, _2 : b._2 }
              â†’ âˆ€(r : Type)
              â†’ (   âˆ€(b : { _1 : Type, _2 : Type })
                  â†’ ({ _1 : b._1, _2 : b._2 } â†’ a)
                  â†’ { _1 : f b._1, _2 : g b._2 }
                  â†’ r
                )
              â†’ r
            )
          â†’ { _1 : f b._1, _2 : g b._2 }
          â†’ r
        )
      â†’ r
  , unit :
        âˆ€(a : Type)
      â†’ âˆ€ ( day
          :   âˆ€(r : Type)
            â†’ (   âˆ€(b : { _1 : Type, _2 : Type })
                â†’ ({ _1 : b._1, _2 : b._2 } â†’ a)
                â†’ { _1 : f b._1, _2 : g b._2 }
                â†’ r
              )
            â†’ r
          )
      â†’ a
  }
</pre></dd>
</dl>
<h4>convolution (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      , product :
          { _1 : cObject, _2 : cObject } â†’ cObject
      , unit :
          cObject
      }
    )
â†’ âˆ€(f : cObject â†’ Type)
â†’ âˆ€(g : cObject â†’ Type)
â†’ âˆ€(a : cObject)
â†’ âˆ€(r : Type)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(cObject : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ Î» ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      , product :
          { _1 : cObject, _2 : cObject } â†’ cObject
      , unit :
          cObject
      }
    )
â†’ Î»(f : cObject â†’ Type)
â†’ Î»(g : cObject â†’ Type)
â†’ Î»(a : cObject)
â†’ Î»(r : Type)
â†’   âˆ€(b : { _1 : cObject, _2 : cObject })
  â†’ c.arrow { _1 = c.product b, _2 = a }
  â†’ v.arrow { _1 = v.product { _1 = f b._1, _2 = g b._2 }, _2 = r }
</pre></dd>
</dl>
<h4>functor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      , product :
          { _1 : cObject, _2 : cObject } â†’ cObject
      , unit :
          cObject
      }
    )
â†’ âˆ€ ( semigroupoid
    : { hom :
          { map :
                âˆ€(a : { _1 : cObject, _2 : cObject })
              â†’ âˆ€(b : { _1 : cObject, _2 : cObject })
              â†’ { _1 :
                    c.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    c.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ c.arrow a
              â†’ c.arrow b
          }
      , product :
            âˆ€(a : { _1 : cObject, _2 : cObject })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : cObject)
                  â†’ c.arrow { _1 = z, _2 = a._2 }
                  â†’ c.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ c.arrow a
      }
    )
â†’ âˆ€(f : cObject â†’ Type)
â†’ âˆ€(g : cObject â†’ Type)
â†’ { map :
        âˆ€(a : cObject)
      â†’ âˆ€(b : cObject)
      â†’ âˆ€(fn : c.arrow { _1 = a, _2 = b })
      â†’ âˆ€ ( day
          :   âˆ€(r : Type)
            â†’ (   âˆ€(b : { _1 : cObject, _2 : cObject })
                â†’ c.arrow { _1 = c.product b, _2 = a }
                â†’ { _1 : f b._1, _2 : g b._2 }
                â†’ r
              )
            â†’ r
          )
      â†’ âˆ€(r : Type)
      â†’ (   âˆ€(b : { _1 : cObject, _2 : cObject })
          â†’ c.arrow { _1 = c.product b, _2 = b@1 }
          â†’ { _1 : f b._1, _2 : g b._2 }
          â†’ r
        )
      â†’ r
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Density</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(d : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€(f : cObject â†’ Type)
â†’ âˆ€(a : Type)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(cObject : Kind)
â†’ Î»(d : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ Î»(f : cObject â†’ Type)
â†’ Î»(a : Type)
â†’ âˆ€(r : Type) â†’ (âˆ€(b : cObject) â†’ d.arrow { _1 = f b, _2 = a } â†’ f b â†’ r) â†’ r
</pre></dd>
</dl>
<h4>functor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(d : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( dSemigroupoid
    : { hom :
          { map :
                âˆ€(a : { _1 : Type, _2 : Type })
              â†’ âˆ€(b : { _1 : Type, _2 : Type })
              â†’ { _1 :
                    d.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    d.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ d.arrow a
              â†’ d.arrow b
          }
      , product :
            âˆ€(a : { _1 : Type, _2 : Type })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : Type)
                  â†’ d.arrow { _1 = z, _2 = a._2 }
                  â†’ d.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ d.arrow a
      }
    )
â†’ âˆ€(f : cObject â†’ Type)
â†’ { map :
        âˆ€(a : Type)
      â†’ âˆ€(b : Type)
      â†’ âˆ€(h : d.arrow { _1 = a, _2 = b })
      â†’ âˆ€ ( lan
          :   âˆ€(r : Type)
            â†’ (âˆ€(b : cObject) â†’ d.arrow { _1 = f b, _2 = a } â†’ f b â†’ r)
            â†’ r
          )
      â†’ âˆ€(r : Type)
      â†’ âˆ€(k : âˆ€(c : cObject) â†’ d.arrow { _1 = f c, _2 = b } â†’ f c â†’ r)
      â†’ r
  }
</pre></dd>
</dl>
<h4>lift (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€(cat : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( semigroupoid
    : { hom :
          { map :
                âˆ€(a : { _1 : Type, _2 : Type })
              â†’ âˆ€(b : { _1 : Type, _2 : Type })
              â†’ v.arrow
                { _1 =
                    v.product
                    { _1 =
                        cat.arrow { _1 = b._1, _2 = a._1 }
                    , _2 =
                        cat.arrow { _1 = a._2, _2 = b._2 }
                    }
                , _2 =
                    v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
                }
          }
      , product :
            âˆ€(a : { _1 : Type, _2 : Type })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : Type)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      }
    )
â†’ âˆ€(f : Type â†’ Type)
â†’ âˆ€ ( comonad
    : { product :
          âˆ€(a : Type) â†’ cat.arrow { _1 = f a, _2 = f (f a) }
      , unit :
          âˆ€(a : Type) â†’ cat.arrow { _1 = f a, _2 = a }
      }
    )
â†’ âˆ€(a : Type)
â†’ âˆ€(x : f a)
â†’ âˆ€(r : Type)
â†’ âˆ€(k : âˆ€(b : Type) â†’ cat.arrow { _1 = f b, _2 = a } â†’ f b â†’ r)
â†’ r
</pre></dd>
</dl>
<h4>lower (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(f : Type â†’ Type)
â†’ âˆ€(functor : { map : âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ (a â†’ b) â†’ f a â†’ f b })
â†’ âˆ€ ( comonad
    : { product : âˆ€(a : Type) â†’ f a â†’ f (f a), unit : âˆ€(a : Type) â†’ f a â†’ a }
    )
â†’ âˆ€(a : Type)
â†’ âˆ€(lan : âˆ€(r : Type) â†’ (âˆ€(b : Type) â†’ (f b â†’ a) â†’ f b â†’ r) â†’ r)
â†’ f a
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Duoid</h2>
<h4>Kind (kind)</h4>
<p>{- A duoid (also known as a â€œunited monoidâ€) is actually a pair of monoids with
   a shared `unit`.
-}</p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { diamond :
      { product : cat.arrow (cat.product m m) m, unit : m }
  , star :
      { product : cat.arrow (cat.product m m) m, unit : m }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p>{- A duoid (also known as a â€œunited monoidâ€) is actually a pair of monoids with
   a shared `unit`. The `additive.product` distributes over the
  `multiplicative.product` as well.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { additive :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  , multiplicative :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Either</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
âˆ€(a : Kind) â†’ âˆ€(b : Kind) â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
Î»(a : Kind) â†’ Î»(b : Kind) â†’ < Left : a | Right : b >
</pre></dd>
</dl>
<h4>duoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(a : Type)
â†’ âˆ€(semigroup : { product : { _1 : a, _2 : a } â†’ a })
â†’ { additive :
      { product :
            âˆ€(i : Type)
          â†’ âˆ€ ( day
              :   âˆ€(r : Type)
                â†’ (   âˆ€(d : { _1 : Type, _2 : Type })
                    â†’ ({ _1 : d._1, _2 : d._2 } â†’ i)
                    â†’ { _1 :
                          < Left : a | Right : d._1 >
                      , _2 :
                          < Left : a | Right : d._2 >
                      }
                    â†’ r
                  )
                â†’ r
              )
          â†’ < Left : a | Right : i >
      , unit :
          âˆ€(b : Type) â†’ âˆ€(fn : {} â†’ b) â†’ < Left : a | Right : b >
      }
  , multiplicative :
      { product :
            âˆ€(i : Type)
          â†’ âˆ€ ( day
              :   âˆ€(r : Type)
                â†’ (   âˆ€(b : { _1 : Type, _2 : Type })
                    â†’ ({ _1 : b._1, _2 : b._2 } â†’ i)
                    â†’ { _1 :
                          < Left : a | Right : b._1 >
                      , _2 :
                          < Left : a | Right : b._2 >
                      }
                    â†’ r
                  )
                â†’ r
              )
          â†’ < Left : a | Right : i >
      , unit :
          âˆ€(a : Type) â†’ âˆ€(fn : {} â†’ a) â†’ < Left : a@1 | Right : a >
      }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Either/functor</h3>
<h4 style="background-color: #bbb; width: 100%">./Either/functor/endo</h4>
<h4>star (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type â†’ Type)
â†’ âˆ€ ( monoidal
    : { map :
          âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ (a â†’ b) â†’ m a â†’ m b
      , product :
            âˆ€(a : Type)
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(b : { _1 : Type, _2 : Type })
                  â†’ ({ _1 : b._1, _2 : b._2 } â†’ a)
                  â†’ { _1 : m b._1, _2 : m b._2 }
                  â†’ r
                )
              â†’ r
            )
          â†’ m a
      , unit :
          âˆ€(a : Type) â†’ ({} â†’ a) â†’ m a
      }
    )
â†’ âˆ€(a : Type)
â†’ { map :
        âˆ€(b : Type)
      â†’ âˆ€(c : Type)
      â†’ âˆ€(f : b â†’ m c)
      â†’ âˆ€(e : < Left : a | Right : b >)
      â†’ m < Left : a | Right : c >
  }
</pre></dd>
</dl>
<h4 style="background-color: #bbb; width: 100%">./Either/functor/monoidal</h4>
<h4>parallel (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(a : Type)
â†’ âˆ€(semigroup : { product : { _1 : a, _2 : a } â†’ a })
â†’ { map :
        âˆ€(b : Type)
      â†’ âˆ€(c : Type)
      â†’ âˆ€(f : b â†’ c)
      â†’ âˆ€(e : < Left : a | Right : b >)
      â†’ < Left : a | Right : c >
  , product :
        âˆ€(i : Type)
      â†’ âˆ€ ( day
          :   âˆ€(r : Type)
            â†’ (   âˆ€(d : { _1 : Type, _2 : Type })
                â†’ ({ _1 : d._1, _2 : d._2 } â†’ i)
                â†’ { _1 :
                      < Left : a | Right : d._1 >
                  , _2 :
                      < Left : a | Right : d._2 >
                  }
                â†’ r
              )
            â†’ r
          )
      â†’ < Left : a | Right : i >
  , unit :
      âˆ€(b : Type) â†’ âˆ€(fn : {} â†’ b) â†’ < Left : a | Right : b >
  }
</pre></dd>
</dl>
<h4>sequential (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(a : Type)
â†’ { map :
        âˆ€(b : Type)
      â†’ âˆ€(c : Type)
      â†’ âˆ€(f : b â†’ c)
      â†’ âˆ€(e : < Left : a | Right : b >)
      â†’ < Left : a | Right : c >
  , product :
        âˆ€(i : Type)
      â†’ âˆ€ ( day
          :   âˆ€(r : Type)
            â†’ (   âˆ€(b : { _1 : Type, _2 : Type })
                â†’ ({ _1 : b._1, _2 : b._2 } â†’ i)
                â†’ { _1 :
                      < Left : a | Right : b._1 >
                  , _2 :
                      < Left : a | Right : b._2 >
                  }
                â†’ r
              )
            â†’ r
          )
      â†’ < Left : a | Right : i >
  , unit :
      âˆ€(a : Type) â†’ âˆ€(fn : {} â†’ a) â†’ < Left : a@1 | Right : a >
  }
</pre></dd>
</dl>
<h4>pair (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type â†’ Type)
â†’ âˆ€(functor : { map : âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ (a â†’ b) â†’ m a â†’ m b })
â†’ { map :
        âˆ€(a : { _1 : Type, _2 : Type })
      â†’ âˆ€(b : { _1 : Type, _2 : Type })
      â†’ âˆ€(f : { _1 : a._1 â†’ m b._1, _2 : a._2 â†’ m b._2 })
      â†’ âˆ€(e : < Left : a._1 | Right : a._2 >)
      â†’ m < Left : b._1 | Right : b._2 >
  }
</pre></dd>
</dl>
<h4>monad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(a : Type)
â†’ { product :
        âˆ€(b : Type)
      â†’ âˆ€(fa : < Left : a | Right : < Left : a | Right : b > >)
      â†’ < Left : a | Right : b >
  , unit :
      âˆ€(b : Type) â†’ âˆ€(x : b) â†’ < Left : a | Right : b >
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Eq</h2>
<h4>Type (type)</h4>
<p>{- `bool` is some sort of `Const` functor in the correct category that can be
--     converted to a `Bool`.
-- -}</p>
<dl>
<dt>kind</dt><dd><pre>
âˆ€(a : Type) â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
Î»(a : Type) â†’ { eq : a â†’ a â†’ Bool }
</pre></dd>
</dl>
<h4>eqfn (term)</h4>
<p>{- When defining properties, you almost always are trying to show the
   equivalence of two functions. This makes that easier.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(a : Type)
â†’ âˆ€(b : Type)
â†’ âˆ€(eq : { eq : b â†’ b â†’ Bool })
â†’ âˆ€(f : a â†’ b)
â†’ âˆ€(g : a â†’ b)
â†’ âˆ€(x : a)
â†’ Bool
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Eq/functor</h3>
<h4>contravariant (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ map :
      âˆ€(a : Type)
    â†’ âˆ€(b : Type)
    â†’ âˆ€(fn : b â†’ a)
    â†’ âˆ€(fa : { eq : a â†’ a â†’ Bool })
    â†’ { eq : âˆ€(x : b) â†’ âˆ€(y : b) â†’ Bool }
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Field</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { additive :
      { inverse :
          cat.arrow m m
      , product :
          cat.arrow (cat.product m m) m
      , unit :
          m
      }
  , multiplicative :
      { inverse :
          cat.arrow m m
      , product :
          cat.arrow (cat.product m m) m
      , unit :
          m
      }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Field/Ordered</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
âˆ€(m : Type) â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(m : Type)
â†’ { additive :
      { eq :
          m â†’ m â†’ Bool
      , inverse :
          m â†’ m
      , le :
          m â†’ m â†’ Bool
      , partialLE :
          m â†’ m â†’ Optional Bool
      , preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
  , multiplicative :
      { inverse :
          m â†’ m
      , preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
  }
</pre></dd>
</dl>
<h4>extractPartiallyOrderedField (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type)
â†’ âˆ€ ( field
    : { additive :
          { eq :
              m â†’ m â†’ Bool
          , inverse :
              m â†’ m
          , le :
              m â†’ m â†’ Bool
          , partialLE :
              m â†’ m â†’ Optional Bool
          , preLE :
              m â†’ m â†’ Optional Bool
          , product :
              { _1 : m, _2 : m } â†’ m
          , unit :
              {} â†’ m
          }
      , multiplicative :
          { inverse :
              m â†’ m
          , preLE :
              m â†’ m â†’ Optional Bool
          , product :
              { _1 : m, _2 : m } â†’ m
          , unit :
              {} â†’ m
          }
      }
    )
â†’ { additive :
      { eq :
          m â†’ m â†’ Bool
      , inverse :
          m â†’ m
      , partialLE :
          m â†’ m â†’ Optional Bool
      , preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
  , multiplicative :
      { inverse :
          m â†’ m
      , preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
  }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type)
â†’ âˆ€ ( field
    : { additive :
          { eq :
              m â†’ m â†’ Bool
          , inverse :
              m â†’ m
          , le :
              m â†’ m â†’ Bool
          , partialLE :
              m â†’ m â†’ Optional Bool
          , preLE :
              m â†’ m â†’ Optional Bool
          , product :
              { _1 : m, _2 : m } â†’ m
          , unit :
              {} â†’ m
          }
      , multiplicative :
          { inverse :
              m â†’ m
          , preLE :
              m â†’ m â†’ Optional Bool
          , product :
              { _1 : m, _2 : m } â†’ m
          , unit :
              {} â†’ m
          }
      }
    )
â†’ { add :
      { _1 : m, _2 : m } â†’ m
  , divide :
      âˆ€(x : { _1 : m, _2 : m }) â†’ m
  , eq :
      m â†’ m â†’ Bool
  , le :
      m â†’ m â†’ Bool
  , multiply :
      { _1 : m, _2 : m } â†’ m
  , negate :
      m â†’ m
  , one :
      {} â†’ m
  , partialLE :
      m â†’ m â†’ Optional Bool
  , reciprocal :
      m â†’ m
  , subtract :
      âˆ€(x : { _1 : m, _2 : m }) â†’ m
  , zero :
      {} â†’ m
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Field/PartiallyOrdered</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
âˆ€(m : Type) â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(m : Type)
â†’ { additive :
      { eq :
          m â†’ m â†’ Bool
      , inverse :
          m â†’ m
      , partialLE :
          m â†’ m â†’ Optional Bool
      , preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
  , multiplicative :
      { inverse :
          m â†’ m
      , preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
  }
</pre></dd>
</dl>
<h4>extractField (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type)
â†’ âˆ€ ( field
    : { additive :
          { eq :
              m â†’ m â†’ Bool
          , inverse :
              m â†’ m
          , partialLE :
              m â†’ m â†’ Optional Bool
          , preLE :
              m â†’ m â†’ Optional Bool
          , product :
              { _1 : m, _2 : m } â†’ m
          , unit :
              {} â†’ m
          }
      , multiplicative :
          { inverse :
              m â†’ m
          , preLE :
              m â†’ m â†’ Optional Bool
          , product :
              { _1 : m, _2 : m } â†’ m
          , unit :
              {} â†’ m
          }
      }
    )
â†’ { additive :
      { inverse : m â†’ m, product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m }
  , multiplicative :
      { inverse : m â†’ m, product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m }
  }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type)
â†’ âˆ€ ( field
    : { additive :
          { eq :
              m â†’ m â†’ Bool
          , inverse :
              m â†’ m
          , partialLE :
              m â†’ m â†’ Optional Bool
          , preLE :
              m â†’ m â†’ Optional Bool
          , product :
              { _1 : m, _2 : m } â†’ m
          , unit :
              {} â†’ m
          }
      , multiplicative :
          { inverse :
              m â†’ m
          , preLE :
              m â†’ m â†’ Optional Bool
          , product :
              { _1 : m, _2 : m } â†’ m
          , unit :
              {} â†’ m
          }
      }
    )
â†’ { add :
      { _1 : m, _2 : m } â†’ m
  , divide :
      âˆ€(x : { _1 : m, _2 : m }) â†’ m
  , eq :
      m â†’ m â†’ Bool
  , multiply :
      { _1 : m, _2 : m } â†’ m
  , negate :
      m â†’ m
  , one :
      {} â†’ m
  , partialLE :
      m â†’ m â†’ Optional Bool
  , reciprocal :
      m â†’ m
  , subtract :
      âˆ€(x : { _1 : m, _2 : m }) â†’ m
  , zero :
      {} â†’ m
  }
</pre></dd>
</dl>
<h4>Set (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
âˆ€(m : Type) â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(m : Type)
â†’ { additive :
      { inverse :
          m â†’ m
      , preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
  , multiplicative :
      { inverse :
          m â†’ m
      , preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { additive :
      { inverse :
          cat.arrow { _1 = m, _2 = m }
      , product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  , multiplicative :
      { inverse :
          cat.arrow { _1 = m, _2 = m }
      , product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>divide (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€ ( category
    : { associativity :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ âˆ€(c : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                , _2 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                , _2 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                }
            }
      , hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , leftIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow { _1 = a, _2 = cat.product { _1 = cat.unit, _2 = a } }
            , to :
                cat.arrow { _1 = cat.product { _1 = cat.unit, _2 = a }, _2 = a }
            }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , rightIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow { _1 = a, _2 = cat.product { _1 = a, _2 = cat.unit } }
            , to :
                cat.arrow { _1 = cat.product { _1 = a, _2 = cat.unit }, _2 = a }
            }
      , tensor :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = a._1, _2 = b._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow { _1 = cat.product a, _2 = cat.product b }
          }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( field
    : { additive :
          { inverse :
              cat.arrow { _1 = m, _2 = m }
          , product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      , multiplicative :
          { inverse :
              cat.arrow { _1 = m, _2 = m }
          , product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      }
    )
â†’ cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
</pre></dd>
</dl>
<h4>extractCommutativeRing (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( field
    : { additive :
          { inverse :
              cat.arrow { _1 = m, _2 = m }
          , product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      , multiplicative :
          { inverse :
              cat.arrow { _1 = m, _2 = m }
          , product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      }
    )
â†’ { additive :
      { inverse :
          cat.arrow { _1 = m, _2 = m }
      , product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  , multiplicative :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>extractRing (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( field
    : { additive :
          { inverse :
              cat.arrow { _1 = m, _2 = m }
          , product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      , multiplicative :
          { inverse :
              cat.arrow { _1 = m, _2 = m }
          , product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      }
    )
â†’ { additive :
      { inverse :
          cat.arrow { _1 = m, _2 = m }
      , product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  , multiplicative :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€ ( category
    : { associativity :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ âˆ€(c : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                , _2 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                , _2 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                }
            }
      , hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , leftIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow { _1 = a, _2 = cat.product { _1 = cat.unit, _2 = a } }
            , to :
                cat.arrow { _1 = cat.product { _1 = cat.unit, _2 = a }, _2 = a }
            }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , rightIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow { _1 = a, _2 = cat.product { _1 = a, _2 = cat.unit } }
            , to :
                cat.arrow { _1 = cat.product { _1 = a, _2 = cat.unit }, _2 = a }
            }
      , tensor :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = a._1, _2 = b._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow { _1 = cat.product a, _2 = cat.product b }
          }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( field
    : { additive :
          { inverse :
              cat.arrow { _1 = m, _2 = m }
          , product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      , multiplicative :
          { inverse :
              cat.arrow { _1 = m, _2 = m }
          , product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      }
    )
â†’ { add :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , divide :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , multiply :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , negate :
      cat.arrow { _1 = m, _2 = m }
  , one :
      cat.arrow { _1 = cat.unit, _2 = m }
  , reciprocal :
      cat.arrow { _1 = m, _2 = m }
  , subtract :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , zero :
      cat.arrow { _1 = cat.unit, _2 = m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Functor</h2>
<h3 style="background-color: #bbb; width: 100%">./Functor/Bifunctor</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€(cObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€(eObject : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      , product :
          { _1 : vObject, _2 : vObject } â†’ vObject
      , unit :
          vObject
      }
    )
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ vObject
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ vObject
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : eObject, _2 : eObject } â†’ vObject
      , constraint :
          eObject â†’ Type
      }
    )
â†’ âˆ€(f : { _1 : cObject, _2 : dObject } â†’ eObject)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(vObject : Kind)
â†’ Î»(cObject : Kind)
â†’ Î»(dObject : Kind)
â†’ Î»(eObject : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      , product :
          { _1 : vObject, _2 : vObject } â†’ vObject
      , unit :
          vObject
      }
    )
â†’ Î» ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ vObject
      , constraint :
          cObject â†’ Type
      }
    )
â†’ Î» ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ vObject
      , constraint :
          dObject â†’ Type
      }
    )
â†’ Î» ( d
    : { arrow :
          { _1 : eObject, _2 : eObject } â†’ vObject
      , constraint :
          eObject â†’ Type
      }
    )
â†’ Î»(f : { _1 : cObject, _2 : dObject } â†’ eObject)
â†’ { map :
        âˆ€(a : { _1 : cObject, _2 : dObject })
      â†’ âˆ€(b : { _1 : cObject, _2 : dObject })
      â†’ v.arrow
        { _1 =
            v.product
            { _1 =
                c.arrow { _1 = a._1, _2 = b._1 }
            , _2 =
                d@1.arrow { _1 = a._2, _2 = b._2 }
            }
        , _2 =
            d.arrow { _1 = f a, _2 = f b }
        }
  }
</pre></dd>
</dl>
<h4>impliedFirstFunctor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€ ( dCategory
    : { hom :
          { map :
                âˆ€(a : { _1 : dObject, _2 : dObject })
              â†’ âˆ€(b : { _1 : dObject, _2 : dObject })
              â†’ { _1 :
                    d.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    d.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ d.arrow a
              â†’ d.arrow b
          }
      , product :
            âˆ€(a : { _1 : dObject, _2 : dObject })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : dObject)
                  â†’ d.arrow { _1 = z, _2 = a._2 }
                  â†’ d.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ d.arrow a
      , unit :
          âˆ€(a : dObject) â†’ d.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(eObject : Kind)
â†’ âˆ€ ( e
    : { arrow :
          { _1 : eObject, _2 : eObject } â†’ Type
      , constraint :
          eObject â†’ Type
      }
    )
â†’ âˆ€(f : { _1 : cObject, _2 : dObject } â†’ eObject)
â†’ âˆ€ ( bifunctor
    : { map :
            âˆ€(a : { _1 : cObject, _2 : dObject })
          â†’ âˆ€(b : { _1 : cObject, _2 : dObject })
          â†’ { _1 :
                c.arrow { _1 = a._1, _2 = b._1 }
            , _2 :
                d.arrow { _1 = a._2, _2 = b._2 }
            }
          â†’ e.arrow { _1 = f a, _2 = f b }
      }
    )
â†’ âˆ€(a : dObject)
â†’ { map :
        âˆ€(g : cObject)
      â†’ âˆ€(h : cObject)
      â†’ âˆ€(fn : c.arrow { _1 = g, _2 = h })
      â†’ e.arrow { _1 = f { _1 = g, _2 = a }, _2 = f { _1 = h, _2 = a } }
  }
</pre></dd>
</dl>
<h4>impliedSecondFunctor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( cCategory
    : { hom :
          { map :
                âˆ€(a : { _1 : cObject, _2 : cObject })
              â†’ âˆ€(b : { _1 : cObject, _2 : cObject })
              â†’ { _1 :
                    c.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    c.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ c.arrow a
              â†’ c.arrow b
          }
      , product :
            âˆ€(a : { _1 : cObject, _2 : cObject })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : cObject)
                  â†’ c.arrow { _1 = z, _2 = a._2 }
                  â†’ c.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ c.arrow a
      , unit :
          âˆ€(a : cObject) â†’ c.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€(eObject : Kind)
â†’ âˆ€ ( e
    : { arrow :
          { _1 : eObject, _2 : eObject } â†’ Type
      , constraint :
          eObject â†’ Type
      }
    )
â†’ âˆ€(f : { _1 : cObject, _2 : dObject } â†’ eObject)
â†’ âˆ€ ( bifunctor
    : { map :
            âˆ€(a : { _1 : cObject, _2 : dObject })
          â†’ âˆ€(b : { _1 : cObject, _2 : dObject })
          â†’ { _1 :
                c.arrow { _1 = a._1, _2 = b._1 }
            , _2 :
                d.arrow { _1 = a._2, _2 = b._2 }
            }
          â†’ e.arrow { _1 = f a, _2 = f b }
      }
    )
â†’ âˆ€(a : cObject)
â†’ { map :
        âˆ€(b : dObject)
      â†’ âˆ€(c : dObject)
      â†’ âˆ€(fn : d.arrow { _1 = b, _2 = c })
      â†’ e.arrow { _1 = f { _1 = a, _2 = b }, _2 = f { _1 = a, _2 = c } }
  }
</pre></dd>
</dl>
<h4>Contravariant (type)</h4>
<p>{- A contravariant functor `C â†’ D` is equivalent to a covariant functor
  `C^op â†’ D`.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€(cObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      }
    )
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ vObject
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ vObject
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€(f : cObject â†’ dObject)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(vObject : Kind)
â†’ Î»(cObject : Kind)
â†’ Î»(dObject : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      }
    )
â†’ Î» ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ vObject
      , constraint :
          cObject â†’ Type
      }
    )
â†’ Î» ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ vObject
      , constraint :
          dObject â†’ Type
      }
    )
â†’ Î»(f : cObject â†’ dObject)
â†’ { map :
        âˆ€(a : cObject)
      â†’ âˆ€(b : cObject)
      â†’ v.arrow
        { _1 = c.arrow { _1 = b, _2 = a }, _2 = d.arrow { _1 = f a, _2 = f b } }
  }
</pre></dd>
</dl>
<h4>Costar (type)</h4>
<p>{- A functor from a Cokleisli category to the underlying category -}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ vObject
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€(m : object â†’ object)
â†’ âˆ€(f : object â†’ object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(vObject : Kind)
â†’ Î»(object : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      }
    )
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ vObject
      , constraint :
          object â†’ Type
      }
    )
â†’ Î»(m : object â†’ object)
â†’ Î»(f : object â†’ object)
â†’ { map :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ v.arrow
        { _1 =
            cat.arrow { _1 = m b, _2 = a }
        , _2 =
            cat.arrow { _1 = f b, _2 = f a }
        }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Functor/Endo</h3>
<h4 style="background-color: #bbb; width: 100%">./Functor/Endo/Star</h4>
<h4>Type (type)</h4>
<p>{- This is very similar to Haskellâ€™s `Traversable`, except that it can be
   implemented for an arbitrary `m`, doesnâ€™t necessarily require an
  `Applicative` instance, and also may be _more_ constrained than `Applicative`.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ vObject
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€(m : object â†’ object)
â†’ âˆ€(f : object â†’ object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(vObject : Kind)
â†’ Î»(object : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      }
    )
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ vObject
      , constraint :
          object â†’ Type
      }
    )
â†’ Î»(m : object â†’ object)
â†’ Î»(f : object â†’ object)
â†’ { map :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ v.arrow
        { _1 =
            cat.arrow { _1 = a, _2 = m b }
        , _2 =
            cat.arrow { _1 = f a, _2 = m (f b) }
        }
  }
</pre></dd>
</dl>
<h4>sequence (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€ ( category
    : { hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(f : object â†’ object)
â†’ âˆ€(g : object â†’ object)
â†’ âˆ€ ( functor
    : { map :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ cat.arrow { _1 = a, _2 = f b }
          â†’ cat.arrow { _1 = g a, _2 = f (g b) }
      }
    )
â†’ âˆ€(a : object)
â†’ cat.arrow { _1 = g (f a), _2 = f (g a) }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ vObject
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€(f : object â†’ object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(vObject : Kind)
â†’ Î»(object : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      }
    )
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ vObject
      , constraint :
          object â†’ Type
      }
    )
â†’ Î»(f : object â†’ object)
â†’ { map :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ v.arrow
        { _1 =
            cat.arrow { _1 = a, _2 = b }
        , _2 =
            cat.arrow { _1 = f a, _2 = f b }
        }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Functor/Monoidal</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      , product :
          { _1 : cObject, _2 : cObject } â†’ cObject
      , unit :
          cObject
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€(f : cObject â†’ Type)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(cObject : Kind)
â†’ Î»(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ Î» ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      , product :
          { _1 : cObject, _2 : cObject } â†’ cObject
      , unit :
          cObject
      }
    )
â†’ Î» ( d
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ Î»(f : cObject â†’ Type)
â†’ { map :
        âˆ€(a : cObject)
      â†’ âˆ€(b : cObject)
      â†’ v.arrow
        { _1 = c.arrow { _1 = a, _2 = b }, _2 = d.arrow { _1 = f a, _2 = f b } }
  , product :
        âˆ€(a : cObject)
      â†’ d.arrow
        { _1 =
              âˆ€(r : Type)
            â†’ (   âˆ€(b : { _1 : cObject, _2 : cObject })
                â†’ c.arrow { _1 = c.product b, _2 = a }
                â†’ d.product { _1 = f b._1, _2 = f b._2 }
                â†’ r
              )
            â†’ r
        , _2 =
            f a
        }
  , unit :
        âˆ€(a : cObject)
      â†’ d.arrow { _1 = c.arrow { _1 = c.unit, _2 = a }, _2 = f a }
  }
</pre></dd>
</dl>
<h4>extractFunctor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      , product :
          { _1 : cObject, _2 : cObject } â†’ cObject
      , unit :
          cObject
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€(f : cObject â†’ Type)
â†’ âˆ€ ( monoidal
    : { map :
            âˆ€(a : cObject)
          â†’ âˆ€(b : cObject)
          â†’ v.arrow
            { _1 =
                c.arrow { _1 = a, _2 = b }
            , _2 =
                d.arrow { _1 = f a, _2 = f b }
            }
      , product :
            âˆ€(a : cObject)
          â†’ d.arrow
            { _1 =
                  âˆ€(r : Type)
                â†’ (   âˆ€(b : { _1 : cObject, _2 : cObject })
                    â†’ c.arrow { _1 = c.product b, _2 = a }
                    â†’ d.product { _1 = f b._1, _2 = f b._2 }
                    â†’ r
                  )
                â†’ r
            , _2 =
                f a
            }
      , unit :
            âˆ€(a : cObject)
          â†’ d.arrow { _1 = c.arrow { _1 = c.unit, _2 = a }, _2 = f a }
      }
    )
â†’ { map :
        âˆ€(a : cObject)
      â†’ âˆ€(b : cObject)
      â†’ v.arrow
        { _1 = c.arrow { _1 = a, _2 = b }, _2 = d.arrow { _1 = f a, _2 = f b } }
  }
</pre></dd>
</dl>
<h4>extractMonoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      , product :
          { _1 : cObject, _2 : cObject } â†’ cObject
      , unit :
          cObject
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€(f : cObject â†’ Type)
â†’ âˆ€ ( monoidal
    : { map :
            âˆ€(a : cObject)
          â†’ âˆ€(b : cObject)
          â†’ v.arrow
            { _1 =
                c.arrow { _1 = a, _2 = b }
            , _2 =
                d.arrow { _1 = f a, _2 = f b }
            }
      , product :
            âˆ€(a : cObject)
          â†’ d.arrow
            { _1 =
                  âˆ€(r : Type)
                â†’ (   âˆ€(b : { _1 : cObject, _2 : cObject })
                    â†’ c.arrow { _1 = c.product b, _2 = a }
                    â†’ d.product { _1 = f b._1, _2 = f b._2 }
                    â†’ r
                  )
                â†’ r
            , _2 =
                f a
            }
      , unit :
            âˆ€(a : cObject)
          â†’ d.arrow { _1 = c.arrow { _1 = c.unit, _2 = a }, _2 = f a }
      }
    )
â†’ { product :
        âˆ€(a : cObject)
      â†’ d.arrow
        { _1 =
              âˆ€(r : Type)
            â†’ (   âˆ€(b : { _1 : cObject, _2 : cObject })
                â†’ c.arrow { _1 = c.product b, _2 = a }
                â†’ d.product { _1 = f b._1, _2 = f b._2 }
                â†’ r
              )
            â†’ r
        , _2 =
            f a
        }
  , unit :
        âˆ€(a : cObject)
      â†’ d.arrow { _1 = c.arrow { _1 = c.unit, _2 = a }, _2 = f a }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Functor/Pair</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      , product :
          { _1 : vObject, _2 : vObject } â†’ vObject
      , unit :
          vObject
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ vObject
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€(f : { _1 : object, _2 : object } â†’ object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(vObject : Kind)
â†’ Î»(object : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      , product :
          { _1 : vObject, _2 : vObject } â†’ vObject
      , unit :
          vObject
      }
    )
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ vObject
      , constraint :
          object â†’ Type
      }
    )
â†’ Î»(f : { _1 : object, _2 : object } â†’ object)
â†’ { map :
        âˆ€(a : { _1 : object, _2 : object })
      â†’ âˆ€(b : { _1 : object, _2 : object })
      â†’ v.arrow
        { _1 =
            v.product
            { _1 =
                cat.arrow { _1 = a._1, _2 = b._1 }
            , _2 =
                cat.arrow { _1 = a._2, _2 = b._2 }
            }
        , _2 =
            cat.arrow { _1 = f a, _2 = f b }
        }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Functor/Profunctor</h3>
<h4>Type (type)</h4>
<p>{- A profunctor `ğ’ â†› ğ’Ÿ` is represented as the bifunctor `(ğ’Ÿ^op, ğ’) â†’ ğ’±`. This is
   much more general than Haskellâ€™s `Profunctor`. It also requires that ğ’± is
   closed.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€(f : { _1 : dObject, _2 : cObject } â†’ Type)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(cObject : Kind)
â†’ Î»(dObject : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ Î» ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ Î» ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ Î»(f : { _1 : dObject, _2 : cObject } â†’ Type)
â†’ { map :
        âˆ€(a : { _1 : dObject, _2 : cObject })
      â†’ âˆ€(b : { _1 : dObject, _2 : cObject })
      â†’ v.arrow
        { _1 =
            v.product
            { _1 =
                d.arrow { _1 = b._1, _2 = a._1 }
            , _2 =
                c.arrow { _1 = a._2, _2 = b._2 }
            }
        , _2 =
            v.arrow { _1 = f a, _2 = f b }
        }
  }
</pre></dd>
</dl>
<h4>SetValued (type)</h4>
<p>{- A functor to *Set* from some other category.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€(f : object â†’ Type)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î»(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ Î»(f : object â†’ Type)
â†’ { map :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ v.arrow { _1 = cat.arrow { _1 = a, _2 = b }, _2 = f a â†’ f b }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Functor/Star</h3>
<h4>Type (type)</h4>
<p>{- A functor from a Kleisli category to the underlying non-Kleisli category.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ vObject
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€(m : object â†’ object)
â†’ âˆ€(f : object â†’ object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(vObject : Kind)
â†’ Î»(object : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      }
    )
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ vObject
      , constraint :
          object â†’ Type
      }
    )
â†’ Î»(m : object â†’ object)
â†’ Î»(f : object â†’ object)
â†’ { map :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ v.arrow
        { _1 =
            cat.arrow { _1 = a, _2 = m b }
        , _2 =
            cat.arrow { _1 = f a, _2 = f b }
        }
  }
</pre></dd>
</dl>
<h4>functor (term)</h4>
<p>{- If there is a natural transformation from `n` to `m`, then a m-Star functor
   can be made into an n-Star functor.
-}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€ ( category
    : { hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(f : object â†’ object)
â†’ { map :
        âˆ€(m : object â†’ object)
      â†’ âˆ€(n : object â†’ object)
      â†’ âˆ€(natural : âˆ€(a : object) â†’ cat.arrow { _1 = n a, _2 = m a })
      â†’ âˆ€ ( star
          : { map :
                  âˆ€(a : object)
                â†’ âˆ€(b : object)
                â†’ cat.arrow { _1 = a, _2 = m b }
                â†’ cat.arrow { _1 = f a, _2 = f b }
            }
          )
      â†’ { map :
              âˆ€(a : object)
            â†’ âˆ€(b : object)
            â†’ âˆ€(fn : cat.arrow { _1 = a, _2 = n b })
            â†’ cat.arrow { _1 = f a, _2 = f b }
        }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Functor/Strong</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(f : object â†’ object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î»(v : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(f : object â†’ object)
â†’ { map :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ v.arrow
        { _1 =
            cat.arrow { _1 = a, _2 = b }
        , _2 =
            cat.arrow { _1 = f a, _2 = f b }
        }
  , strengthen :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ cat.arrow
        { _1 =
            cat.product { _1 = a, _2 = f b }
        , _2 =
            f (cat.product { _1 = a, _2 = b })
        }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€(cObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      }
    )
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ vObject
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ vObject
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€(f : cObject â†’ dObject)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(vObject : Kind)
â†’ Î»(cObject : Kind)
â†’ Î»(dObject : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      }
    )
â†’ Î» ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ vObject
      , constraint :
          cObject â†’ Type
      }
    )
â†’ Î» ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ vObject
      , constraint :
          dObject â†’ Type
      }
    )
â†’ Î»(f : cObject â†’ dObject)
â†’ { map :
        âˆ€(a : cObject)
      â†’ âˆ€(b : cObject)
      â†’ v.arrow
        { _1 = c.arrow { _1 = a, _2 = b }, _2 = d.arrow { _1 = f a, _2 = f b } }
  }
</pre></dd>
</dl>
<h4>laws (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( cCategory
    : { hom :
          { map :
                âˆ€(a : { _1 : cObject, _2 : cObject })
              â†’ âˆ€(b : { _1 : cObject, _2 : cObject })
              â†’ { _1 :
                    c.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    c.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ c.arrow a
              â†’ c.arrow b
          }
      , product :
            âˆ€(a : { _1 : cObject, _2 : cObject })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : cObject)
                  â†’ c.arrow { _1 = z, _2 = a._2 }
                  â†’ c.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ c.arrow a
      , unit :
          âˆ€(a : cObject) â†’ c.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(f : cObject â†’ Type)
â†’ âˆ€ ( functor
    : { map :
            âˆ€(a : cObject)
          â†’ âˆ€(b : cObject)
          â†’ c.arrow { _1 = a, _2 = b }
          â†’ f a
          â†’ f b
      }
    )
â†’ { composition :
        âˆ€(a : cObject)
      â†’ âˆ€(b : cObject)
      â†’ âˆ€(e : cObject)
      â†’ âˆ€(eq : { eq : f e â†’ f e â†’ Bool })
      â†’ âˆ€(fn : c.arrow { _1 = b, _2 = e })
      â†’ âˆ€(gn : c.arrow { _1 = a, _2 = b })
      â†’ âˆ€(x : f a)
      â†’ Bool
  , unit :
      âˆ€(a : cObject) â†’ âˆ€(eq : { eq : f a â†’ f a â†’ Bool }) â†’ âˆ€(x : f a) â†’ Bool
  }
</pre></dd>
</dl>
<h4>opposite (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€(cObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      }
    )
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ vObject
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ vObject
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€(f : cObject â†’ dObject)
â†’ âˆ€ ( functor
    : { map :
            âˆ€(a : cObject)
          â†’ âˆ€(b : cObject)
          â†’ v.arrow
            { _1 =
                c.arrow { _1 = a, _2 = b }
            , _2 =
                d.arrow { _1 = f a, _2 = f b }
            }
      }
    )
â†’ { map :
        âˆ€(a : cObject)
      â†’ âˆ€(b : cObject)
      â†’ v.arrow
        { _1 = c.arrow { _1 = b, _2 = a }, _2 = d.arrow { _1 = f b, _2 = f a } }
  }
</pre></dd>
</dl>
<h4>void (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(dObject : Kind)
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€(f : Type â†’ dObject)
â†’ âˆ€ ( functor
    : { map :
          âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ (a â†’ b) â†’ d.arrow { _1 = f a, _2 = f b }
      }
    )
â†’ âˆ€(a : Type)
â†’ d.arrow { _1 = f a, _2 = f {} }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Group</h2>
<h3 style="background-color: #bbb; width: 100%">./Group/Commutative</h3>
<h4>Kind (kind)</h4>
<p>{- A commutative monoid implies a preorder. However, that currently forces us
   into *Set*, so we instead just alias the non-commutative type to avoid specializing.
-}</p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { inverse : cat.arrow m m, product : cat.arrow (cat.product m m) m, unit : m }
</pre></dd>
</dl>
<h4>Set (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
âˆ€(m : Type) â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(m : Type)
â†’ { inverse :
      m â†’ m
  , preLE :
      m â†’ m â†’ Optional Bool
  , product :
      { _1 : m, _2 : m } â†’ m
  , unit :
      {} â†’ m
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p>{- A commutative monoid implies a preorder. However, that currently forces us
   into *Set*, so we instead just alias the non-commutative type to avoid specializing.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { inverse :
      cat.arrow { _1 = m, _2 = m }
  , product :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , unit :
      cat.arrow { _1 = cat.unit, _2 = m }
  }
</pre></dd>
</dl>
<h4>extractCommutativeMonoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( group
    : { inverse :
          cat.arrow { _1 = m, _2 = m }
      , product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
    )
â†’ { product :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , unit :
      cat.arrow { _1 = cat.unit, _2 = m }
  }
</pre></dd>
</dl>
<h4>extractGroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( group
    : { inverse :
          cat.arrow { _1 = m, _2 = m }
      , product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
    )
â†’ { inverse :
      cat.arrow { _1 = m, _2 = m }
  , product :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , unit :
      cat.arrow { _1 = cat.unit, _2 = m }
  }
</pre></dd>
</dl>
<h4>extractMonoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( group
    : { inverse :
          cat.arrow { _1 = m, _2 = m }
      , product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
    )
â†’ { product :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , unit :
      cat.arrow { _1 = cat.unit, _2 = m }
  }
</pre></dd>
</dl>
<h4>quotient (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€ ( category
    : { associativity :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ âˆ€(c : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                , _2 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                , _2 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                }
            }
      , hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , leftIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow { _1 = a, _2 = cat.product { _1 = cat.unit, _2 = a } }
            , to :
                cat.arrow { _1 = cat.product { _1 = cat.unit, _2 = a }, _2 = a }
            }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , rightIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow { _1 = a, _2 = cat.product { _1 = a, _2 = cat.unit } }
            , to :
                cat.arrow { _1 = cat.product { _1 = a, _2 = cat.unit }, _2 = a }
            }
      , tensor :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = a._1, _2 = b._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow { _1 = cat.product a, _2 = cat.product b }
          }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( group
    : { inverse :
          cat.arrow { _1 = m, _2 = m }
      , product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
    )
â†’ cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
</pre></dd>
</dl>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { inverse : cat.arrow m m, product : cat.arrow (cat.product m m) m, unit : m }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Group/Ordered</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
âˆ€(m : Type) â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(m : Type)
â†’ { eq :
      m â†’ m â†’ Bool
  , inverse :
      m â†’ m
  , le :
      m â†’ m â†’ Bool
  , partialLE :
      m â†’ m â†’ Optional Bool
  , product :
      { _1 : m, _2 : m } â†’ m
  , unit :
      {} â†’ m
  }
</pre></dd>
</dl>
<h4>extractPartiallyOrderedGroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type)
â†’ âˆ€ ( group
    : { eq :
          m â†’ m â†’ Bool
      , inverse :
          m â†’ m
      , le :
          m â†’ m â†’ Bool
      , partialLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
    )
â†’ { eq :
      m â†’ m â†’ Bool
  , inverse :
      m â†’ m
  , partialLE :
      m â†’ m â†’ Optional Bool
  , product :
      { _1 : m, _2 : m } â†’ m
  , unit :
      {} â†’ m
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Group/OrderedCommutative</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
âˆ€(m : Type) â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(m : Type)
â†’ { eq :
      m â†’ m â†’ Bool
  , inverse :
      m â†’ m
  , le :
      m â†’ m â†’ Bool
  , partialLE :
      m â†’ m â†’ Optional Bool
  , preLE :
      m â†’ m â†’ Optional Bool
  , product :
      { _1 : m, _2 : m } â†’ m
  , unit :
      {} â†’ m
  }
</pre></dd>
</dl>
<h4>extractPartiallyOrderedCommutativeGroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type)
â†’ âˆ€ ( group
    : { eq :
          m â†’ m â†’ Bool
      , inverse :
          m â†’ m
      , le :
          m â†’ m â†’ Bool
      , partialLE :
          m â†’ m â†’ Optional Bool
      , preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
    )
â†’ { eq :
      m â†’ m â†’ Bool
  , inverse :
      m â†’ m
  , partialLE :
      m â†’ m â†’ Optional Bool
  , preLE :
      m â†’ m â†’ Optional Bool
  , product :
      { _1 : m, _2 : m } â†’ m
  , unit :
      {} â†’ m
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Group/PartiallyOrdered</h3>
<h4>Type (type)</h4>
<p>{- This is the weakest form of order provided. There is no standalone preorder,
   partial order, or anything, because there are too many possible
   instances. For the general case, just define regular functions. A
   `Group/PartiallyOrdered` constrains the instances enough for a generic â€œless
   thanâ€ to be meaningful.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
âˆ€(m : Type) â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(m : Type)
â†’ { eq :
      m â†’ m â†’ Bool
  , inverse :
      m â†’ m
  , partialLE :
      m â†’ m â†’ Optional Bool
  , product :
      { _1 : m, _2 : m } â†’ m
  , unit :
      {} â†’ m
  }
</pre></dd>
</dl>
<h4>extractEq (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type)
â†’ âˆ€ ( group
    : { eq :
          m â†’ m â†’ Bool
      , inverse :
          m â†’ m
      , partialLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
    )
â†’ { eq : m â†’ m â†’ Bool }
</pre></dd>
</dl>
<h4>extractGroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type)
â†’ âˆ€ ( group
    : { eq :
          m â†’ m â†’ Bool
      , inverse :
          m â†’ m
      , partialLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
    )
â†’ { inverse : m â†’ m, product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Group/PartiallyOrderedCommutative</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
âˆ€(m : Type) â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(m : Type)
â†’ { eq :
      m â†’ m â†’ Bool
  , inverse :
      m â†’ m
  , partialLE :
      m â†’ m â†’ Optional Bool
  , preLE :
      m â†’ m â†’ Optional Bool
  , product :
      { _1 : m, _2 : m } â†’ m
  , unit :
      {} â†’ m
  }
</pre></dd>
</dl>
<h4>extractCommutativeGroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type)
â†’ âˆ€ ( group
    : { eq :
          m â†’ m â†’ Bool
      , inverse :
          m â†’ m
      , partialLE :
          m â†’ m â†’ Optional Bool
      , preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
    )
â†’ { inverse : m â†’ m, product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m }
</pre></dd>
</dl>
<h4>extractSetCommutativeGroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type)
â†’ âˆ€ ( group
    : { eq :
          m â†’ m â†’ Bool
      , inverse :
          m â†’ m
      , partialLE :
          m â†’ m â†’ Optional Bool
      , preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
    )
â†’ { inverse :
      m â†’ m
  , preLE :
      m â†’ m â†’ Optional Bool
  , product :
      { _1 : m, _2 : m } â†’ m
  , unit :
      {} â†’ m
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { inverse :
      cat.arrow { _1 = m, _2 = m }
  , product :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , unit :
      cat.arrow { _1 = cat.unit, _2 = m }
  }
</pre></dd>
</dl>
<h4>extractMonoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( group
    : { inverse :
          cat.arrow { _1 = m, _2 = m }
      , product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
    )
â†’ { product :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , unit :
      cat.arrow { _1 = cat.unit, _2 = m }
  }
</pre></dd>
</dl>
<h4>leftQuotient (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€ ( category
    : { associativity :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ âˆ€(c : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                , _2 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                , _2 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                }
            }
      , hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , leftIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow { _1 = a, _2 = cat.product { _1 = cat.unit, _2 = a } }
            , to :
                cat.arrow { _1 = cat.product { _1 = cat.unit, _2 = a }, _2 = a }
            }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , rightIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow { _1 = a, _2 = cat.product { _1 = a, _2 = cat.unit } }
            , to :
                cat.arrow { _1 = cat.product { _1 = a, _2 = cat.unit }, _2 = a }
            }
      , tensor :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = a._1, _2 = b._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow { _1 = cat.product a, _2 = cat.product b }
          }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( group
    : { inverse :
          cat.arrow { _1 = m, _2 = m }
      , product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
    )
â†’ cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
</pre></dd>
</dl>
<h4>rightQuotient (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€ ( category
    : { associativity :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ âˆ€(c : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                , _2 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                , _2 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                }
            }
      , hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , leftIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow { _1 = a, _2 = cat.product { _1 = cat.unit, _2 = a } }
            , to :
                cat.arrow { _1 = cat.product { _1 = cat.unit, _2 = a }, _2 = a }
            }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , rightIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow { _1 = a, _2 = cat.product { _1 = a, _2 = cat.unit } }
            , to :
                cat.arrow { _1 = cat.product { _1 = a, _2 = cat.unit }, _2 = a }
            }
      , tensor :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = a._1, _2 = b._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow { _1 = cat.product a, _2 = cat.product b }
          }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( group
    : { inverse :
          cat.arrow { _1 = m, _2 = m }
      , product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
    )
â†’ cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€ ( category
    : { associativity :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ âˆ€(c : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                , _2 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                , _2 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                }
            }
      , hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , leftIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow { _1 = a, _2 = cat.product { _1 = cat.unit, _2 = a } }
            , to :
                cat.arrow { _1 = cat.product { _1 = cat.unit, _2 = a }, _2 = a }
            }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , rightIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow { _1 = a, _2 = cat.product { _1 = a, _2 = cat.unit } }
            , to :
                cat.arrow { _1 = cat.product { _1 = a, _2 = cat.unit }, _2 = a }
            }
      , tensor :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = a._1, _2 = b._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow { _1 = cat.product a, _2 = cat.product b }
          }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( group
    : { inverse :
          cat.arrow { _1 = m, _2 = m }
      , product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
    )
â†’ { inverse :
      cat.arrow { _1 = m, _2 = m }
  , leftQuotient :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , product :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , rightQuotient :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , unit :
      cat.arrow { _1 = cat.unit, _2 = m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Groupoid</h2>
<h4>Type (type)</h4>
<p>{- TODO: This would be `./../Group/Type â€¦ (./../Category/Monoidal/Profunctor
         object morphism)`, but `Category` isnâ€™t defined via `Monoid`, so we
		 prefer compatibility with that.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€(morphism : { _1 : object, _2 : object } â†’ Type)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ Î»(morphism : { _1 : object, _2 : object } â†’ Type)
â†’ { hom :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
            }
      }
  , inverse :
      âˆ€(a : { _1 : object, _2 : object }) â†’ morphism a â†’ morphism a
  , product :
        âˆ€(a : { _1 : object, _2 : object })
      â†’ (   âˆ€(r : Type)
          â†’ (   âˆ€(z : object)
              â†’ cat.arrow { _1 = z, _2 = a._2 }
              â†’ cat.arrow { _1 = a._1, _2 = z }
              â†’ r
            )
          â†’ r
        )
      â†’ cat.arrow a
  , unit :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Identity</h2>
<h4>Type (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
âˆ€(object : Kind) â†’ âˆ€(a : object) â†’ object
</pre></dd>
</dl>
<h4>adjunction (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ counit :
    âˆ€(a : Type) â†’ âˆ€(x : a) â†’ a
, leftAdjunct :
    âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ âˆ€(f : a â†’ b) â†’ a â†’ b
, rightAdjunct :
    âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ âˆ€(f : a â†’ b) â†’ a â†’ b
, unit :
    âˆ€(a : Type) â†’ âˆ€(x : a) â†’ a
}
</pre></dd>
</dl>
<h4>bimonad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€ ( category
    : { hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ { comonoid :
      { product :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
  , monoid :
      { product :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
  }
</pre></dd>
</dl>
<h4>comonad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€ ( category
    : { hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ { product :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
  , unit :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Identity/functor</h3>
<h4>endo (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : vObject, _2 : vObject } â†’ Type
      , constraint :
          vObject â†’ Type
      }
    )
â†’ âˆ€ ( vCategory
    : { hom :
          { map :
                âˆ€(a : { _1 : vObject, _2 : vObject })
              â†’ âˆ€(b : { _1 : vObject, _2 : vObject })
              â†’ { _1 :
                    v.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    v.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ v.arrow a
              â†’ v.arrow b
          }
      , product :
            âˆ€(a : { _1 : vObject, _2 : vObject })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : vObject)
                  â†’ v.arrow { _1 = z, _2 = a._2 }
                  â†’ v.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ v.arrow a
      , unit :
          âˆ€(a : vObject) â†’ v.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ vObject
      , constraint :
          object â†’ Type
      }
    )
â†’ { map :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ v.arrow
        { _1 = cat.arrow { _1 = a, _2 = b }, _2 = cat.arrow { _1 = a, _2 = b } }
  }
</pre></dd>
</dl>
<h4>monoidal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ map :
    âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ âˆ€(x : a â†’ b) â†’ a â†’ b
, product :
      âˆ€(i : Type)
    â†’ âˆ€ ( day
        :   âˆ€(r : Type)
          â†’ (   âˆ€(b : { _1 : Type, _2 : Type })
              â†’ ({ _1 : b._1, _2 : b._2 } â†’ i)
              â†’ { _1 : b._1, _2 : b._2 }
              â†’ r
            )
          â†’ r
        )
    â†’ i
, unit :
    âˆ€(a : Type) â†’ âˆ€(fn : {} â†’ a) â†’ a
}
</pre></dd>
</dl>
<h4>monad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€ ( category
    : { hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ { product :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
  , unit :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Isomorphism</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind }) â†’ âˆ€(a : Kind) â†’ âˆ€(b : Kind) â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind })
â†’ Î»(a : Kind)
â†’ Î»(b : Kind)
â†’ { from : cat.arrow b a, to : cat.arrow a b }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p>{- The 2-morphism in the 2-category ğ‚ğšğ­.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€(a : { _1 : object, _2 : object })
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ Î»(a : { _1 : object, _2 : object })
â†’ { from : cat.arrow { _1 = a._2, _2 = a._1 }, to : cat.arrow a }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Lan</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(cpObject : Kind)
â†’ âˆ€ ( cp
    : { arrow :
          { _1 : cpObject, _2 : cpObject } â†’ Type
      , constraint :
          cpObject â†’ Type
      }
    )
â†’ âˆ€(p : cObject â†’ cpObject)
â†’ âˆ€(f : cObject â†’ Type)
â†’ âˆ€(a : cpObject)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(cObject : Kind)
â†’ Î»(cpObject : Kind)
â†’ Î» ( cp
    : { arrow :
          { _1 : cpObject, _2 : cpObject } â†’ Type
      , constraint :
          cpObject â†’ Type
      }
    )
â†’ Î»(p : cObject â†’ cpObject)
â†’ Î»(f : cObject â†’ Type)
â†’ Î»(a : cpObject)
â†’ âˆ€(r : Type) â†’ (âˆ€(b : cObject) â†’ cp.arrow { _1 = p b, _2 = a } â†’ f b â†’ r) â†’ r
</pre></dd>
</dl>
<h4>functor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(cpObject : Kind)
â†’ âˆ€ ( cp
    : { arrow :
          { _1 : cpObject, _2 : cpObject } â†’ Type
      , constraint :
          cpObject â†’ Type
      }
    )
â†’ âˆ€ ( cpSemigroupoid
    : { hom :
          { map :
                âˆ€(a : { _1 : cpObject, _2 : cpObject })
              â†’ âˆ€(b : { _1 : cpObject, _2 : cpObject })
              â†’ { _1 :
                    cp.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cp.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cp.arrow a
              â†’ cp.arrow b
          }
      , product :
            âˆ€(a : { _1 : cpObject, _2 : cpObject })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : cpObject)
                  â†’ cp.arrow { _1 = z, _2 = a._2 }
                  â†’ cp.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cp.arrow a
      }
    )
â†’ âˆ€(f : cObject â†’ cpObject)
â†’ âˆ€(g : cObject â†’ Type)
â†’ { map :
        âˆ€(a : cpObject)
      â†’ âˆ€(b : cpObject)
      â†’ âˆ€(h : cp.arrow { _1 = a, _2 = b })
      â†’ âˆ€ ( lan
          :   âˆ€(r : Type)
            â†’ (âˆ€(b : cObject) â†’ cp.arrow { _1 = f b, _2 = a } â†’ g b â†’ r)
            â†’ r
          )
      â†’ âˆ€(r : Type)
      â†’ âˆ€(k : âˆ€(c : cObject) â†’ cp.arrow { _1 = f c, _2 = b } â†’ g c â†’ r)
      â†’ r
  }
</pre></dd>
</dl>
<h4>lift (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€(cat : { arrow : { _1 : Type, _2 : Type } â†’ Type, constraint : Type â†’ Type })
â†’ âˆ€ ( semigroupoid
    : { hom :
          { map :
                âˆ€(a : { _1 : Type, _2 : Type })
              â†’ âˆ€(b : { _1 : Type, _2 : Type })
              â†’ v.arrow
                { _1 =
                    v.product
                    { _1 =
                        cat.arrow { _1 = b._1, _2 = a._1 }
                    , _2 =
                        cat.arrow { _1 = a._2, _2 = b._2 }
                    }
                , _2 =
                    v.arrow { _1 = cat.arrow a, _2 = cat.arrow b }
                }
          }
      , product :
            âˆ€(a : { _1 : Type, _2 : Type })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : Type)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      }
    )
â†’ âˆ€(f : Type â†’ Type)
â†’ âˆ€ ( comonad
    : { product :
          âˆ€(a : Type) â†’ cat.arrow { _1 = f a, _2 = f (f a) }
      , unit :
          âˆ€(a : Type) â†’ cat.arrow { _1 = f a, _2 = a }
      }
    )
â†’ âˆ€(g : Type â†’ Type)
â†’ âˆ€(a : Type)
â†’ âˆ€(x : g a)
â†’ âˆ€(r : Type)
â†’ âˆ€(k : âˆ€(b : Type) â†’ cat.arrow { _1 = f b, _2 = a } â†’ g b â†’ r)
â†’ r
</pre></dd>
</dl>
<h4>lower (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(cpObject : Kind)
â†’ âˆ€ ( cp
    : { arrow :
          { _1 : cpObject, _2 : cpObject } â†’ Type
      , constraint :
          cpObject â†’ Type
      }
    )
â†’ âˆ€(h : cpObject â†’ Type)
â†’ âˆ€ ( functor
    : { map :
            âˆ€(a : cpObject)
          â†’ âˆ€(b : cpObject)
          â†’ cp.arrow { _1 = a, _2 = b }
          â†’ h a
          â†’ h b
      }
    )
â†’ âˆ€(f : cObject â†’ cpObject)
â†’ âˆ€(g : cObject â†’ Type)
â†’ âˆ€(duplicate : âˆ€(b : cObject) â†’ g b â†’ h (f b))
â†’ âˆ€(a : cpObject)
â†’ âˆ€ ( lan
    :   âˆ€(r : Type)
      â†’ (âˆ€(b : cObject) â†’ cp.arrow { _1 = f b, _2 = a } â†’ g b â†’ r)
      â†’ r
    )
â†’ h a
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Lattice</h2>
<h3 style="background-color: #bbb; width: 100%">./Lattice/Complemented</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { complement :
      cat.arrow { _1 = m, _2 = m }
  , join :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  , meet :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { join :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  , meet :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>extractJoin (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( lattice
    : { join :
          { product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      , meet :
          { product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      }
    )
â†’ { product :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , unit :
      cat.arrow { _1 = cat.unit, _2 = m }
  }
</pre></dd>
</dl>
<h4>extractMeet (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( lattice
    : { join :
          { product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      , meet :
          { product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      }
    )
â†’ { product :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , unit :
      cat.arrow { _1 = cat.unit, _2 = m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Leibniz</h2>
<h4>Kind (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ { arrow :
      âˆ€(a : { _1 : cObject, _2 : cObject }) â†’ Type
  , constraint :
      cObject â†’ Type
  }
</pre></dd>
</dl>
<h4>category (term)</h4>
<p>{- In a Leibniz category, unit is refl, and product is transitivity. -}</p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€ ( dCategory
    : { hom :
          { map :
                âˆ€(a : { _1 : dObject, _2 : dObject })
              â†’ âˆ€(b : { _1 : dObject, _2 : dObject })
              â†’ { _1 :
                    d.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    d.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ d.arrow a
              â†’ d.arrow b
          }
      , product :
            âˆ€(a : { _1 : dObject, _2 : dObject })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : dObject)
                  â†’ d.arrow { _1 = z, _2 = a._2 }
                  â†’ d.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ d.arrow a
      , unit :
          âˆ€(a : dObject) â†’ d.arrow { _1 = a, _2 = a }
      }
    )
â†’ { hom :
      { map :
            âˆ€(a : { _1 : cObject, _2 : cObject })
          â†’ âˆ€(b : { _1 : cObject, _2 : cObject })
          â†’ âˆ€ ( f
              : { _1 :
                    { subst :
                          âˆ€(f : cObject â†’ dObject)
                        â†’ d.arrow { _1 = f b._1, _2 = f a._1 }
                    }
                , _2 :
                    { subst :
                          âˆ€(f : cObject â†’ dObject)
                        â†’ d.arrow { _1 = f a._2, _2 = f b._2 }
                    }
                }
              )
          â†’ âˆ€ ( fn
              : { subst :
                      âˆ€(f : cObject â†’ dObject)
                    â†’ d.arrow { _1 = f a._1, _2 = f a._2 }
                }
              )
          â†’ { subst :
                âˆ€(f : cObject â†’ dObject) â†’ d.arrow { _1 = f b._1, _2 = f b._2 }
            }
      }
  , product :
        âˆ€(a : { _1 : cObject, _2 : cObject })
      â†’ âˆ€ ( p
          :   âˆ€(r : Type)
            â†’ (   âˆ€(z : cObject)
                â†’ { subst :
                        âˆ€(f : cObject â†’ dObject)
                      â†’ d.arrow { _1 = f z, _2 = f a._2 }
                  }
                â†’ { subst :
                        âˆ€(f : cObject â†’ dObject)
                      â†’ d.arrow { _1 = f a._1, _2 = f z }
                  }
                â†’ r
              )
            â†’ r
          )
      â†’ { subst :
            âˆ€(f : cObject â†’ dObject) â†’ d.arrow { _1 = f a._1, _2 = f a._2 }
        }
  , unit :
        âˆ€(a : cObject)
      â†’ { subst : âˆ€(f : cObject â†’ dObject) â†’ d.arrow { _1 = f a, _2 = f a } }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./List</h2>
<h3 style="background-color: #bbb; width: 100%">./List/functor</h3>
<h4>compactable (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ map :
    âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ âˆ€(f : a â†’ Optional b) â†’ âˆ€(l : List a) â†’ List b
}
</pre></dd>
</dl>
<h4 style="background-color: #bbb; width: 100%">./List/functor/endo</h4>
<h4>star (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type â†’ Type)
â†’ âˆ€ ( monoidal
    : { map :
          âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ (a â†’ b) â†’ m a â†’ m b
      , product :
            âˆ€(a : Type)
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(b : { _1 : Type, _2 : Type })
                  â†’ ({ _1 : b._1, _2 : b._2 } â†’ a)
                  â†’ { _1 : m b._1, _2 : m b._2 }
                  â†’ r
                )
              â†’ r
            )
          â†’ m a
      , unit :
          âˆ€(a : Type) â†’ ({} â†’ a) â†’ m a
      }
    )
â†’ { map :
      âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ âˆ€(f : a â†’ m b) â†’ âˆ€(fa : List a) â†’ m (List b)
  }
</pre></dd>
</dl>
<h4>monoidal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ map :
    âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ âˆ€(f : a â†’ b) â†’ âˆ€(fa : List a) â†’ List b
, product :
      âˆ€(i : Type)
    â†’ âˆ€ ( day
        :   âˆ€(r : Type)
          â†’ (   âˆ€(b : { _1 : Type, _2 : Type })
              â†’ ({ _1 : b._1, _2 : b._2 } â†’ i)
              â†’ { _1 : List b._1, _2 : List b._2 }
              â†’ r
            )
          â†’ r
        )
    â†’ List i
, unit :
    âˆ€(a : Type) â†’ âˆ€(fn : {} â†’ a) â†’ List a
}
</pre></dd>
</dl>
<h4>monad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ product :
    âˆ€(a : Type) â†’ âˆ€(mma : List (List a)) â†’ List a
, unit :
    âˆ€(a : Type) â†’ âˆ€(x : a) â†’ List a
}
</pre></dd>
</dl>
<h4>monoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(a : Type)
â†’ { product : âˆ€(x : { _1 : List a, _2 : List a }) â†’ List a, unit : {} â†’ List a }
</pre></dd>
</dl>
<h4>semigroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
âˆ€(a : Type) â†’ { product : âˆ€(x : { _1 : List a, _2 : List a }) â†’ List a }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Loop</h2>
<h4>Kind (kind)</h4>
<p>{- NB: `unit` would ideally be defined with `: cat.arrow cat.unit m`, but
       thereâ€™s no Kind-level `{}` to use there.
-}</p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { inverse : cat.arrow m m, product : cat.arrow (cat.product m m) m, unit : m }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { inverse :
      cat.arrow { _1 = m, _2 = m }
  , product :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , unit :
      cat.arrow { _1 = cat.unit, _2 = m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Magma</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { product : cat.arrow (cat.product m m) m }
</pre></dd>
</dl>
<h4>Sort (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
Sort
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ Î»(m : object)
â†’ { product : cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m } }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Monad</h2>
<h4>Type (type)</h4>
<p>{- A monad on a category C is a monoid object in the category of
   endofunctors in C induced by composition.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€(m : object â†’ object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ Î»(m : object â†’ object)
â†’ { product :
      âˆ€(a : object) â†’ cat.arrow { _1 = m (m a), _2 = m a }
  , unit :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = m a }
  }
</pre></dd>
</dl>
<h4>impliedMonoidalFunctor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(f : Type â†’ Type)
â†’ âˆ€(functor : { map : âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ (a â†’ b) â†’ f a â†’ f b })
â†’ âˆ€ ( monad
    : { product : âˆ€(a : Type) â†’ f (f a) â†’ f a, unit : âˆ€(a : Type) â†’ a â†’ f a }
    )
â†’ { map :
      âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ (a â†’ b) â†’ f a â†’ f b
  , product :
        âˆ€(i : Type)
      â†’ âˆ€ ( day
          :   âˆ€(r : Type)
            â†’ (   âˆ€(b : { _1 : Type, _2 : Type })
                â†’ ({ _1 : b._1, _2 : b._2 } â†’ i)
                â†’ { _1 : f b._1, _2 : f b._2 }
                â†’ r
              )
            â†’ r
          )
      â†’ f i
  , unit :
      âˆ€(a : Type) â†’ âˆ€(fn : {} â†’ a) â†’ f a
  }
</pre></dd>
</dl>
<h4>impliedStarfunctor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€ ( semigroupoid
    : { hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      }
    )
â†’ âˆ€(m : object â†’ object)
â†’ âˆ€ ( functor
    : { map :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ cat.arrow { _1 = a, _2 = b }
          â†’ cat.arrow { _1 = m a, _2 = m b }
      }
    )
â†’ âˆ€ ( monad
    : { product :
          âˆ€(a : object) â†’ cat.arrow { _1 = m (m a), _2 = m a }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = m a }
      }
    )
â†’ { map :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ âˆ€(f : cat.arrow { _1 = a, _2 = m b })
      â†’ cat.arrow { _1 = m a, _2 = m b }
  }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€ ( semigroupoid
    : { hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      }
    )
â†’ âˆ€(m : object â†’ object)
â†’ âˆ€ ( functor
    : { map :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ cat.arrow { _1 = a, _2 = b }
          â†’ cat.arrow { _1 = m a, _2 = m b }
      }
    )
â†’ âˆ€ ( monad
    : { product :
          âˆ€(a : object) â†’ cat.arrow { _1 = m (m a), _2 = m a }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = m a }
      }
    )
â†’ { bind :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ âˆ€(f : cat.arrow { _1 = a, _2 = m b })
      â†’ cat.arrow { _1 = m a, _2 = m b }
  , extractStarfunctor :
      { map :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ âˆ€(f : cat.arrow { _1 = a, _2 = m b })
          â†’ cat.arrow { _1 = m a, _2 = m b }
      }
  , join :
      âˆ€(a : object) â†’ cat.arrow { _1 = m (m a), _2 = m a }
  , map :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ cat.arrow { _1 = a, _2 = b }
      â†’ cat.arrow { _1 = m a, _2 = m b }
  , pure :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = m a }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Monoid</h2>
<h3 style="background-color: #bbb; width: 100%">./Monoid/Commutative</h3>
<h4>Kind (kind)</h4>
<p>{- A commutative monoid implies a preorder. However, that currently forces us
   into *Set*, so we instead just alias the non-commutative type to avoid
   specializing.
-}</p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { product : cat.arrow (cat.product m m) m, unit : m }
</pre></dd>
</dl>
<h4>Set (type)</h4>
<p>{- A commutative monoid implies a preorder. Technically, a preorder could be
   defined with `â‰¤` where both `x â‰¤ y` and `y â‰¤ x` may be false. However, with
   structural typing it makes it impossible to distinguish a preordered
   structure from a totally-ordered structure.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
âˆ€(m : Type) â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(m : Type)
â†’ { preLE :
      m â†’ m â†’ Optional Bool
  , product :
      { _1 : m, _2 : m } â†’ m
  , unit :
      {} â†’ m
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p>{- A commutative monoid implies a preorder. However, that currently forces us
   into *Set*, so we instead just alias the non-commutative type to avoid specializing.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { product :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , unit :
      cat.arrow { _1 = cat.unit, _2 = m }
  }
</pre></dd>
</dl>
<h4>extractMonoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type)
â†’ âˆ€ ( monoid
    : { preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
    )
â†’ { product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m }
</pre></dd>
</dl>
<h4>extractSemigroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( monoid
    : { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
    )
â†’ { product : cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m } }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Monoid/Hopf</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { antipode :
      cat.arrow { _1 = m, _2 = m }
  , comonoid :
      { product :
          cat.arrow { _1 = m, _2 = cat.product { _1 = m, _2 = m } }
      , unit :
          cat.arrow { _1 = m, _2 = cat.unit }
      }
  , monoid :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>Kind (kind)</h4>
<p>{- NB: `unit` would ideally be defined with `: cat.arrow cat.unit m`, but
       thereâ€™s no Kind-level `{}` to use there.
-}</p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { product : cat.arrow (cat.product m m) m, unit : m }
</pre></dd>
</dl>
<h4>Sort (term)</h4>
<p>{- TODO: Unfortunately, we donâ€™t have the common kind-level units available. So
         rather than making a type that canâ€™t be used, we just stick with
         Semigroup, and let the desired type be _named_ even if it canâ€™t be
         implemented yet.
-}</p>
<dl>
<dt>type</dt><dd><pre>
Sort
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { product :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , unit :
      cat.arrow { _1 = cat.unit, _2 = m }
  }
</pre></dd>
</dl>
<h4>extractSemigroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( monoid
    : { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
    )
â†’ { product : cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m } }
</pre></dd>
</dl>
<h4>laws (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type)
â†’ âˆ€(eq : { eq : m â†’ m â†’ Bool })
â†’ âˆ€(monoid : { product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m })
â†’ { associativity :
      âˆ€(a : m) â†’ âˆ€(b : m) â†’ âˆ€(c : m) â†’ Bool
  , leftIdentity :
      âˆ€(a : m) â†’ Bool
  , rightIdentity :
      âˆ€(a : m) â†’ Bool
  }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( monoid
    : { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
    )
â†’ { product :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , unit :
      cat.arrow { _1 = cat.unit, _2 = m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Natural</h2>
<h4>duoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(max : { _1 : Natural, _2 : Natural } â†’ Natural)
â†’ { additive :
      { product :
          { _1 : Natural, _2 : Natural } â†’ Natural
      , unit :
          {} â†’ Natural
      }
  , multiplicative :
      { product :
          âˆ€(t : { _1 : Natural, _2 : Natural }) â†’ Natural
      , unit :
          {} â†’ Natural
      }
  }
</pre></dd>
</dl>
<h4>monoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ product :
    âˆ€(t : { _1 : Natural, _2 : Natural }) â†’ Natural
, unit :
    {} â†’ Natural
}
</pre></dd>
</dl>
<h4>rig (term)</h4>
<p>{- TODO: Should be a Rig/Commutative -}</p>
<dl>
<dt>type</dt><dd><pre>
{ additive :
    { product :
        âˆ€(t : { _1 : Natural, _2 : Natural }) â†’ Natural
    , unit :
        {} â†’ Natural
    }
, multiplicative :
    { product :
        âˆ€(t : { _1 : Natural, _2 : Natural }) â†’ Natural
    , unit :
        {} â†’ Natural
    }
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./NaturalTransformation</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
âˆ€(f : Kind â†’ Kind) â†’ âˆ€(g : Kind â†’ Kind) â†’ âˆ€(a : Kind) â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
Î»(f : Kind â†’ Kind) â†’ Î»(g : Kind â†’ Kind) â†’ Î»(a : Kind) â†’ f a â†’ g a
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€(f : { _1 : cObject â†’ dObject, _2 : cObject â†’ dObject })
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(cObject : Kind)
â†’ Î»(dObject : Kind)
â†’ Î» ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ Î»(f : { _1 : cObject â†’ dObject, _2 : cObject â†’ dObject })
â†’ âˆ€(a : cObject) â†’ d.arrow { _1 = f._1 a, _2 = f._2 a }
</pre></dd>
</dl>
<h4>category (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€ ( dCategory
    : { hom :
          { map :
                âˆ€(a : { _1 : dObject, _2 : dObject })
              â†’ âˆ€(b : { _1 : dObject, _2 : dObject })
              â†’ { _1 :
                    d.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    d.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ d.arrow a
              â†’ d.arrow b
          }
      , product :
            âˆ€(a : { _1 : dObject, _2 : dObject })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : dObject)
                  â†’ d.arrow { _1 = z, _2 = a._2 }
                  â†’ d.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ d.arrow a
      , unit :
          âˆ€(a : dObject) â†’ d.arrow { _1 = a, _2 = a }
      }
    )
â†’ { hom :
      { map :
            âˆ€(a : { _1 : cObject â†’ dObject, _2 : cObject â†’ dObject })
          â†’ âˆ€(b : { _1 : cObject â†’ dObject, _2 : cObject â†’ dObject })
          â†’ âˆ€ ( f
              : { _1 :
                    âˆ€(a : cObject) â†’ d.arrow { _1 = b._1 a, _2 = a@1._1 a }
                , _2 :
                    âˆ€(a : cObject) â†’ d.arrow { _1 = a@1._2 a, _2 = b._2 a }
                }
              )
          â†’ âˆ€(fn : âˆ€(a : cObject) â†’ d.arrow { _1 = a@1._1 a, _2 = a@1._2 a })
          â†’ âˆ€(i : cObject)
          â†’ d.arrow { _1 = b._1 i, _2 = b._2 i }
      }
  , product :
        âˆ€(a : { _1 : cObject â†’ dObject, _2 : cObject â†’ dObject })
      â†’ âˆ€ ( p
          :   âˆ€(r : Type)
            â†’ (   âˆ€(z : cObject â†’ dObject)
                â†’ (âˆ€(a : cObject) â†’ d.arrow { _1 = z a, _2 = a@1._2 a })
                â†’ (âˆ€(a : cObject) â†’ d.arrow { _1 = a@1._1 a, _2 = z a })
                â†’ r
              )
            â†’ r
          )
      â†’ âˆ€(i : cObject)
      â†’ d.arrow { _1 = a._1 i, _2 = a._2 i }
  , unit :
      âˆ€(a : cObject â†’ dObject) â†’ âˆ€(i : cObject) â†’ d.arrow { _1 = a i, _2 = a i }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Optional</h2>
<h4>eq (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(a : Type)
â†’ âˆ€(eq : { eq : a â†’ a â†’ Bool })
â†’ { eq : âˆ€(x : Optional a) â†’ âˆ€(y : Optional a) â†’ Bool }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Optional/functor</h3>
<h4>compactable (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ map :
      âˆ€(a : Type)
    â†’ âˆ€(b : Type)
    â†’ âˆ€(f : a â†’ Optional b)
    â†’ âˆ€(x : Optional a)
    â†’ Optional b
}
</pre></dd>
</dl>
<h4 style="background-color: #bbb; width: 100%">./Optional/functor/endo</h4>
<h4>star (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type â†’ Type)
â†’ âˆ€ ( monoidal
    : { map :
          âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ (a â†’ b) â†’ m a â†’ m b
      , product :
            âˆ€(a : Type)
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(b : { _1 : Type, _2 : Type })
                  â†’ ({ _1 : b._1, _2 : b._2 } â†’ a)
                  â†’ { _1 : m b._1, _2 : m b._2 }
                  â†’ r
                )
              â†’ r
            )
          â†’ m a
      , unit :
          âˆ€(a : Type) â†’ ({} â†’ a) â†’ m a
      }
    )
â†’ { map :
        âˆ€(a : Type)
      â†’ âˆ€(b : Type)
      â†’ âˆ€(f : a â†’ m b)
      â†’ âˆ€(fa : Optional a)
      â†’ m (Optional b)
  }
</pre></dd>
</dl>
<h4>monoidal (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ map :
    âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ âˆ€(f : a â†’ b) â†’ âˆ€(fa : Optional a) â†’ Optional b
, product :
      âˆ€(i : Type)
    â†’ âˆ€ ( day
        :   âˆ€(r : Type)
          â†’ (   âˆ€(b : { _1 : Type, _2 : Type })
              â†’ ({ _1 : b._1, _2 : b._2 } â†’ i)
              â†’ { _1 : Optional b._1, _2 : Optional b._2 }
              â†’ r
            )
          â†’ r
        )
    â†’ Optional i
, unit :
    âˆ€(a : Type) â†’ âˆ€(fn : {} â†’ a) â†’ Optional a
}
</pre></dd>
</dl>
<h4>monad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ product :
    âˆ€(a : Type) â†’ âˆ€(mma : Optional (Optional a)) â†’ Optional a
, unit :
    âˆ€(a : Type) â†’ âˆ€(x : a) â†’ Optional a
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Quasigroup</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { inverse : cat.arrow m m, product : cat.arrow (cat.product m m) m }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ Î»(m : object)
â†’ { inverse :
      cat.arrow { _1 = m, _2 = m }
  , product :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Ran</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(cpObject : Kind)
â†’ âˆ€ ( cp
    : { arrow :
          { _1 : cpObject, _2 : cpObject } â†’ Type
      , constraint :
          cpObject â†’ Type
      }
    )
â†’ âˆ€(p : cObject â†’ cpObject)
â†’ âˆ€(f : cObject â†’ Type)
â†’ âˆ€(a : cpObject)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(cObject : Kind)
â†’ Î»(cpObject : Kind)
â†’ Î» ( cp
    : { arrow :
          { _1 : cpObject, _2 : cpObject } â†’ Type
      , constraint :
          cpObject â†’ Type
      }
    )
â†’ Î»(p : cObject â†’ cpObject)
â†’ Î»(f : cObject â†’ Type)
â†’ Î»(a : cpObject)
â†’ âˆ€(b : cObject) â†’ cp.arrow { _1 = a, _2 = p b } â†’ f b
</pre></dd>
</dl>
<h4>functor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(cpObject : Kind)
â†’ âˆ€ ( cp
    : { arrow :
          { _1 : cpObject, _2 : cpObject } â†’ Type
      , constraint :
          cpObject â†’ Type
      }
    )
â†’ âˆ€ ( cpSemigroupoid
    : { hom :
          { map :
                âˆ€(a : { _1 : cpObject, _2 : cpObject })
              â†’ âˆ€(b : { _1 : cpObject, _2 : cpObject })
              â†’ { _1 :
                    cp.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cp.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cp.arrow a
              â†’ cp.arrow b
          }
      , product :
            âˆ€(a : { _1 : cpObject, _2 : cpObject })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : cpObject)
                  â†’ cp.arrow { _1 = z, _2 = a._2 }
                  â†’ cp.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cp.arrow a
      }
    )
â†’ âˆ€(p : cObject â†’ cpObject)
â†’ âˆ€(f : cObject â†’ Type)
â†’ { map :
        âˆ€(a : cpObject)
      â†’ âˆ€(b : cpObject)
      â†’ âˆ€(fn : cp.arrow { _1 = a, _2 = b })
      â†’ âˆ€(ran : âˆ€(b : cObject) â†’ cp.arrow { _1 = a, _2 = p b } â†’ f b)
      â†’ âˆ€(c : cObject)
      â†’ âˆ€(k : cp.arrow { _1 = b, _2 = p c })
      â†’ f c
  }
</pre></dd>
</dl>
<h4>lift (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€(cpObject : Kind)
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( cp
    : { arrow :
          { _1 : cpObject, _2 : cpObject } â†’ Type
      , constraint :
          cpObject â†’ Type
      }
    )
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€ ( dSemigroupoid
    : { hom :
          { map :
                âˆ€(a : { _1 : dObject, _2 : dObject })
              â†’ âˆ€(b : { _1 : dObject, _2 : dObject })
              â†’ { _1 :
                    d.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    d.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ d.arrow a
              â†’ d.arrow b
          }
      , product :
            âˆ€(a : { _1 : dObject, _2 : dObject })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : dObject)
                  â†’ d.arrow { _1 = z, _2 = a._2 }
                  â†’ d.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ d.arrow a
      }
    )
â†’ âˆ€(h : cpObject â†’ dObject)
â†’ âˆ€ ( functor
    : { map :
            âˆ€(a : cpObject)
          â†’ âˆ€(b : cpObject)
          â†’ cp.arrow { _1 = a, _2 = b }
          â†’ d.arrow { _1 = h a, _2 = h b }
      }
    )
â†’ âˆ€(f : cObject â†’ cpObject)
â†’ âˆ€(g : cObject â†’ dObject)
â†’ âˆ€(join : âˆ€(b : cObject) â†’ d.arrow { _1 = h (f b), _2 = g b })
â†’ âˆ€(a : cpObject)
â†’ âˆ€(b : cObject)
â†’ âˆ€(k : cp.arrow { _1 = a, _2 = f b })
â†’ d.arrow { _1 = h a, _2 = g b }
</pre></dd>
</dl>
<h4>lower (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(p : Type â†’ Type)
â†’ âˆ€ ( monoidal
    : { map :
          âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ (a â†’ b) â†’ p a â†’ p b
      , product :
            âˆ€(a : Type)
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(b : { _1 : Type, _2 : Type })
                  â†’ ({ _1 : b._1, _2 : b._2 } â†’ a)
                  â†’ { _1 : p b._1, _2 : p b._2 }
                  â†’ r
                )
              â†’ r
            )
          â†’ p a
      , unit :
          âˆ€(a : Type) â†’ ({} â†’ a) â†’ p a
      }
    )
â†’ âˆ€(f : Type â†’ Type)
â†’ âˆ€(a : Type)
â†’ âˆ€(ran : âˆ€(b : Type) â†’ (a â†’ p b) â†’ f b)
â†’ f a
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Rig</h2>
<h4>Kind (kind)</h4>
<p>{- This is what is often called a â€œsemiringâ€, but here we follow the convention
   described in https://ncatlab.org/nlab/show/rig, reserving â€œsemiringâ€ for a
   rig without multiplicative unit.
-}</p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { additive :
      { product : cat.arrow (cat.product m m) m, unit : m }
  , multiplicative :
      { product : cat.arrow (cat.product m m) m, unit : m }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Rig/Near</h3>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { additive :
      { product : cat.arrow (cat.product m m) m, unit : m }
  , multiplicative :
      { product : cat.arrow (cat.product m m) m, unit : m }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { additive :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  , multiplicative :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>Set (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
âˆ€(m : Type) â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(m : Type)
â†’ { additive :
      { preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
  , multiplicative :
      { product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p>{- This is what is often called a â€œsemiringâ€, but here we follow the convention
   described in https://ncatlab.org/nlab/show/rig, reserving â€œsemiringâ€ for a
   rig without multiplicative unit.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { additive :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  , multiplicative :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>extractSemiring (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( rig
    : { additive :
          { product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      , multiplicative :
          { product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      }
    )
â†’ { additive :
      { product : cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m } }
  , multiplicative :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( rig
    : { additive :
          { product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      , multiplicative :
          { product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      }
    )
â†’ { add :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , multiply :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , one :
      cat.arrow { _1 = cat.unit, _2 = m }
  , zero :
      cat.arrow { _1 = cat.unit, _2 = m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Ring</h2>
<h3 style="background-color: #bbb; width: 100%">./Ring/Commutative</h3>
<h4>Set (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
âˆ€(m : Type) â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(m : Type)
â†’ { additive :
      { inverse :
          m â†’ m
      , preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
  , multiplicative :
      { preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { additive :
      { inverse :
          cat.arrow { _1 = m, _2 = m }
      , product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  , multiplicative :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>extractRing (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type)
â†’ âˆ€ ( ring
    : { additive :
          { inverse :
              m â†’ m
          , preLE :
              m â†’ m â†’ Optional Bool
          , product :
              { _1 : m, _2 : m } â†’ m
          , unit :
              {} â†’ m
          }
      , multiplicative :
          { preLE :
              m â†’ m â†’ Optional Bool
          , product :
              { _1 : m, _2 : m } â†’ m
          , unit :
              {} â†’ m
          }
      }
    )
â†’ { additive :
      { inverse : m â†’ m, product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m }
  , multiplicative :
      { product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m }
  }
</pre></dd>
</dl>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { additive :
      { inverse :
          cat.arrow m m
      , product :
          cat.arrow (cat.product m m) m
      , unit :
          m
      }
  , multiplicative :
      { product : cat.arrow (cat.product m m) m, unit : m }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Ring/Near</h3>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { additive :
      { inverse :
          cat.arrow m m
      , product :
          cat.arrow (cat.product m m) m
      , unit :
          m
      }
  , multiplicative :
      { product : cat.arrow (cat.product m m) m, unit : m }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { additive :
      { inverse :
          cat.arrow { _1 = m, _2 = m }
      , product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  , multiplicative :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Ring/Ordered</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
âˆ€(m : Type) â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(m : Type)
â†’ { additive :
      { eq :
          m â†’ m â†’ Bool
      , inverse :
          m â†’ m
      , le :
          m â†’ m â†’ Bool
      , partialLE :
          m â†’ m â†’ Optional Bool
      , preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
  , multiplicative :
      { product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m }
  }
</pre></dd>
</dl>
<h4>extractPartiallyOrderedRing (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type)
â†’ âˆ€ ( ring
    : { additive :
          { eq :
              m â†’ m â†’ Bool
          , inverse :
              m â†’ m
          , le :
              m â†’ m â†’ Bool
          , partialLE :
              m â†’ m â†’ Optional Bool
          , preLE :
              m â†’ m â†’ Optional Bool
          , product :
              { _1 : m, _2 : m } â†’ m
          , unit :
              {} â†’ m
          }
      , multiplicative :
          { product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m }
      }
    )
â†’ { additive :
      { eq :
          m â†’ m â†’ Bool
      , inverse :
          m â†’ m
      , partialLE :
          m â†’ m â†’ Optional Bool
      , preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
  , multiplicative :
      { product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Ring/PartiallyOrdered</h3>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
âˆ€(m : Type) â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(m : Type)
â†’ { additive :
      { eq :
          m â†’ m â†’ Bool
      , inverse :
          m â†’ m
      , partialLE :
          m â†’ m â†’ Optional Bool
      , preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
  , multiplicative :
      { product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m }
  }
</pre></dd>
</dl>
<h4>extractRing (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type)
â†’ âˆ€ ( ring
    : { additive :
          { eq :
              m â†’ m â†’ Bool
          , inverse :
              m â†’ m
          , partialLE :
              m â†’ m â†’ Optional Bool
          , preLE :
              m â†’ m â†’ Optional Bool
          , product :
              { _1 : m, _2 : m } â†’ m
          , unit :
              {} â†’ m
          }
      , multiplicative :
          { product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m }
      }
    )
â†’ { additive :
      { inverse : m â†’ m, product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m }
  , multiplicative :
      { product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m }
  }
</pre></dd>
</dl>
<h4>extractSetRing (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type)
â†’ âˆ€ ( ring
    : { additive :
          { eq :
              m â†’ m â†’ Bool
          , inverse :
              m â†’ m
          , partialLE :
              m â†’ m â†’ Optional Bool
          , preLE :
              m â†’ m â†’ Optional Bool
          , product :
              { _1 : m, _2 : m } â†’ m
          , unit :
              {} â†’ m
          }
      , multiplicative :
          { product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m }
      }
    )
â†’ { additive :
      { inverse :
          m â†’ m
      , preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
  , multiplicative :
      { product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m }
  }
</pre></dd>
</dl>
<h4>Set (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
âˆ€(m : Type) â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(m : Type)
â†’ { additive :
      { inverse :
          m â†’ m
      , preLE :
          m â†’ m â†’ Optional Bool
      , product :
          { _1 : m, _2 : m } â†’ m
      , unit :
          {} â†’ m
      }
  , multiplicative :
      { product : { _1 : m, _2 : m } â†’ m, unit : {} â†’ m }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { additive :
      { inverse :
          cat.arrow { _1 = m, _2 = m }
      , product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  , multiplicative :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>extractRig (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( ring
    : { additive :
          { inverse :
              cat.arrow { _1 = m, _2 = m }
          , product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      , multiplicative :
          { product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      }
    )
â†’ { additive :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  , multiplicative :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>subtract (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€ ( category
    : { associativity :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ âˆ€(c : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                , _2 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                , _2 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                }
            }
      , hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , leftIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow { _1 = a, _2 = cat.product { _1 = cat.unit, _2 = a } }
            , to :
                cat.arrow { _1 = cat.product { _1 = cat.unit, _2 = a }, _2 = a }
            }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , rightIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow { _1 = a, _2 = cat.product { _1 = a, _2 = cat.unit } }
            , to :
                cat.arrow { _1 = cat.product { _1 = a, _2 = cat.unit }, _2 = a }
            }
      , tensor :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = a._1, _2 = b._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow { _1 = cat.product a, _2 = cat.product b }
          }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( ring
    : { additive :
          { inverse :
              cat.arrow { _1 = m, _2 = m }
          , product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      , multiplicative :
          { product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      }
    )
â†’ cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€ ( category
    : { associativity :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ âˆ€(c : object)
          â†’ { from :
                cat.arrow
                { _1 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                , _2 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                }
            , to :
                cat.arrow
                { _1 =
                    cat.product { _1 = cat.product { _1 = a, _2 = b }, _2 = c }
                , _2 =
                    cat.product { _1 = a, _2 = cat.product { _1 = b, _2 = c } }
                }
            }
      , hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , leftIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow { _1 = a, _2 = cat.product { _1 = cat.unit, _2 = a } }
            , to :
                cat.arrow { _1 = cat.product { _1 = cat.unit, _2 = a }, _2 = a }
            }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      , rightIdentity :
            âˆ€(a : object)
          â†’ { from :
                cat.arrow { _1 = a, _2 = cat.product { _1 = a, _2 = cat.unit } }
            , to :
                cat.arrow { _1 = cat.product { _1 = a, _2 = cat.unit }, _2 = a }
            }
      , tensor :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = a._1, _2 = b._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow { _1 = cat.product a, _2 = cat.product b }
          }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( ring
    : { additive :
          { inverse :
              cat.arrow { _1 = m, _2 = m }
          , product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      , multiplicative :
          { product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      }
    )
â†’ { add :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , multiply :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , negate :
      cat.arrow { _1 = m, _2 = m }
  , one :
      cat.arrow { _1 = cat.unit, _2 = m }
  , subtract :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , zero :
      cat.arrow { _1 = cat.unit, _2 = m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Rng</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { additive :
      { inverse :
          cat.arrow m m
      , product :
          cat.arrow (cat.product m m) m
      , unit :
          m
      }
  , multiplicative :
      { product : cat.arrow (cat.product m m) m }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { additive :
      { inverse :
          cat.arrow { _1 = m, _2 = m }
      , product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  , multiplicative :
      { product : cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m } }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Semigroup</h2>
<h3 style="background-color: #bbb; width: 100%">./Semigroup/Commutative</h3>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { product : cat.arrow (cat.product m m) m }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ Î»(m : object)
â†’ { product : cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m } }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Semigroup/Inverse</h3>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { inverse : cat.arrow m m, product : cat.arrow (cat.product m m) m }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ Î»(m : object)
â†’ { inverse :
      cat.arrow { _1 = m, _2 = m }
  , product :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  }
</pre></dd>
</dl>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { product : cat.arrow (cat.product m m) m }
</pre></dd>
</dl>
<h4>Sort (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
Sort
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ Î»(m : object)
â†’ { product : cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m } }
</pre></dd>
</dl>
<h4>functor (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ âˆ€ ( semigroupoid
    : { hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      }
    )
â†’ âˆ€ ( bifunctor
    : { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ { _1 :
                cat.arrow { _1 = a._1, _2 = b._1 }
            , _2 :
                cat.arrow { _1 = a._2, _2 = b._2 }
            }
          â†’ cat.arrow { _1 = cat.product a, _2 = cat.product b }
      }
    )
â†’ { map :
        âˆ€(a : object)
      â†’ âˆ€(b : object)
      â†’ âˆ€ ( fn
          : { from :
                cat.arrow { _1 = b, _2 = a }
            , to :
                cat.arrow { _1 = a, _2 = b }
            }
          )
      â†’ âˆ€ ( fa
          : { product :
                cat.arrow { _1 = cat.product { _1 = a, _2 = a }, _2 = a }
            }
          )
      â†’ { product : cat.arrow { _1 = cat.product { _1 = b, _2 = b }, _2 = b } }
  }
</pre></dd>
</dl>
<h4>laws (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type)
â†’ âˆ€(eq : { eq : m â†’ m â†’ Bool })
â†’ âˆ€(semigroup : { product : { _1 : m, _2 : m } â†’ m })
â†’ { associativity : âˆ€(a : m) â†’ âˆ€(b : m) â†’ âˆ€(c : m) â†’ Bool }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( semigroup
    : { product : cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m } }
    )
â†’ { product : cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m } }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Semigroupoid</h2>
<h4>Type (type)</h4>
<p>{- FIXME: The `hom` profunctor should be implementable generically, however I
          canâ€˜t currently get it to compile with Dhall, so itâ€™s a member here,
          and every implementation is basically a copy/paste of
         `compose (compose f g) h`. Embedding the definition here also basically
          forces every category to be enriched over ğ’ğğ­.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€(m : { _1 : object, _2 : object } â†’ Type)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( v
    : { arrow :
          { _1 : Type, _2 : Type } â†’ Type
      , constraint :
          Type â†’ Type
      , product :
          { _1 : Type, _2 : Type } â†’ Type
      , unit :
          Type
      }
    )
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ Î»(m : { _1 : object, _2 : object } â†’ Type)
â†’ { hom :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ v.arrow
            { _1 =
                v.product
                { _1 =
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 =
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
            , _2 =
                v.arrow { _1 = m a, _2 = m b }
            }
      }
  , product :
        âˆ€(a : { _1 : object, _2 : object })
      â†’ (   âˆ€(r : Type)
          â†’ (   âˆ€(z : object)
              â†’ m { _1 = z, _2 = a._2 }
              â†’ m { _1 = a._1, _2 = z }
              â†’ r
            )
          â†’ r
        )
      â†’ m a
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Semilattice</h2>
<h3 style="background-color: #bbb; width: 100%">./Semilattice/Bounded</h3>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { product : cat.arrow (cat.product m m) m, unit : m }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { product :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , unit :
      cat.arrow { _1 = cat.unit, _2 = m }
  }
</pre></dd>
</dl>
<h4>Set (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
âˆ€(m : Type) â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(m : Type)
â†’ { partialLE :
      m â†’ m â†’ Optional Bool
  , preLE :
      m â†’ m â†’ Optional Bool
  , product :
      { _1 : m, _2 : m } â†’ m
  , unit :
      {} â†’ m
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      }
    )
â†’ Î»(m : object)
â†’ { product : cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m } }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Semiring</h2>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { additive :
      { product : cat.arrow (cat.product m m) m }
  , multiplicative :
      { product : cat.arrow (cat.product m m) m, unit : m }
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Semiring/Near</h3>
<h4>Kind (kind)</h4>
<p></p>
<dl>
<dt>sort</dt><dd><pre>
  âˆ€(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ âˆ€(m : Kind)
â†’ Kind
</pre></dd>
<dt>kind</dt><dd><pre>
  Î»(cat : { arrow : Kind â†’ Kind â†’ Kind, product : Kind â†’ Kind â†’ Kind })
â†’ Î»(m : Kind)
â†’ { additive :
      { product : cat.arrow (cat.product m m) m }
  , multiplicative :
      { product : cat.arrow (cat.product m m) m, unit : m }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { additive :
      { product : cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m } }
  , multiplicative :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>Type (type)</h4>
<p>{- This is different from what is often called a â€œsemiringâ€ as it lacks
   additive unit, but here we follow the convention described in
   https://ncatlab.org/nlab/show/rig, using the name â€œrigâ€ for what would
   traditionally be a semiring.
-}</p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ Î»(m : object)
â†’ { additive :
      { product : cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m } }
  , multiplicative :
      { product :
          cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
      , unit :
          cat.arrow { _1 = cat.unit, _2 = m }
      }
  }
</pre></dd>
</dl>
<h4>terms.dhall (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      , product :
          { _1 : object, _2 : object } â†’ object
      , unit :
          object
      }
    )
â†’ âˆ€(m : object)
â†’ âˆ€ ( semiring
    : { additive :
          { product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          }
      , multiplicative :
          { product :
              cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
          , unit :
              cat.arrow { _1 = cat.unit, _2 = m }
          }
      }
    )
â†’ { add :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , multiply :
      cat.arrow { _1 = cat.product { _1 = m, _2 = m }, _2 = m }
  , one :
      cat.arrow { _1 = cat.unit, _2 = m }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Star</h2>
<h4>Type (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(vObject : Kind)
â†’ âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ vObject
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€(m : object â†’ object)
â†’ âˆ€(a : { _1 : object, _2 : object })
â†’ vObject
</pre></dd>
</dl>
<h4>category (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€ ( semigroupoid
    : { hom :
          { map :
                âˆ€(a : { _1 : object, _2 : object })
              â†’ âˆ€(b : { _1 : object, _2 : object })
              â†’ { _1 :
                    cat.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ cat.arrow a
              â†’ cat.arrow b
          }
      , product :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : object)
                  â†’ cat.arrow { _1 = z, _2 = a._2 }
                  â†’ cat.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ cat.arrow a
      }
    )
â†’ âˆ€(m : object â†’ object)
â†’ âˆ€ ( functor
    : { map :
            âˆ€(a : object)
          â†’ âˆ€(b : object)
          â†’ cat.arrow { _1 = a, _2 = b }
          â†’ cat.arrow { _1 = m a, _2 = m b }
      }
    )
â†’ âˆ€ ( monad
    : { product :
          âˆ€(a : object) â†’ cat.arrow { _1 = m (m a), _2 = m a }
      , unit :
          âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = m a }
      }
    )
â†’ { hom :
      { map :
            âˆ€(a : { _1 : object, _2 : object })
          â†’ âˆ€(b : { _1 : object, _2 : object })
          â†’ âˆ€ ( f
              : { _1 :
                    cat.arrow { _1 = b._1, _2 = m a._1 }
                , _2 :
                    cat.arrow { _1 = a._2, _2 = m b._2 }
                }
              )
          â†’ âˆ€(fn : cat.arrow { _1 = a._1, _2 = m a._2 })
          â†’ cat.arrow { _1 = b._1, _2 = m b._2 }
      }
  , product :
        âˆ€(a : { _1 : object, _2 : object })
      â†’ âˆ€ ( p
          :   âˆ€(r : Type)
            â†’ (   âˆ€(z : object)
                â†’ cat.arrow { _1 = z, _2 = m a._2 }
                â†’ cat.arrow { _1 = a._1, _2 = m z }
                â†’ r
              )
            â†’ r
          )
      â†’ cat.arrow { _1 = a._1, _2 = m a._2 }
  , unit :
      âˆ€(a : object) â†’ cat.arrow { _1 = a, _2 = m a }
  }
</pre></dd>
</dl>
<h4>semigroupoid (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Text</h2>
<h4>monoid (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ product : âˆ€(a : { _1 : Text, _2 : Text }) â†’ Text, unit : {} â†’ Text }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Tuple</h2>
<h4>adjunction (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(s : Type)
â†’ { counit :
      âˆ€(a : Type) â†’ âˆ€(x : { _1 : s, _2 : s â†’ a }) â†’ a
  , leftAdjunct :
        âˆ€(a : Type)
      â†’ âˆ€(b : Type)
      â†’ âˆ€(f : { _1 : s, _2 : a } â†’ b)
      â†’ âˆ€(x : a)
      â†’ âˆ€(y : s)
      â†’ b
  , rightAdjunct :
        âˆ€(a : Type)
      â†’ âˆ€(b : Type)
      â†’ âˆ€(f : a â†’ s â†’ b)
      â†’ âˆ€(t : { _1 : s, _2 : a })
      â†’ b
  , unit :
      âˆ€(a : Type) â†’ âˆ€(x : a) â†’ âˆ€(y : s) â†’ { _1 : s, _2 : a }
  }
</pre></dd>
</dl>
<h4>comonad (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(a : Type)
â†’ { product :
        âˆ€(b : Type)
      â†’ âˆ€(tup : { _1 : a, _2 : b })
      â†’ { _1 : a, _2 : { _1 : a, _2 : b } }
  , unit :
      âˆ€(b : Type) â†’ âˆ€(tup : { _1 : a, _2 : b }) â†’ b
  }
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Tuple/functor</h3>
<h4 style="background-color: #bbb; width: 100%">./Tuple/functor/endo</h4>
<h4>star (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(m : Type â†’ Type)
â†’ âˆ€(functor : { map : âˆ€(a : Type) â†’ âˆ€(b : Type) â†’ (a â†’ b) â†’ m a â†’ m b })
â†’ âˆ€(a : Type)
â†’ { map :
        âˆ€(b : Type)
      â†’ âˆ€(c : Type)
      â†’ âˆ€(f : b â†’ m c)
      â†’ âˆ€(t : { _1 : a, _2 : b })
      â†’ m { _1 : a, _2 : c }
  }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Unit</h2>
<h4>eq (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ eq : {} â†’ {} â†’ Bool }
</pre></dd>
</dl>
<h4>orderedGroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ eq :
    {} â†’ {} â†’ Bool
, inverse :
    {} â†’ {}
, le :
    {} â†’ {} â†’ Bool
, partialLE :
    {} â†’ {} â†’ Optional Bool
, product :
    { _1 : {}, _2 : {} } â†’ {}
, unit :
    {} â†’ {}
}
</pre></dd>
</dl>
<h4>partiallyOrderedGroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ eq :
    {} â†’ {} â†’ Bool
, inverse :
    {} â†’ {}
, partialLE :
    {} â†’ {} â†’ Optional Bool
, product :
    { _1 : {}, _2 : {} } â†’ {}
, unit :
    {} â†’ {}
}
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Void</h2>
<h4>eq (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ eq : <> â†’ <> â†’ Bool }
</pre></dd>
</dl>
<h4>semigroup (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
{ product : âˆ€(p : { _1 : <>, _2 : <> }) â†’ <> }
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./Yoneda</h2>
<h4>Type (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
  âˆ€(object : Kind)
â†’ âˆ€ ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ âˆ€(f : object â†’ Type)
â†’ âˆ€(a : object)
â†’ Type
</pre></dd>
<dt>type</dt><dd><pre>
  Î»(object : Kind)
â†’ Î» ( cat
    : { arrow :
          { _1 : object, _2 : object } â†’ Type
      , constraint :
          object â†’ Type
      }
    )
â†’ Î»(f : object â†’ Type)
â†’ Î»(a : object)
â†’ âˆ€(b : object) â†’ cat.arrow { _1 = a, _2 = b } â†’ f b
</pre></dd>
</dl>
<h3 style="background-color: #bbb; width: 100%">./Yoneda/functor</h3>
<h4>instance (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€ ( cSemigroupoid
    : { hom :
          { map :
                âˆ€(a : { _1 : cObject, _2 : cObject })
              â†’ âˆ€(b : { _1 : cObject, _2 : cObject })
              â†’ { _1 :
                    c.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    c.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ c.arrow a
              â†’ c.arrow b
          }
      , product :
            âˆ€(a : { _1 : cObject, _2 : cObject })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : cObject)
                  â†’ c.arrow { _1 = z, _2 = a._2 }
                  â†’ c.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ c.arrow a
      }
    )
â†’ âˆ€(f : cObject â†’ Type)
â†’ { map :
        âˆ€(a : cObject)
      â†’ âˆ€(b : cObject)
      â†’ âˆ€(fn : c.arrow { _1 = a, _2 = b })
      â†’ âˆ€(ran : âˆ€(b : cObject) â†’ c.arrow { _1 = a, _2 = b } â†’ f b)
      â†’ âˆ€(c : cObject)
      â†’ âˆ€(k : c@1.arrow { _1 = b, _2 = c })
      â†’ f c
  }
</pre></dd>
</dl>
<h4>monoidal (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h4>lift (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
  âˆ€(cObject : Kind)
â†’ âˆ€ ( c
    : { arrow :
          { _1 : cObject, _2 : cObject } â†’ Type
      , constraint :
          cObject â†’ Type
      }
    )
â†’ âˆ€(dObject : Kind)
â†’ âˆ€ ( d
    : { arrow :
          { _1 : dObject, _2 : dObject } â†’ Type
      , constraint :
          dObject â†’ Type
      }
    )
â†’ âˆ€ ( dCategory
    : { hom :
          { map :
                âˆ€(a : { _1 : dObject, _2 : dObject })
              â†’ âˆ€(b : { _1 : dObject, _2 : dObject })
              â†’ { _1 :
                    d.arrow { _1 = b._1, _2 = a._1 }
                , _2 :
                    d.arrow { _1 = a._2, _2 = b._2 }
                }
              â†’ d.arrow a
              â†’ d.arrow b
          }
      , product :
            âˆ€(a : { _1 : dObject, _2 : dObject })
          â†’ (   âˆ€(r : Type)
              â†’ (   âˆ€(z : dObject)
                  â†’ d.arrow { _1 = z, _2 = a._2 }
                  â†’ d.arrow { _1 = a._1, _2 = z }
                  â†’ r
                )
              â†’ r
            )
          â†’ d.arrow a
      , unit :
          âˆ€(a : dObject) â†’ d.arrow { _1 = a, _2 = a }
      }
    )
â†’ âˆ€(f : cObject â†’ dObject)
â†’ âˆ€ ( functor
    : { map :
            âˆ€(a : cObject)
          â†’ âˆ€(b : cObject)
          â†’ c.arrow { _1 = a, _2 = b }
          â†’ d.arrow { _1 = f a, _2 = f b }
      }
    )
â†’ âˆ€(a : cObject)
â†’ âˆ€(b : cObject)
â†’ âˆ€(k : c.arrow { _1 = a, _2 = b })
â†’ d.arrow { _1 = f a, _2 = f b }
</pre></dd>
</dl>
<h4>lower (term)</h4>
<p></p>
<dl>
<dt>type</dt><dd><pre>
âˆ€(f : Type â†’ Type) â†’ âˆ€(a : Type) â†’ âˆ€(ran : âˆ€(b : Type) â†’ (a â†’ b) â†’ f b) â†’ f a
</pre></dd>
</dl>
<h4>monad (type)</h4>
<p></p>
<dl>
<dt>kind</dt><dd><pre>
Type
</pre></dd>
<dt>type</dt><dd><pre>
<>
</pre></dd>
</dl>
<h2 style="background-color: #bbb; width: 100%">./docs</h2>
<h2 style="background-color: #bbb; width: 100%">./scripts</h2>
</body></html>
