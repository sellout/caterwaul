{- This is very similar to Haskell’s `Traversable`, except that it can be
   implemented for an arbitrary `m`, doesn’t necessarily require an
  `Applicative` instance, and also may be _more_ constrained than `Applicative`.
-}
let kArrow = ./../../../Function/Kind

let kProduct = ./../../../Tuple/Kind

in    λ(vObject : Kind)
    → λ(object : Kind)
    → λ(v : ./../../../Category/Kind kArrow kProduct Type vObject)
    → λ(cat : ./../../../Category/Kind kArrow kProduct vObject object)
    → λ(m : kArrow object object)
    → ./../Type
      vObject
      object
      v
      (./../../../Category/Kleisli/category vObject object cat m)
