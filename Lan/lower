let kArrow = ./../Function/Kind

let kProduct = ./../Tuple/Kind

let base = ./../Category/Monoidal/extractCategory kArrow kProduct

let vObject = Type

let v = base Type vObject ./../Category/Set/monoidal/cartesian

in    λ(cObject : Kind)
    → λ(cpObject : Kind)
    → λ(cp : ./../Category/Kind kArrow kProduct vObject cpObject)
    → let dObject = Type
      
      let d = base vObject dObject ./../Category/Set/monoidal/cartesian
      
      let dSemigroupoid = ./../Category/Set/semigroupoid
      
      in    λ(h : kArrow cpObject dObject)
          → λ(functor : ./../Functor/Type vObject cpObject dObject v cp d h)
          → λ(f : kArrow cObject cpObject)
          → λ(g : kArrow cObject dObject)
          → λ(duplicate : ∀(b : cObject) → d.arrow { _1 = g b, _2 = h (f b) })
          → λ(a : cpObject)
          → λ(lan : ./Type cObject cpObject cp f g a)
          → lan
            (h a)
            (   λ(b : cObject)
              → λ(k : cp.arrow { _1 = f b, _2 = a })
              → dSemigroupoid.op
                { _1 = g b, _2 = h a }
                (   λ(r : Type)
                  → λ ( arrowsOut
                      :   ∀(z : dObject)
                        → d.arrow { _1 = z, _2 = h a }
                        → d.arrow { _1 = g b, _2 = z }
                        → r
                      )
                  → arrowsOut (h (f b)) (functor.map (f b) a k) (duplicate b)
                )
            )
