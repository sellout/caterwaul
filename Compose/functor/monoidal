{- NB: Since this is currently forced to be in *Set*, it’s quite possible that
       some of the uses of _C_ and _D_ are wrong, since the type system can’t
       distinguish them. So take them with a grain of salt if you’re editing
       this file.
-}
let kArrow =
      ./../../Function/Kind sha256:0b6372c593badac5fe880699fd1cf19dfba07c62fab935a8bad96915866f466e

let kProduct =
      ./../../Tuple/Kind sha256:03e1c52890f0cda1a2181cd3eb045d5344fc7c907fcbf836736c0e3222c5ffd8

let MonoidalFunctor =
      ./../../Functor/Monoidal/Type sha256:bf47360872158ca906f90c060e3a3339c2ca60a630baa0446884e840ca7fbf70

in    λ ( cObject
        : Kind
        )
    → λ ( c
        : ./../../Category/Monoidal/Kind sha256:c90d64b23bd9269a630ed0e3c5202fef1969034543a57c20db10215d7092fe22
          kArrow
          kProduct
          cObject
        )
    → let dObject =
            Type
      
      let d =
            ./../../Category/Set/monoidal/cartesian sha256:b3c97e385d62b718ab11e540a98141cb81b89db0d7c1115ec11b330c596dcf01
      
      let eObject = Type
      
      let e =
            ./../../Category/Set/monoidal/cartesian sha256:b3c97e385d62b718ab11e540a98141cb81b89db0d7c1115ec11b330c596dcf01
      
      let Compose =
            ./../Type sha256:e18cb4b2004c6cf2789b492be4e1b912e3299eca94c229dc5913a11d55bcd72c
            cObject
            dObject
            eObject
      
      let Day =
            ./../../Day/Type sha256:681b4b22f4cd4484c75a93d75c4c4a58c7d7b146d8f9e1a52602b49a8fb51f87
            cObject
            c
            e
      
      let Day/convolution =
            ./../../Day/convolution sha256:dffad22f69e29116debfd7702a83fae5a1278fa46a80668aa9730c28c1afdd02
      
      in    λ(f : kArrow dObject eObject)
          → λ(fMonoidal : MonoidalFunctor dObject d e f)
          → λ(g : kArrow cObject dObject)
          → λ(gMonoidal : MonoidalFunctor cObject c d g)
          →   { map =
                    λ(a : cObject)
                  → λ(b : cObject)
                  → λ(k : c.arrow { _1 = a, _2 = b })
                  → fMonoidal.map (g a) (g b) (gMonoidal.map a b k)
              , identity =
                    λ(a : cObject)
                  → λ(fn : c.arrow { _1 = c.identity, _2 = a })
                  → fMonoidal.identity
                    (g a)
                    (λ(_ : d.identity) → gMonoidal.identity a fn)
              , op =
                    λ(i : cObject)
                  → λ ( day
                      : Day
                        { _1 =
                            Compose { _1 = f, _2 = g }
                        , _2 =
                            Compose { _1 = f, _2 = g }
                        }
                        i
                      )
                  → day
                    (f (g i))
                    (   λ(b : { _1 : cObject, _2 : cObject })
                      → λ(fn : c.arrow { _1 = c.op b, _2 = i })
                      → λ(a : { _1 : f (g b._1), _2 : f (g b._2) })
                      → fMonoidal.op
                        (g i)
                        (   λ(fr : eObject)
                          → λ(fDay : Day/convolution dObject d e f f (g i) fr)
                          → fDay
                            { _1 = g b._1, _2 = g b._2 }
                            (   λ(p : { _1 : g b._1, _2 : g b._2 })
                              → gMonoidal.op
                                i
                                (   λ(gr : dObject)
                                  → λ ( gDay
                                      : Day/convolution cObject c d g g i gr
                                      )
                                  → gDay b fn p
                                )
                            )
                            a
                        )
                    )
              }
            : MonoidalFunctor cObject c e (Compose { _1 = f, _2 = g })
