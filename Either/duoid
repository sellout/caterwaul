let kArrow = ./../Function/Kind

let kProduct = ./../Tuple/Kind

let vObject = Type

let v =
      ./../Category/Monoidal/extractCategory
      kArrow
      kProduct
      Type
      vObject
      ./../Category/Set/monoidal/cartesian

let object = Type

let Set = ./../Category/Set/rig

let cat =
      ./../Category/Rig/extractMultiplicative kArrow kProduct vObject object Set

let CommutativeSemigroup =
      ./../Semigroup/Commutative/Type
      object
      ( ./../Category/Monoidal/extractSemigroupal
        kArrow
        kProduct
        vObject
        object
        cat
      )

let extractMonoid = ./../Functor/Monoidal/extractMonoid object v cat cat

in    λ(a : object)
    → λ(semigroup : CommutativeSemigroup a)
    →   { additive =
            extractMonoid
            (λ(b : object) → Set.additive.op { _1 = a, _2 = b })
            (./functor/monoidal/parallel a semigroup)
        , multiplicative =
            extractMonoid
            (λ(b : object) → Set.additive.op { _1 = a, _2 = b })
            (./functor/monoidal/sequential a)
        }
      : ./../Duoid/Type
        (kArrow object object)
        (./../Category/Endofunctor/monoidal/functor v cat)
        (λ(b : object) → Set.additive.op { _1 = a, _2 = b })
