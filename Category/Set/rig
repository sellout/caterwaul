let kArrow = ./../../Function/Kind

let kProduct = ./../../Tuple/Kind

in    { constraint =
          λ(t : Type) → ./../../Const/Type Type Type { _1 = {}, _2 = t }
      , arrow =
          ./../../Function/Type
      , additive =
          { identity = <>, op = ./../../Either/Type }
      , multiplicative =
          { identity = {}, op = ./../../Tuple/Type }
      }
    : ./../Rig/Kind kArrow kProduct Type
