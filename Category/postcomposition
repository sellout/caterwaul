let kArrow = ./../Function/Kind

let kProduct = ./../Tuple/Kind

let vObject = Type

let v = ./Set/monoidal/cartesian

let vBase = ./Monoidal/extractCategory kArrow kProduct Type vObject v

in    λ(object : Kind)
    → λ(cat : ./Kind kArrow kProduct vObject object)
    → λ(category : ./Type object v cat)
    → λ(c : object)
    →   { map =
              λ(x : object)
            → λ(y : object)
            → λ(fn : cat.arrow { _1 = x, _2 = y })
            → λ(input : cat.arrow { _1 = c, _2 = x })
            → category.op
              { _1 = c, _2 = y }
              (   λ(r : Type)
                → λ ( arrowsOut
                    :   ∀(z : object)
                      → cat.arrow { _1 = z, _2 = y }
                      → cat.arrow { _1 = c, _2 = z }
                      → r
                    )
                → arrowsOut x fn input
              )
        }
      : ./../Functor/Type
        vObject
        object
        vObject
        vBase
        cat
        vBase
        (λ(x : object) → cat.arrow { _1 = c, _2 = x })
