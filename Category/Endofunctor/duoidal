{- NB: This is defined in terms of the monoidal categories instead of the other
       way around because this is more restrictive than either monoidal
       category.
     • Applicative requires that the target category is **Set** and
     • monadic requires an endofunctor`object`.
       When you combine these two restrictions, you end up only being able to
       support endofunctors in **Set**.
-}
let kCat =
      ./../Cat/semigroupal sha256:de5b05c9640ea3ca0ee586c7102a982db79d3c0f0c92230cb2df19c7b986b513

let vObject = Type

let object = Type

in    λ ( v
        : ./../../Category/Kind sha256:c73426d12cddcdfc44b6e687fc897f7ef91fcda0c4da116a91acdca4d15c68a2
          kCat
          Type
          vObject
        )
    → λ ( cat
        : ./../../Category/Monoidal/Kind sha256:6eb37e632903173c5ec1600564aa614697c4b58719773c4e4c66a76f095d1636
          kCat
          vObject
          object
        )
    → let applicative =
            ./../Functor/monoidal sha256:ca31ba197edb1e6fe3e901c7e628430170df1367d5ece052734749b4a757c054
            object
            v
            cat
            cat
      
      let monadic =
            ./monoidal/monadic sha256:6c2ff9a2294a8955a06b7ccad72ba28e11587ecb0882b7ecd1702b56c59d2f38
            object
            v
            ( ./../../Category/Monoidal/extractCategory sha256:936b393338b8dcf60af6c25ecea2b0b02d83e18acfed60ff736754fe0c1d7b3d
              kCat
              vObject
              object
              cat
            )
      
      in    { constraint =
                monadic.constraint
            , arrow =
                applicative.arrow
            , additive =
                { identity = applicative.identity, op = applicative.op }
            , multiplicative =
                { identity = monadic.identity, op = monadic.op }
            }
          : ./../Duoidal/Kind sha256:477d8185fbbe496496f87216c1204a2367ff703d5ca3b0c7495f17c43ac4dec6
            kCat
            vObject
            (kCat.arrow object object)
